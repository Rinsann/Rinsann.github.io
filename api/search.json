[{"id":"96b67f8842f46b7b02f3deffef8158e9","title":"Hexo 隐藏文章","content":"使用该 Hexo 插件可以在博客中隐藏指定的文章，并使它们仅可通过链接访问。\n当一篇文章被设置为「隐藏」时，它不会出现在任何列表中（包括首页、存档、分类页面、标签页面、Feed、站点地图等），也不会被搜索引擎索引（前提是搜索引擎遵守 noindex 标签）。\n只有知道文章链接的人才可以访问被隐藏的文章。\nGithub 地址：https://github.com/printempw/hexo-hide-posts\n安装在站点根目录下执行 npm install hexo-hide-posts --save\n配置在站点目录下的\\_config.yml 中如下配置：\n# hexo-hide-posts\nhide_posts:\n  # 可以改成其他你喜欢的名字\n  filter: hidden\n  # 指定你想要传递隐藏文章的位置，比如让所有隐藏文章在存档页面可见\n  # 常见的位置有：index, tag, category, archive, sitemap, feed, etc.\n  # 留空则默认全部隐藏\n  public_generators: []\n  # 为隐藏的文章添加 noindex meta 标签，阻止搜索引擎收录\n  noindex: true\n\n举个栗子：设置 filter: secret 之后，你就可以在 front-matter 中使用 secret: true 来隐藏文章了。\n使用\n在文章的属性中定义 hidden: true 即可隐藏文章。\ntitle: 'Hidden Post'\ndate: '2021/03/05 21:45:14'\nhidden: true\n\n虽然首页上被隐藏了，但你仍然可以通过 https://hexo.test/lorem-ipsum/ 链接访问它。\n你可以在命令行运行 hexo hidden:list 来获取当前所有的已隐藏文章列表。\n插件也在 Local Variables 中添加了 all_posts 和 hidden_posts 变量，供自定义主题使用。\n","slug":"Hexo隐藏文章","date":"2022-07-10T03:30:49.000Z","categories_index":"","tags_index":"Hexo","author_index":"R桑"},{"id":"fc5e39806758c28d6affaf6d452a0421","title":"back-stage","content":"6 种组件间通信方式一、 props\n适用场景：父子组件通信\n注意事项：\n如果父组件给子组件传递函数：本质其实是希望子组件给父组件传递数据\n如果父组件给子组件传递的数据（非函数）：本质就是父组件直接给子组件传递数据\nprops 书写方式：3 种\n[&#39;todos&#39;],&#123;type:Array&#125;,&#123;type:Array,default:[]&#125;\n\n小提示：路由也可以传递 props\n书写形式：布尔值，对象，函数形式\n二、自定义事件\n适用于场景：子组件给父组件传递数据\n\n$on 和 $emit\n\n三、全局事件总线$bus\nhidden: true\nVue.prototype.$bus = this\n\n四、pubsub-js\n在 react 框架的项目中适用比较多，（发布订阅模式）\n同样适用于任意场景\n五、Vuex\n适用于场景：子组件给父组件传递数据\n六、插槽\n适用于父子组件通信 — 一般是结构（标签）\n插槽分类有：\n\n默认插槽\n具名插槽\n作用域插槽\n\n事件注意事项Vue事件\n系统事件 click、双击、鼠标系列等等\n自定义事件\n\n不管是系统事件还是自定义事件都需要注意事件源、事件类型、以及事件回调\n\n原生DOM，比如button可以绑定系统事件click单击事件等等\n组件标签 event1 可以绑定系统事件但是不起作用，因为属于自定义事件，需要加上 .native 把自定义事件变为原生DOM事件\n\n&lt;h1&gt;EventTest组件&lt;&#x2F;h1&gt;\n&lt;!-- 原生DOM事件 --&gt;\n&lt;button @click&#x3D;&quot;handler&quot;&gt;原生btn按钮&lt;&#x2F;button&gt;\n&lt;!-- 使用Event1组件：底下这个组件  @click.native 原生DOM事件，给Event1组件的根元素绑定了利用事件的委派点击里面的子元素也会触发事件--&gt;\n&lt;Event1 @click.native&#x3D;&quot;handler1&quot;&gt;&lt;&#x2F;Event1&gt;\n&lt;hr&#x2F;&gt;\n&lt;!-- 自定义事件对于原生DOM没有任何意义 因为给原生DOM绑定是没有 $emit 的 --&gt;\n&lt;!-- &lt;button @erha&#x3D;&quot;handler3&quot;&gt; 原生的btn&lt;&#x2F;button&gt; --&gt;\n&lt;Event2 @click&#x3D;&quot;handler2&quot; @xxx&#x3D;&quot;handler2&quot;&gt;&lt;&#x2F;Event2&gt;\n&lt;!-- 表单元素 color:选取颜色  range：范围条 date：日历 week--&gt;\n&lt;input type&#x3D;&quot;week&quot; &#x2F;&gt;\n\n\n\n属性修饰符 sync:money.sync 代表父组件给子组件传递一个props &#39;money&#39; 同时给当前子组件绑定一个自定义事件 update:money\n$listeners 与 $attrs 属性它们两者手势组件实例的属性，可以获取到父组件给子组件传递的props 和自定义事件\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h2&gt;自定义带Hover提示的按钮&lt;&#x2F;h2&gt;\n    &lt;!-- 当用户使用封装好的按钮的时候，需要向HintButton组件传递响应的参数 --&gt;\n    &lt;HintButton\n      type&#x3D;&quot;success&quot;\n      icon&#x3D;&quot;el-icon-delete&quot;\n      size&#x3D;&quot;mini&quot;\n      title&#x3D;&quot;提示按钮&quot;\n      @click&#x3D;&quot;handler&quot;\n    &#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport HintButton from &#39;.&#x2F;HintButton&#x2F;index.vue&#39;\nexport default &#123;\n  name: &#39;AttrsListenersTest&#39;,\n  components: &#123;\n    HintButton\n  &#125;,\n  methods: &#123;\n    handler () &#123;\n      console.log(6666)\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n\n&lt;template&gt;\n  &lt;!-- 可以利用 a 标签实现按钮带有提示功能 --&gt;\n  &lt;a :title&#x3D;&quot;title&quot;&gt;\n    &lt;!-- 下面的这种写法，不能使用:简写和@简写 --&gt;\n    &lt;el-button v-bind&#x3D;&quot;$attrs&quot; v-on&#x3D;&quot;$listeners&quot;&gt;&lt;&#x2F;el-button&gt;\n  &lt;&#x2F;a&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &quot;&quot;,\n  props: [&#39;title&#39;],\n  mounted () &#123;\n    &#x2F;&#x2F; $attrs属于组件的一个属性。可以获取到父组件传递过来的props数据\n    &#x2F;&#x2F; 对于子组件而言，父组件的数据可以利用props接收，但是需要注意，如果子组件通过props接收的属性，在$attrs属性中是获取不到的\n    console.log(this.$attrs)\n    &#x2F;&#x2F; $listeners 也是组件实例自身的一个属性，它可以获取到父组件给子组件传递的自定义事件\n    console.log(this.$listeners)\n  &#125;\n&#125;;\n&lt;&#x2F;script&gt;\n\n\n\n$children 属性和 $parentref 可以获取到某一个组件、子组件的节点\n$children 是组件实例的属性，可以获取到当前组件的全部子组件，$children 返回的是一个数组\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h2&gt;BABA有存款: &#123;&#123; money &#125;&#125;&lt;&#x2F;h2&gt;\n    &lt;button @click&#x3D;&quot;JieQianFromXM(100)&quot;&gt;找小明借钱100&lt;&#x2F;button&gt;\n    &lt;br&#x2F;&gt;\n    &lt;button @click&#x3D;&quot;JieQianFromXH(150)&quot;&gt;找小红借钱150&lt;&#x2F;button&gt;\n    &lt;br&#x2F;&gt;\n    &lt;button @click&#x3D;&quot;JieQianAll(200)&quot;&gt;找所有孩子借钱200&lt;&#x2F;button&gt;\n    &lt;br&#x2F;&gt;\n    &lt;br&#x2F;&gt;\n    &lt;!-- 小明 ref 可以获取节点 组价标签 --&gt;\n    &lt;Son ref&#x3D;&quot;xm&quot;&#x2F;&gt;\n    &lt;br&#x2F;&gt;\n    &lt;!-- 小红 --&gt;\n    &lt;Daughter ref&#x3D;&quot;xh&quot;&#x2F;&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Son from &quot;.&#x2F;Son&quot;;\nimport Daughter from &quot;.&#x2F;Daughter&quot;;\n\nexport default &#123;\n  name: &quot;ChildrenParentTest&quot;,\n  data () &#123;\n    return &#123;\n      money: 1000,\n    &#125;;\n  &#125;,\n\n  methods: &#123;\n    JieQianFromXM (money) &#123;\n      &#x2F;&#x2F; 父组件的钱数累加100元\n      this.money +&#x3D; money\n      &#x2F;&#x2F; ref 可以获取到真实DOM节点，当然也可以获取到子组件的标签可以操作子组件的数据和方法\n      this.$refs.xm.money -&#x3D; money\n    &#125;,\n    JieQianFromXH (money) &#123;\n      this.money +&#x3D; money\n      this.$refs.xh.money -&#x3D; money\n    &#125;,\n    JieQianAll (money) &#123;\n      &#x2F;&#x2F; 组件实例自身拥有一个属性 $children 可以获取到当前组件中全部的子组件\n      this.$children.forEach(item &#x3D;&gt; &#123;\n        item.money -&#x3D; money\n        this.money +&#x3D; money\n      &#125;)\n    &#125;\n  &#125;,\n\n  components: &#123;\n    Son,\n    Daughter,\n  &#125;,\n&#125;;\n&lt;&#x2F;script&gt;\n\n&lt;style&gt;&lt;&#x2F;style&gt;\n\n$parent 组件实例的属性，可以获取当前组件的父组件，进而操作父组件的数据和方法\n&lt;template&gt;\n  &lt;div style&#x3D;&quot;background: #ccc; height: 50px;&quot;&gt;\n    &lt;h3&gt;儿子小明: 有存款: &#123;&#123; money &#125;&#125;&lt;&#x2F;h3&gt;\n    &lt;button @click&#x3D;&quot;geiQian(50)&quot;&gt;给BABA钱: 50&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n  name: &#39;Son&#39;,\n  data () &#123;\n    return &#123;\n      money: 30000\n    &#125;\n  &#125;,\n\n  methods: &#123;\n    geiQian (money) &#123;\n      this.money -&#x3D; money\n      &#x2F;&#x2F;  需要在子组件内部，获取到父组件，让父组件的数据加上 50\n      this.$parent.money +&#x3D; money\n    &#125;\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n\n混入 mixin如果项目当中出现很多结构类似的功能，需要使用组件复用，JS 业务逻辑类似可以使用 mixin，把多个组件JS部分重复的地方进行复用。\nexport default &#123;\n // 对外暴露的对象，放置组件重复的业务逻辑\n methods: &#123;\n  giveMoney (money) &#123;\n   this.money -= money\n   //  需要在子组件内部，获取到父组件，让父组件的数据加上 50\n   this.$parent.money += money\n  &#125;\n &#125;\n&#125;\n\n使用\n&lt;template&gt;\n  &lt;div style&#x3D;&quot;background: #ccc; height: 50px;&quot;&gt;\n    &lt;h3&gt;女儿小红: 有存款: &#123;&#123; money &#125;&#125;&lt;&#x2F;h3&gt;\n    &lt;button @click&#x3D;&quot;giveMoney(100)&quot;&gt;给BABA钱: 100&lt;&#x2F;button&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport mixin from &#39;@&#x2F;pages&#x2F;Communication&#x2F;Mixins&#x2F;mixin&#39;\n\nexport default &#123;\n  name: &#39;Daughter&#39;,\n  mixins: [mixin],\n  data () &#123;\n    return &#123;\n      money: 20000\n    &#125;\n  &#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n\n\n插槽插槽可以实现父子组件通信（结构的通信）\n插槽有：\n\n默认插槽\n具名插槽\n作用域插槽：子组件的数据来源于父组件，子组件是决定不了自身的结构与外观的\n\n后台管理系统项目前台项目：主要针对的是用户\n后台项目：主要面向的是卖家\n比如：前台项目的当中的数据来源于卖家（公司），但是需要注意的是卖家不能直接操作服务器和数据库，对于卖家而言，需要把产品信息上传到服务器，写入数据库。所以需要有一个后台管理项目，帮卖家进行可视化的操作数据库，去对产品进行增删改查。\n卖家（公司）组成：老板、经理、员工\n老板：这个项目对于老板而言，什么都可以操作，比如产品的上架、下架。查看和批改员工的绩效、其它等等。\n员工：只能查看个人绩效、工时等等\n需要注意的是，根据不同的角色（老板、员工），看到的、可以操作的内容都是不同的。\n同时对于后台管理项目，一般而言是不需要用户去注册的。\n模板简洁版：https://github.com/PanJiaChen/vue-admin-template\n加强版：https://github.com/PanJiaChen/vue-element-admin\n模板的文件与文件夹认识【简洁版】\n\nbuild文件夹\n\nindex.js 里面是 webpack 的配置\n\nmock文件夹\n\nmock 文件夹下的文件都是一些模拟的假数据\n\nnode_modules文件夹\n\n存储项目依赖的模块\n\npublic 文件夹\n\n存放了icon图标，以及静态页面，public 文件夹中放置的是一些静态资源，而且打包的时候 webpack 不会编译此文件夹下的内容，会原封不动的打包到dist\n\nsrc 文件夹\n\napi 文件夹：存放ajax请求的文件夹\nassets 文件夹：里面放置一些静态资源（一般是共享资源），assets 文件夹里面的静态资源，webpack 打包的时候，会进行编译\ncomponents文件夹：一般放置的是非路由组件或全局组件\nicons 文件夹：放置SVG矢量图\nlayout文件夹：放置了一些组件与mixin\nrouter 文件夹：路由相关文件\nstore 文件夹：Vuex 相关文件\nstyle 文件夹：公共样式相关文件\nutils 文件夹：request.js 是 axios 二次封装的文件\nviews 文件夹：里面放置的是路由组件\nApp.vue：根组件\nmain.js：入口文件\npermission.js：导航守卫相关文件\nsettings.js：项目配置项文件\n.env.development 和 .env.producation：监测是开发环境和生成环境的配置文件\n\n登录业务第一件事就是先完成静态组件，然后修改API，换成真实的后端接口\n后端swagger接口文档\nhttp:&#x2F;&#x2F;39.98.123.211:8170&#x2F;swagger-ui.html\nhttp:&#x2F;&#x2F;39.98.123.211:8510&#x2F;swagger-ui.html\n\n\n\n\n\n\n\n\n\n","slug":"back-stage","date":"2022-07-10T03:28:23.000Z","categories_index":"","tags_index":"Vue","author_index":"R桑"},{"id":"00e814c6dd8c392dd19a02f2418ceb24","title":"web前端面试题","content":"如何理解SPA应用SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。\n优点：\n\n用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；\n\n基于上面一点，SPA 相对对服务器压力小；\n\n前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；\n\n\n缺点：\n\n初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；\n前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；\nSEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。\n\n说一下前端登录的流程?初次登录的时候，前端调后调的登录接口，发送用户名和密码，后端收到请求，验证用户名和密码，验证成功，就给前端返回一个token，和一个用户信息的值，前端拿到token，将token储存到Vuex中，然后从Vuex中把token的值存入浏览器Cookies中。\n把用户信息存到Vuex然后再存储到LocalStroage中,然后跳转到下一个页面，根据后端接口的要求，只要不登录就不能访问的页面需要在前端每次跳转页面师判断Cookies中是否有token，没有就跳转到登录页，有就跳转到相应的页面，我们应该再每次发送 post&#x2F;get 请求的时候应该加入token，常用方法再项目utils/service.js中添加全局拦截器，将token的值放入请求头中 后端判断请求头中有无token，有token，就拿到token并验证token是否过期，在这里过期会返回无效的token然后有个跳回登录页面重新登录并且清除本地用户的信息\n说一下购物车的逻辑?//vue中购物车逻辑的实现\n1. 购物车信息用一个数组来存储，数组中保存对象，对象中有id和count属性\n\n2. 在vuex中state中添加一个数据 cartList 用来保存这个数组\n\n3. 由于商品详情页需要用到加入购物车功能，所以我们需要提供一个mutation, 用来将购物车信息加入 cartList中\n\n4. 加入购物车信息的时候，遵照如下规则： 如果购物车中已经有了该商品信息，则数量累加，如果没有该商品信息，则新增一个对象\n\n5. 在商品详情页，点击加入购物车按钮的时候，调用vuex提供的addToCart这个mutation将当前的商品信息 （id count）传给addTocart  this.$store.commit(\"addToCart\", &#123;id:  , count：&#125;)\n\n// js中购物车逻辑的实现\n1.商品页点击“加入购物车”按钮，触发事件\n\n2.事件调用购物车“增加商品”的Js程序（函数、对象方法）\n\n3.向Js程序传递传递“商品id”、“商品数量”等数据\n\n4.存储“商品id”、“商品数量”到浏览器的localStorage中\n\n**展示购物车中的商品******\n\n1.打开购物车页面\n\n2.从localStorage中取出“商品Id”、“商品数量”等信息。\n\n3.调用服务器端“获得商品详情”的接口得到购物车中的商品信息（参数为商品Id）\n\n4.将获得的商品信息显示在购物车页面。\n\n**完成购物车中商品的购买******\n\n1.用户对购物车中的商品完成购买流程，产生购物订单\n\n2.清除localStorage中存储的已经购买的商品信息\n\n备注1：购物车中商品存储的数据除了“商品id”、“商品数量”之外，根据产品要求还可以有其他的信息，例如完整的商品详情（这样就不用掉服务器接口获得详情了）、购物车商品的过期时间，超过时间的购物车商品在下次打开网站或者购物车页面时被清除。\n\n备注2：购物车商品除了存储在localStorage中，根据产品的需求不同，也可以存储在sessionStorage、cookie、session中，或者直接向服务器接口发起请求存储在服务器上。何种情况使用哪种方式存储、有啥区别请自己分析。\n\n说一下前端权限管理怎么实现Vue 实现\n目前主要的设计思路都是基于Vue-Router配合后端返回角色权限定义进行设计。后端返回角色对应路由权限数据，返回形如 &#123; role: ‘admin’, permissions: [‘Order’, …] &#125;，其中permissions对应前端路由页面name，通过这样的形式后端动态返回该角色所具备的权限列表，前端配合router.addRoutes动态注册路由，达到路由级的权限控制。\n在后台管理系统中对角色进行权限的分配（包括页面权限和接口权限），页面权限可以根据vue-router的api动态的生成路由表，而接口权限就需要后端的同学去进行校验。\n在Vue中权限控制的主体思路，前端会有一份路由表，它表示了每一个路由可访问的权限。当用户登录之后，通过 token 获取用户的 role ，动态根据用户的 role 算出其对应有权限的路由，再通过router.addRoutes动态挂载路由。但这些控制都只是页面级的。\n创建vue实例的时候将vue-router挂载，但这个时候vue-router挂载一些登录或者不用权限的公用的页面。当用户登录后，获取用role，将role和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。调用router.addRoutes(store.getters.addRouters)添加用户可访问的路由。使用vuex管理路由表，根据vuex中可访问的路由渲染侧边栏组件。\nReact 实现\nReact：利用高阶组件包装路由视图进行权限控制\n说一下常见的 git 操作git branch 查看本地所有分支\ngit status 查看当前状态\ngit commit 提交\ngit branch -a 查看所有的分支\ngit branch -r 查看远程所有分支\ngit commit -am \"init\" 提交并且加注释\ngit remote add origin git@192.168.1.119:ndshow\ngit push origin master 将文件给推到服务器上\ngit remote show origin 显示远程库origin里的资源\ngit push origin master:develop\ngit push origin master:hb-dev 将本地库与服务器上的库进行关联\ngit checkout --track origin/dev 切换到远程dev分支\ngit branch -D master develop 删除本地库develop\ngit checkout -b dev 建立一个新的本地分支dev\ngit merge origin/dev 将分支dev与当前分支进行合并\ngit checkout dev 切换到本地dev分支\ngit remote show 查看远程库\ngit add .\ngit rm 文件名(包括路径) 从git中删除指定文件\ngit clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来\ngit config --list 看所有用户\ngit ls-files 看已经被提交的\ngit rm [file name] 删除一个文件\ngit commit -a 提交当前repos的所有的改变\ngit add [file name] 添加一个文件到git index\ngit commit -v 当你用－v参数的时候可以看commit的差异\ngit commit -m \"This is the message describing the commit\" 添加commit信息\ngit commit -a -a是代表add，把所有的change加到git index里然后再commit\ngit commit -a -v 一般提交命令\ngit log 看你commit的日志\ngit diff 查看尚未暂存的更新\ngit rm a.a 移除文件(从暂存区和工作区中删除)\ngit rm --cached a.a 移除文件(只从暂存区中删除)\ngit commit -m \"remove\" 移除文件(从Git中删除)\ngit rm -f a.a 强行移除修改后文件(从暂存区和工作区中删除)\ngit diff --cached 或 $ git diff --staged 查看尚未提交的更新\ngit stash push 将文件给push到一个临时空间中\ngit stash pop 将文件从临时空间pop下来\n\n//  我是cv的自取吧\n\ngit 解决合并冲突现在通过git merge featurel进行分支合并，如下所示：\n\n从冲突信息可以看到，a.txt发生冲突，必须手动解决冲突之后再提交\n而git status同样可以告知我们冲突的文件：\n\n打开a.txt文件，可以看到如下内容：\n\ngit用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容：\n\n&#96;&#96;&#96;textInvalid code snippet option\n- &#96;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#96; 和 &#96;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#96; 之间的区域就是传入进来更改的内容\n\n现在要做的事情就是将冲突的内容进行更改，对每个文件使用 &#96;git add&#96; 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，&#96;Git&#96;就会将它们标记为冲突已解决然后再提交：\n\n- &#96;git add a.txt&#96;\n- &#96;git commit -m &quot;conflict fixed&quot;&#96;\n\n此时&#96;master&#96;分支和&#96;feature1&#96;分支变成了下图所示：\n\n![img](..&#x2F;images&#x2F;%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98&#x2F;d7421e60-fdb3-11eb-bc6f-3f06e1491664.png)\n\n使用&#96;git log&#96;命令可以看到合并的信息：\n\n![img](..&#x2F;images&#x2F;%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98&#x2F;e0dfd1b0-fdb3-11eb-991d-334fd31f0201.png)\n\n当&#96;Git&#96;无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成\n\n解决冲突就是把&#96;Git&#96;合并失败的文件手动编辑为我们希望的内容，再提交\n\n### SPA 应用首屏加载速度慢\n\n**加载慢的原因**\n\n在页面渲染的过程，导致加载速度慢的因素可能如下：\n\n- 网络延时问题\n- 资源文件体积是否过大\n- 资源是否重复发送请求去加载了\n- 加载脚本的时候，渲染内容堵塞了\n\n**解决方案**\n\n常见的几种&#96;SPA&#96;首屏优化方式\n\n1.减小入口文件体积\n\n常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加\n\n&#96;&#96;&#96;js\n&#x2F;&#x2F; vue-router 配置路由的时候，采用动态加载路由的形式\nroutes:[\n    path: &#39;Blogs&#39;,\n    name: &#39;ShowBlogs&#39;,\n    component: () &#x3D;&gt; import(&#39;.&#x2F;components&#x2F;ShowBlogs.vue&#39;) &#x2F;&#x2F; 以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件\n]\n\n2.静态资源本地缓存\n后端返回资源问题：\n\n采用HTTP缓存，设置Cache-Control，Last-Modified，Etag等响应头\n采用Service Worker离线缓存\n\n前端合理利用 localStorage\n3.UI框架按需加载\n在日常使用UI框架，例如element-UI、或者antd，我们经常性直接饮用整个UI库\nimport ElementUI from 'element-ui'\nVue.use(ElementUI)\n\n但实际上我用到的组件只有按钮，分页，表格，输入与警告 所以我们要按需引用\nimport &#123;\n\tButton,\n\tInput,\n\tPagination,\n\tTable,\n\tTableColumn,\n\tMessageBox,\n&#125; from 'element-ui'\nVue.use(Button)\nVue.use(Input)\nVue.use(Pagination)\n\n4.图片资源的压缩\n图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素，对于所有的图片资源，我们可以进行适当的压缩\n对页面上使用到的icon，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻http请求压力。\n5.组件重复打包\n假设A.js文件是一个常用的库，现在有多个路由使用了A.js文件，这就造成了重复下载\n解决方案：在webpack的config文件中，修改CommonsChunkPlugin的配置\nminChunks: 3\n\nminChunks为 3 表示会把使用 3 次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件\n6.开启GZip压缩\n拆完包之后，我们再用gzip做一下压缩 安装compression-webpack-plugin\nnmp i compression-webpack-plugin -D\n\n在vue.congig.js中引入并修改webpack配置\nconst CompressionPlugin = require('compression-webpack-plugin')\n\nconfigureWebpack: (config) => &#123;\n    if (process.env.NODE_ENV === 'production') &#123;\n        // 为生产环境修改配置...\n        config.mode = 'production'\n        return &#123;\n        plugins: [new CompressionPlugin(&#123;\n        test: /\\.js$|\\.html$|\\.css/, //匹配文件名\n        threshold: 10240, //对超过10k的数据进行压缩\n        deleteOriginalAssets: false //是否删除原文件\n    &#125;)]\n    &#125;\n&#125;\n\n7.使用SSR\nSSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器\n从头搭建一个服务端渲染是很复杂的，vue应用建议使用Nuxt.js实现服务端渲染\n重排(reflow)和重绘(repaint)\n重绘：某些元素的外观被改变，例如：元素的填充颜色\n重排：重新生成布局，重新排列元素。\n\n\n\n\n\n\n\n\n\n\n重绘不一定导致重排，但重排一定会导致重绘。\nHTML5 有哪些新特性\n新增了语义化标签：header/ footer/main/aside/nav/article/section\n新增了视频 video 和 音频 audio 标签\n新增了 canvas 和 SVG\n新增了 localStorage 和 sessionStorage\nlocalStorage - 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。\nsessionStorage - 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。\n\n\n新增了 Web Socket\n\n理解 cookie、session、localStorage、sessionStorage 关系与区别cookie与session的区别\nCookie数据存放在客户端，Session数据放在服务器端\nCookie的安全性一般，他人可通过分析存放在本地的Cookie并进行Cookie欺骗。在安全性第一的前提下，选择Session更优。重要交互信息比如权限等就要放在Session中，一般的信息记录放Cookie中\n单个Cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie，而Session原则上没有限制\nSession会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用Cookie。\nSession 的运行依赖Session ID，而 Session ID 是存在 Cookie 中的，也就是说，如果浏览器禁用了 Cookie，Session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 Session ID，也就是地址重写）\n\nlocalStorage 的特点\nlocalStorage 与 HTTP 没有任何关系，所以在 HTTP 请求时不会带上 localStorage 的值\n只有相同域名的页面才能互相读取 localStorage，同源策略与 cookie 一致\n不同的浏览器，对每个域名 localStorage 的最大存储量的规定不一样，超出存储量会被拒绝。最大存5M 超过5M的数据就会丢失。而 Chrome 10MB 左右\n常用来记录一些不敏感的信息\nlocalStorage 理论上永久有效，除非用户清理缓存\n\nsessionStorage的特点sessionStorage 的所有性质基本上与 localStorage 一致，唯一的不同区别在于：\nsessionStorage 的有效期是页面会话持续，如果页面会话（session）结束（关闭窗口或标签页），sessionStorage 就会消失。而 localStorage 则会一直存在。\nlocalStorage与sessionStorage的区别\nlocalStorage生命周期是永久的，除非被清除，否则永久保存，而sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除\n\npx、em、rem、vw 百分比的区别\npx: 是固定单位，其他几种都是相对单位。\nem: 默认字体大小的倍数。比如给元素设置font-size：2em\nrem: 根元素（html节点）字体大小的倍数。\n1vw: 代表浏览器视口宽度的1% ，vw和vh比rem精度更高\n1%: 对不同的属性有不同的含义。\n\nforEach能return吗forEach 没有返回值只是作为一个对象去遍历的。\n为什么 JavaScript 中 0.1 + 0.2 ≠ 0.3JavaScript 使用 Number 类型表示数字（整数和浮点数），遵循 IEEE 754 标准 通过 64 位来表示一个数字\n0.1 在二进制中表示为 0.1 &#x3D; 2^-4 * 1.10011(0011)，即 0.000110011001100110011……\n0.1 和 0.2 转换成二进制后会无限循环\n0.1 -&gt; 0.0001100110011001...(无限循环)\n0.2 -&gt; 0.0011001100110011...(无限循环)\n\n即 0.1 在二进制中是无限循环的，很多十进制小数用二进制表示都是无限循环的，但 JS 采用的浮点数标准 IEEE 754 尾数位数限制，会舍入掉超出 64 位的数字，这样在进制之间的转换中精度已经损失。\nJavaScript 原型，原型链 ? 有什么特点？JavaScript 常被描述为一种基于原型的语言——每个对象拥有一个原型对象\n当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾\n准确地说，这些属性和方法定义在 Object 的构造器函数（constructor functions）之上的prototype属性上，而非实例对象本身\n原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法\n在对象实例和它的构造器之间建立一个链接（它是__proto__属性，是从构造函数的prototype属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法\n\n每个对象的__proto__都是指向它的构造函数的原型对象prototype的\nperson1.__proto__ === Person.prototype\n\n构造函数是一个函数对象，是通过 Function构造器产生的\nPerson.__proto__ === Function.prototype\n\n原型对象本身是一个普通对象，而普通对象的构造函数都是Object\nPerson.prototype.__proto__ === Object.prototype\n\n刚刚上面说了，所有的构造器都是函数对象，函数对象都是 Function构造产生的\nObject.__proto__ === Function.prototype\n\nObject 的原型对象也有__proto__属性指向null，null是原型链的顶端\nObject.prototype.__proto__ === null\n\n下面作出总结：\n\n一切对象都是继承自Object对象，Object 对象直接继承根源对象null\n一切的函数对象（包括 Object 对象），都是继承自 Function 对象\nObject 对象直接继承自 Function 对象\nFunction对象的__proto__会指向自己的原型对象，最终还是继承自Object对象\n\nES6 的新特性\n新增了let和const\n变量的解构赋值 const student = [&#39;小花&#39;,&#39;小王&#39;,&#39;小李&#39;,&#39;小吴&#39;,]; let [xiaohua,xiaowang,xiaoli,xiangwu] = student;\n模板字符串\n箭头函数 () &#x3D;&gt; {}\n扩展运算符，也就是三个点 ...\nSymbol：ES6 引入的一种新的原始数据类型 Symbol，表示独一无二的值。\nPromise：Promise是 ES6引入的异步编程的新解决方案 。语法上 Promise是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。\nclass 类\n模块化\n\nNew 操作符做了什么事情?1、首先创建了一个新对象\n2、设置原型，将对象的原型设置为函数的prototype对象\n3、让函数的this指向这个对象，执行构造函数的代码（为这个新对象添加属性）\n4、判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象\n\n箭头函数的this指向箭头函数没有自己的this，一般是外部的作用域的this，如果已经是在全局环境下了那么this指向就是window\nasync 和 awaitasync 函数是 Generator 函数的语法糖。使用 关键字 async 来表示，在函数内部使用await 表明当前函数是异步函数 不会阻塞线程导致后续代码停止运行。\nawait意思是async wait(异步等待)。这个关键字只能在使用async定义的函数里面使用。任何async函数都会默认返回promise，并且这个promise解析的值都将会是这个函数的返回值，而async函数必须等到内部所有的 await 命令的 Promise 对象执行完，才会发生状态改变\nVue 的 data 为什么是一个方法而不写成对象vue为了保证每个实例上的data数据的独立性，规定了必须使用函数，而不是对象。\n因为使用对象的话，每个实例（组件）上使用的data数据是相互影响的，这当然就不是我们想要的了。对象是对于内存地址的引用，直接定义个对象的话组件之间都会使用这个对象，这样会造成组件之间数据相互影响。\nVue.set 方法当生成vue实例后，当再次对 data 中的数组或对象进行修改时，有些操作方式是非响应式的，Vue检测不到数据更新，因此也不会触发视图更新。此时需要使用Vue.set()进行响应式的数据更新。\nv-model 数据双向绑定\n说明一般使用 v-model / .sync 实现，v-model 是 v-bind:value和 v-on:input的语法糖\n\nv-bind:value 实现了 data ⇒ UI 的单向绑定\nv-on:input 实现了 UI ⇒ data 的单向绑定\n加起来就是双向绑定了\n\n\n这两个单向绑定是如何实现的呢？\n\n前者通过 Object.defineProperty API 给 data 创建 getter 和 setter，用于监听 data 的改变，data 一变就会安排改变 UI\n\n后者通过 template compiler 给 DOM 添加事件监听，DOM input 的值变了就会去修改 data。\n\n\n\n\n组件间数据传递的方式\n父子组件：使用「props 和事件」进行通信\n\n爷孙组件：\n\n使用两次父子组件间通信来实现\n\n使用「provide + inject」来通信\n\n\n\n任意组件：使用 eventBus = new Vue() 来通信\n\n\n\n主要 API 是 eventBus.$on 和 eventBus.$emit\n缺点是事件多了就很乱，难以维护\n\n\n任意组件：使用 Vuex 通信（Vue 3 可用 Pinia 代替 Vuex）\n\nMVVM 模型\n\n\n\n\n\n\n\n\nMVVM表示的是 &#96;&#96;Model-View-ViewModel&#96;\n\nModel：模型层，负责处理业务逻辑以及和服务器端进行交互\nView：视图层：负责将数据模型转化为UI展示出来，可以简单的理解为HTML页面\nViewModel：视图模型层，用来连接Model和View，是Model和View之间的通信桥梁\n\n\ncomputed 和 watch\ncomputed 支持缓存，只有依赖数据发生改变，才会重新进行计算\ncomputed 不支持异步，当computed内有异步操作时无效，无法监听数据的变化\ncomputed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。\nwatch它是一个对data的数据监听回调, 当依赖的data的数据变化时, 会执行回调\nwatch支持异步, 同时有两个属性immediate：组件加载立即触发回调函数执行， deep: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。\n\nwatch 和 computed 的区别是：\n相同点：他们两者都是观察页面数据变化的。\n不同点：computed只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。 watch每次都需要执行函数。watch更适用于数据变化时的异步操作。\n当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。这是和computed最大的区别，请勿滥用。\nwebpack 构建流程\n开始运行 Webpack。\n读取与合并参数，加载 plugin。\n实例化 Compiler。\n调用 compiler.run 创建 Compilation，代表一次资源的构建。\nCompilation 对象也提供了很多关键步骤的钩子函数，并生成一次 Chunk。\nCompilation.buildModule 主要执行 loader，编译掉不认识的代码。\n\n\n\n\n使用 Parser 分析项目依赖。\n从 Chunk 开始解析依赖，使用 Module 和 Dependency 管理代码模块相互关系。\n\n\n使用 Template 生成结果代码。\n基于 Chunk 的数据拼接字符串，生成最终代码。\n\n\n\ntoken 的过期时间登录完后后端返回一个token，将token存储到 localStorage，用户触发页面行为的时候回去调用接口，我们把这个token放在请求头上带给后端，后端去数据库里面查，看看用户的 token 有没有过期，过期了会返回一个状态码 401，然后跳转到 login 让用户重新登录请求token\n说一下常见的 HTTP 状态码?说一下状态码是 302 和 304 是什么意思？你在项目中出现过么？你是怎么解决的？   &lt;!-- 状态码：由3位数字组成，第一个数字定义了响应的类别 -->\n   &lt;!-- 1xx：指示消息,表示请求已接收，继续处理 -->\n   &lt;!-- 2xx：成功,表示请求已被成功接收，处理 -->\n   &lt;!-- 200 OK：客户端请求成功\n        204 No Content：无内容。服务器成功处理，但未返回内容。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。不会刷新页面。\n        206 Partial Content：服务器已经完成了部分GET请求（客户端进行了范围请求）。响应报文中包含Content-Range指定范围的实体内容\n-->\n   &lt;!-- 3xx 重定向 -->\n   &lt;!-- 301 Moved Permanently：永久重定向，表示请求的资源已经永久的搬到了其他位置。\n        302 Found：临时重定向，表示请求的资源临时搬到了其他位置\n        303 See Other：临时重定向，应使用GET定向获取请求资源。303功能与302一样，区别只是303明确客户端应该使用GET访问\n        307 Temporary Redirect：临时重定向，和302有着相同含义。POST不会变成GET\n        304 Not Modified：表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足。返回304时，不包含任何响应主体。虽然304被划分在3XX，但和重定向一毛钱关系都没有\n-->\n   &lt;!-- 4xx：客户端错误 -->\n   &lt;!-- 400 Bad Request：客户端请求有语法错误，服务器无法理解。\n        401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。\n        403 Forbidden：服务器收到请求，但是拒绝提供服务\n        404 Not Found：请求资源不存在。比如，输入了错误的url\n        415 Unsupported media type：不支持的媒体类型\n-->\n   &lt;!-- 5xx：服务器端错误，服务器未能实现合法的请求。 -->\n   &lt;!-- 500 Internal Server Error：服务器发生不可预期的错误。\n        503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，\n-->\n\n我们在浏览器中输入 URL 并回车后都发生了什么？\n合成 URL\n\nDNS 域名解析\n\n三次握手，建立TCP连接\n\n发送HTTP请求，服务器处理请求，返回响应结果\n\n关闭TCP连接，四次挥手\n\n浏览器渲染\n\n渲染进程将HTML内容转换为能够读懂的DOM树结构\n渲染引擎将CSS样式表转化为浏览器可以理解的styleSheets，计算出DOM节点的样式\n创建布局树，并计算元素的布局信息\n对布局树进行分层，并生成分层树\n为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转成位图\n合成线程发送绘制图块命令给浏览器进程，浏览器进程根据指令生成页面，并显示到显示器上。\n\n\n\n微任务和宏任务正式开始\n先上代码\n\nfunction app() &#123;\n\tsetTimeout(() => &#123;\n\t\tconsole.log('1-1')\n\t\tPromise.resolve().then(() => &#123;\n\t\t\tconsole.log('2-1')\n\t\t&#125;)\n\t&#125;)\n\tconsole.log('1-2')\n\tPromise.resolve().then(() => &#123;\n\t\tconsole.log('1-3')\n\t\tsetTimeout(() => &#123;\n\t\t\tconsole.log('3-1')\n\t\t&#125;)\n\t&#125;)\n&#125;\napp()\n\n\n输出结果：\n\n1-2\n1-3\n1-1\n2-1\n3-1\n\n开始分析\n面试官特别喜欢问：你讲讲什么是微任务和宏任务\n\n\n\n\n\n\n\n\n\n\n大部分面试官其实自己也不懂什么是微任务和宏任务,不信下次你们反问一下\n所谓微任务和宏任务\n宏任务:常见的定时器,用户交互事件等等.（宏任务就是特定的这些个任务,没什么特殊含义）\n微任务:Promise相关任务,MutationObserver等（一样，只是一种称呼而已！！！）\n\n到底先执行微任务还是宏任务\n先有鸡还是先有蛋? 到底是先有宏任务还是微任务啊?\n\n第一个原则\n万物皆从全局上下文准备退出，全局的同步代码运行结束的这个时机开始\n例如我们刚才这段代码：\n\nfunction app() &#123;\n\tsetTimeout(() => &#123;\n\t\tconsole.log('1-1')\n\t\tPromise.resolve().then(() => &#123;\n\t\t\tconsole.log('2-1')\n\t\t&#125;)\n\t&#125;)\n\tconsole.log('1-2')\n\tPromise.resolve().then(() => &#123;\n\t\tconsole.log('1-3')\n\t\tsetTimeout(() => &#123;\n\t\t\tconsole.log('3-1')\n\t\t&#125;)\n\t&#125;)\n&#125;\napp()\n\n\n当执行完了console.log(&quot;1-2&quot;);的时候，意味着全局的上下文马上要退出了,因为此时全局的同步代码都执行完了,剩下的都是异步代码\n\n第二个原则\n同一层级下(不理解层级，可以先不管，后面会讲),微任务永远比宏任务先执行\n即Promise.then比setTimeout先执行\n所以先打印1-3,再打印1-1\n\n第三个原则\n每个宏任务,都单独关联了一个微任务队列\n我用刚买的黑板画了一张图,大家就知道什么是层级了\n\n\n\n每个层级的宏任务,都对应了他们的微任务队列,微任务队列遵循先进先出的原则,当全局同步代码执行完毕后,就开始执行第一层的任务。同层级的微任务永远先于宏任务执行,并且会在当前层级宏任务结束前全部执行完毕\n\n怎么分辨层级？\n属于同一个维度的代码,例如下面的func1和func2就属于同层级任务\n\nsetTimeout(func1)...\nPromise.resolve().then(func2)...\n\n\n下面这种fn1和fn2就不属于同一个层级的,因为 fn2 属于内部这个setTimeout的微任务队列,而fn1属于外部setTimeout的微任务队列\n\nsetTimeout(() => &#123;\n\tPromise.resolve().then(fn1)\n\tsetTimeout(() => &#123;\n\t\tPromise.resolve().then(fn2)\n\t&#125;)\n&#125;)\n\n\n\n\n\n\n\n\n\n\n划重点:每个宏任务对应一个单独的微任务队列\n遇到面试题\n就按照我的套路,从全局上下文退出前（全局的同步代码执行完毕后）,开始收集当前层级的微任务和宏任务,然后先清空微任务队列,再执行宏任务.如果这期间遇到宏任务&#x2F;微任务,就像我这样画个图,把他们塞进对应的层级里即可\n\nVue中的$nextTick使用场景轮播图场景：仓库中的bannerList最开始是一个空数组，然后服务器发请求数据回来，获取到图片数据，这里是有数据变化的。\n通过 watch 监听 bannerList 属性值的变化，当我们监听的这个回调执行力，代表组件实例身上这个属性的数据已经有了。\nwatch: &#123;\n  //  监听bannerList数据的变化\n  bannerList:&#123;\n    handler(newValue,oldValue)&#123;\n      new Swiper(document.querySelector('.swiper-container'), &#123;\n        loop: true,\n        //  如果需要分页器\n        pagination: &#123;\n          el: '.swiper-pagination',\n          clickable:true\n        &#125;,\n        //  如果需要前进后退\n        navigation: &#123;\n          nextEl: '.swiper-button-next',\n          prevEl: '.swiper-button-prev'\n        &#125;\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n\n那watch这种写法可以吗？还是不行~\n在这里new Swiper 还是没有结构，这里只能保证数据已经有了，但是 v-for 有没有执行完毕把结构渲染出来还是不确定的。\n$nextTick：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即执行这个方法，获取更新后的DOM。\nbannerList 初始状态是一个空数组，数据拿到它发生数组中有了数据，DOM 已经更新完毕了，这里指的就是下次DOM更新，v-for 循环结束了结构已经有了，就是循环结束之后然后再延迟执行回调。\n在修改数据之后，bannerList就是一个空数组，服务器数据已经拿到了，v-for 循环结束之后，在执行 nextTick回调。\n$nextTick：可以保证页面中结构一定是有的，经常和很多插件一起使用，这些插件都需要DOM已经存在了。\nv-for 为什么不能和 v-if 一起使用在官方文档中明确指出 v-for 和 v-if 不建议一起使用。\n原因：v-for比v-if优先级高，所以一起使用的话，每次v-for都会执行v-if,造成不必要的计算，影响性能，尤其是当之需要渲染很小一部分的时候。\n&lt;ul>\n\t&lt;li v-for=\"user in users\" v-if=\"user.isActive\" :key=\"user.id\">\n\t\t&#123;&#123; user.name &#125;&#125;\n\t&lt;/li>\n&lt;/ul>\n\n如上述情况，即使有100个user中只有一个需要使用v-if，也需要整个循环数组，这在性能上是极大的浪费。\n那难道就没有更好的解决办法，回答：当然是有解决方法的；我们可以使用computed\n示例：\n&lt;div&gt;\n\t&lt;div v-for&#x3D;&quot;(user,index) in activeUsers&quot; :key&#x3D;&quot;user.index&quot; &gt;\n\t\t&#123;&#123; user.name &#125;&#125;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\ndata () &#123;  &#x2F;&#x2F; 业务逻辑里面定义的数据\n    return &#123;\n      users,: [&#123;\n        name: &#39;111111&#39;,\n        isShow: true\n      &#125;, &#123;\n        name: &#39;22222&#39;,\n        isShow: false\n      &#125;]\n    &#125;\n  &#125;\ncomputed: &#123;\n\tactiveUsers: function () &#123;\n\t\treturn this.users.filter(function (user) &#123;\n\t\t\treturn user.isShow;&#x2F;&#x2F;返回isShow&#x3D;true的项，添加到activeUsers数组\n\t\t&#125;)\n\t&#125;\n&#125;\n\n总结：v-if比v-for优先级高，一起使用在性能上会造成极大的浪费，并且官网也并不推荐我们这样做，所以我们可以选择使用computed过滤掉列表中不需要显示的项目。\nVueRouter 路由器的两种工作模式\n对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。\nhash 值不会包含在 HTTP 请求中，即：hash 值不会带给服务器。\nhash模式：\n地址中永远带着#号，不美观 。\n若以后将地址通过第三方手机app分享，若 app 校验严格，则地址会被标记为不合法。\n兼容性较好。\n\n\nhistory模式：\n地址干净，美观 。\n兼容性和 hash 模式相比略差。\n应用部署上线时需要后端人员支持，解决刷新页面服务端 404 的问题。\n\n\n\n虚拟DOM中key的作用：\n简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。\n详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】, 随后 React 进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下：\na.旧虚拟DOM中找到了与新虚拟DOM相同的key：\n(1).若虚拟DOM中内容没变, 直接使用之前的真实DOM\n(2).若虚拟DOM中内容变了, 则生成新的真实 DOM，随后替换掉页面中之前的真实DOM\nb. 旧虚拟DOM中未找到与新虚拟DOM相同的key\n根据数据创建新的真实DOM，随后渲染到到页面\n\n\n\n用 index 作为 key 可能会引发的问题：\n\n若对数据进行：逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实DOM更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。\n如果结构中还包含输入类的DOM：会产生错误DOM更新 &#x3D;&#x3D;&gt; 界面有问题。\n注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。\n\n","slug":"前端面试题","date":"2022-07-07T13:39:33.000Z","categories_index":"","tags_index":"面试题","author_index":"R桑"},{"id":"6cf6ea53457bfcb2a915aa71f05e8d96","title":"promise.all与promise.race的应用","content":"将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化\nconst preloadImage = function (path) &#123;\n  return new Promise(function (resolve, reject) &#123;\n    const image = new Image();\n    image.onload  = resolve;\n    image.onerror = reject;\n    image.src = path;\n  &#125;);\n&#125;;\n\n将多个渲染数据分别给个then，让其各司其职。或当下个异步请求依赖上个请求结果的时候，我们也能够通过链式操作友好解决问题\n// 各司其职\ngetInfo().then(res=>&#123;\n    let &#123; bannerList &#125; = res\n    //渲染轮播图\n    console.log(bannerList)\n    return res\n&#125;).then(res=>&#123;\n    \n    let &#123; storeList &#125; = res\n    //渲染店铺列表\n    console.log(storeList)\n    return res\n&#125;).then(res=>&#123;\n    let &#123; categoryList &#125; = res\n    console.log(categoryList)\n    //渲染分类列表\n    return res\n&#125;)\n\n\n\n通过all()实现多个请求合并在一起，汇总所有请求结果，只需设置一个loading即可\nfunction initLoad()&#123;\n    // loading.show() //加载loading\n    Promise.all([getBannerList(),getStoreList(),getCategoryList()]).then(res=>&#123;\n        console.log(res)\n        loading.hide() //关闭loading\n    &#125;).catch(err=>&#123;\n        console.log(err)\n        loading.hide()//关闭loading\n    &#125;)\n&#125;\n//数据初始化    \ninitLoad()\n\n\n\n通过race可以设置图片请求超时\n//请求某个图片资源\nfunction requestImg()&#123;\n    var p = new Promise(function(resolve, reject)&#123;\n        var img = new Image();\n        img.onload = function()&#123;\n           resolve(img);\n        &#125;\n        //img.src = \"https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg\"; 正确的\n        img.src = \"https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg1\";\n    &#125;);\n    return p;\n&#125;\n\n//延时函数，用于给请求计时\nfunction timeout()&#123;\n    var p = new Promise(function(resolve, reject)&#123;\n        setTimeout(function()&#123;\n            reject('图片请求超时');\n        &#125;, 5000);\n    &#125;);\n    return p;\n&#125;\n\nPromise\n.race([requestImg(), timeout()])\n.then(function(results)&#123;\n    console.log(results);\n&#125;)\n.catch(function(reason)&#123;\n    console.log(reason);\n&#125;);\n","slug":"promise-all与promise-race的应用","date":"2022-06-14T05:28:44.000Z","categories_index":"","tags_index":"Promise","author_index":"R桑"},{"id":"474fd39d06800a3e7f5683194706b168","title":"VueShop","content":"脚手架使用npm i -g @vue/cli\nyarn add global @vue/cli\n\nvue init webpack 项目的名字console.log(‘%c [ 项目的名字 ]-16’, ‘font-size:13px; background:pink; color:#bf2c9f;’, 项目的名字)\nvue create 项目名称\n脚手架目录:public + assets文件夹区别\nnode_modules：放置项目依赖的地方\npublic一般放置一些共用的静态资源，打包上线的时候，public 文件夹里面资源原封不动打包到dist文件夹里面\nsrc：程序员源代码文件夹\n\nassets文件夹：经常放置一些静态资源（图片），assets文件夹里面资源webpack会进行打包为一个模块（js文件夹里面）\ncomponents文件夹：一般放置非路由组件（或者项目共用的组件）\nApp.vue 唯一的根组件\nmain.js 入口文件【程序最先执行的文件】\nbabel.config.js：babel配置文件\npackage.json：项目描述、项目依赖、项目运行指令\nREADME.md：项目说明文件\n\n脚手架下载下来的项目稍微配置一下设置项目启动自动打开浏览器在package.json文件中\"scripts\": &#123;\n \"serve\": \"vue-cli-service serve --open\",\n \"build\": \"vue-cli-service build\",\n \"lint\": \"vue-cli-service lint\"\n&#125;,\n\n关闭eslint校验工具（非必须）创建vue.config.js文件：需要对外暴露\nmodule.exports = &#123;\n\tlintOnSave: false,\n&#125;\n\nsrc文件夹的别名的设置因为项目比较大的时候src（源代码文件夹）：里面目录会很多，找文件不方便，设置src文件夹的别名的好处，找文件会方便一些\n创建jsconfig.json文件，@代表的是src文件夹：\n&#123;\n\t\"compilerOptions\": &#123;\n\t\t\"baseUrl\": \"./\",\n\t\t\"paths\": &#123;\n\t\t\t\"@/*\": [\"src/*\"]\n\t\t&#125;\n\t&#125;,\n\t\"exclude\": [\n\t\t// @ 不能使用的地方\n\t\t\"node_modules\",\n\t\t\"dist\"\n\t]\n&#125;\n\n项目路由的分析前端的路由：KV 键值对。\n\nkey：URL（地址栏中的路径）\nvalue：相应的路由组件\n\n比如：项目是上中下结构\n路由组件拆分：\nHome 首页路由组件，Search 路由组件、Login 路由组件、Register 路由组件\n非路由组件：Header 首页和搜索页、Footer在首页和搜索页存在，但是在登录页和注册页是没有的。\n完成非路由组件 Header 和 Footer在开发项目的时候\n\n书写静态页面\n拆分组件\n获取服务器的数据动态展示\n完成相应的动态业务逻辑\n\n注意 1：创建组件的时候，组件结构 + 组件的样式 + 图片的资源\n注意 2：项目采用了了less 样式，浏览器不识别less样式，需要通过less、less-loader进行处理less，把less样式变为CSS样式，浏览器才能识别\n使用 less-loader 前先安装 less\n否则会报错 Error: Cannot find module &#39;less&#39;脚手架@vue/cli 4.5.13，vue 版本 2.6.11 直接 yarn add less-loader@7.3.0 运行报错，换成 yarn add less@4.0.0 ，然后在 yarn add less-loader@7webpack5 请按照文档使用最新的安装方式。\n注意 3：如果想要组件识别less样式，需要在 style 标签上加上 lang=&quot;less&quot;\n路由组件的搭建\n使用Vue-router@^3.5.3\nyang add vue-router@^3.5.3 --save\n\n路由组件应该有四个：Home、Search、Login、Register\ncomponents文件夹：经常放置的是非路由组件（共用全局组件）\npages/views文件夹：经常放置路由组件\n配置路由\n项目中配置的路由一般放置在 router 文件夹中\n// 配置路由的地方\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\n\n// 使用 vue-router 插件\nVue.use(VueRouter)\n\n// 引入路由组件\nimport Home from '@/pages/Home'\nimport Search from '@/pages/Search'\nimport Login from '@/pages/Login'\nimport Register from '@/pages/Register'\n// 配置路由\nexport default new VueRouter(&#123;\n\troutes: [\n\t\t&#123;\n\t\t\tpath: '/home',\n\t\t\tcomponent: Home,\n\t\t&#125;,\n\t\t&#123;\n\t\t\tpath: '/search',\n\t\t\tcomponent: Search,\n\t\t&#125;,\n\t\t&#123;\n\t\t\tpath: '/login',\n\t\t\tcomponent: Login,\n\t\t&#125;,\n\t\t&#123;\n\t\t\tpath: '/register',\n\t\t\tcomponent: Register,\n\t\t&#125;,\n\t\t// 重定向，在项目跑起来的时候,访问根目录立马让它定向到首页\n\t\t&#123;\n\t\t\tpath: '*',\n\t\t\tredirect: '/home',\n\t\t&#125;,\n\t],\n&#125;)\n\n总结路由组件与非路由组件的区别\n\n路由组件一般放置在pages|views 文件夹，非路由组件一般放置在 components 文件夹中\n路由组件一般需要在 router 文件夹中进行注册（使用的即为路由的名字），非路由组件在使用的时候，一般都是以标签的形式使用\n注册完路由，不管是路由组件还是非路由组件身上都有 $route、$router属性\n\n$route：一般获取路由信息（路径、query、params）\n$router：一般进行编程式导航进行跳转（push|replace&#96;）\n路由的跳转\n路由的跳转有两种形式：\n\n声明式导航 router-link，可以进行路由的跳转\n编程式导航 push|replace，也可以进行路由的跳转\n\n编程式导航：声明式导航能做的，编程式导航都能做，但是编程式导航除了可以进行路由跳转，还可以做一些其它的业务逻辑。\nFooter 组件显示与隐藏显示或者隐藏组件：v-if | v-show\n\nFooter 组件在 Home、Search 显示\n在登录、注册页面 Footer 组件时隐藏的\n\n我们可以根据组件身上的 $route 获取当前路由的信息，通过路由判断 Footer 显示与隐藏\n方式一直接使用 $route.path 匹配路径：\n&lt;!-- 在Home、Search显示、登录或者注册隐藏 -->\n&lt;footer v-show=\"$route.path=='/home'||$route.path=='/search'\" />\n\n方式二配置路由的时候，可以给路由添加路由元信息 meta：\n// 配置路由\nexport default new VueRouter(&#123;\n\troutes: [\n\t\t&#123;\n\t\t\tpath: '/home',\n\t\t\tcomponent: Home,\n\t\t\tmeta: &#123; show: true &#125;,\n\t\t&#125;,\n\t],\n&#125;)\n\n路由传参路由的跳转有几种方式，比如从 A -&gt; B：\n\n声明式导航：router-link（务必填写to属性），可以实现路由的跳转\n编程式导航：利用的是组件的$router.push | replace方法，在路由的跳转过程中可以书写一些业务\n\n路由传参，参数有几种写法\n\nparams参数：属于路径当中的一部分，需要注意，在配置路由的时候，需要占位\nquery参数：不属于路径当中的一部分，类似于AJAX中的queryString /home?k=v&amp;kv=，不需要占位\n\n&#123;\n    path: \"/search/:keyword\",\n    component: Search,\n    meta: &#123; show: true &#125;\n&#125;\n\nmethods: &#123;\n    // 搜索按钮的回调函数：需要向 search 路由进行跳转\n    goSearch () &#123;\n        // 路由传递参数\n        // 第一种：字符串形式 params 和 query\n        this.$router.push(\"/search/\" + this.keyword + \"?k=\" + this.keyword.toUpperCase())\n        //  第二种：模板字符串\n       this.$router.push(`/search/$&#123;this.keyword&#125;?k=$&#123;this.keyword.toUpperCase()&#125;`)\n        //第三种：对象\n        this.$router.push(&#123;\n            name: \"search\",\n            params: &#123;keyword: this.keyword&#125;,\n            query: &#123;k: this.keyword.toUpperCase()&#125;\n        &#125;)\n    &#125;\n&#125;\n\n路由传参常见面试题一、路由传递参数（对象写法）path 是否可以结合params参数一起使用？\n\n不能！路由传递参数的时候，对象的写法可以是name、path的形式，但是需要注意path这种写法不能与&#96;&#96;params&#96;参数一起使用\n\n&#96;&#96;&#96;jsthis.$router.push({path: ‘&#x2F;search’,params: { keyword: this.keyword, query: { k: this.keyword.toUpperCase() } },})\n\n二、如何指定&#96;params&#96;参数可传可不传？\n\n- 比如，配置路由的时候已经占位了（&#96;params&#96;参数），但是路由跳转的时候没有传递\n\n- 路径就会存在问题 &#96;http:&#x2F;&#x2F;localhost:8080&#x2F;?#&#x2F;?k&#x3D;EWRE&#96; ，正常应该是 &#96;http:&#x2F;&#x2F;localhost:8080&#x2F;#&#x2F;search?k&#x3D;EWRE&#96;，不传的时候路径当中不存在&#96;search&#96;\n\n- 如果路由要求传递&#96;params&#96;参数，但是我们没有传递，那么&#96;URL&#96;会有问题\n\n- &#96;&#96;&#96;js\n  path: &quot;&#x2F;search&#x2F;:keyword?&quot;, &#x2F;&#x2F;在配置路由的时候，在占位后面加上一个 &#96;?&#96;，代表params参数可传可不传\n\n三、params参数可以传递也可以不传递，但是如果传递的是空串，如何解决？\n\n使用 undefined 解决：params参数可以传递或者不传递（空串）\n\n&#96;&#96;&#96;jsthis.$router.push({name: ‘search’,params: { keyword: ‘’ || undefined },query: { k: this.keyword.toUpperCase() },})\n\n四、路由组件能不能传递&#96;props&#96;数据？\n\n- 可以的，有三种写法\n\n- 第一种布尔值&#96;props:true&#96; ，只能传递&#96;params&#96;参数\n\n- 第二种对象写法\n\n- 第三种函数写法（常用）\n\n- &#96;&#96;&#96;js\n  &#123;\n      name: &quot;search&quot;,\n      path: &quot;&#x2F;search&#x2F;:keyword?&quot;,\n      component: Search,\n      meta: &#123;show: true&#125;\n      &#x2F;&#x2F; props: true\n      &#x2F;&#x2F; 对象写法:额外给路由组件传递一些 props\n      &#x2F;&#x2F; props:&#123;a:1,b:2&#125;\n      &#x2F;&#x2F; 函数写法：可以params参数、query参数，通过props传递给路由组件\n      props:($route)&#x3D;&gt;&#123;\n          return &#123;keyword:$route.params.keyword,k:$route.query.k&#125;;\n      &#125;\n  &#125;\n  组件中使用 props:[&#39;keyword&#39;,&#39;a&#39;,&#39;b&#39;] 接收\n\n编程式路由跳转到当前路由（参数不变），多次执行会抛出NavigationDuplicated的错误？\n路由跳转的两种形式：声明式导航、编程式导航，这里搜索使用的是push形式也就是编程式导航\n声明式导航没有这类问题，因为vue-router底层已经处理好了\n\n为什么编程式导航进行路由跳转的时候，会有这种错误？\n因为这里使用的 &quot;vue-router&quot;: &quot;^3.5.3&quot; 引入了 promise ，promise需要传入一个成功或者失败的回调，这样才能处理到这个错误。\nthis.$router.push(\n\t&#123;\n\t\tname: 'search',\n\t\tparams: &#123; keyword: this.keyword &#125;,\n\t\tquery: &#123; k: this.keyword.toUpperCase() &#125;,\n\t&#125;,\n\t// 给push方法传入响应的成功或回调函数，可以捕获当前错误解决\n\t() => &#123;&#125;,\n\t(error) => &#123;\n\t\tconsole.log(error)\n\t&#125;\n)\n\n上面这种方法只是治标不治本，将来在别的组件当中 push|replace，编程式导航还是会出现类似的错误。\nthis：当前组件实例\nthis.$router属性：当前这个属性，是VueRouter类的一个实例，当在入口文件注册路由的时候，给组件实例添加的 $router和$route属性\npush：是VueRouter类的一个实例的原型上的方法\n另一个方法：\n// 先把VueRouter原型对象的push，先保存一份\nlet originPush = VueRouter.prototype.push;\nlet originReplace = VueRouter.prototype.replace;\n//重写push|replace\n//第一个参数：告诉原来的push方法，往哪里跳转（传递那些参数）\n//第二个参数：成功的回调\n//第三个参数：失败的回调\nVueRouter.prototype.push = function (location, resolve, reject) &#123;\n if (resolve &amp;&amp; reject) &#123;\n  //call和apply的区别\n  //相同点，都可以调用函数一次，都可以篡改函数上下文\n  //不同点：call与apply传递参数方式 call传递参数用逗号隔开、apply方法执行传递数组\n  originPush.call(this, location,resolve,reject)\n&#125;else&#123;\n originPush.call(this,location,()=>&#123;&#125;,()=>&#123;&#125;)\n&#125;\nVueRouter.prototype.replace = function(location,resolve,reject)&#123;\n if (resolve&amp;&amp;reject)&#123;\n  originPush.call(this,location,resolve,reject)\n &#125;else&#123;\n  originPush.call(this,location,()=>&#123;&#125;,()=>&#123;&#125;)\n &#125;\n&#125;\n\nHome 模块组件拆分\n先把静态页面完成\n拆分出静态组件\n获取服务器的数据进行展示\njs动态业务完成\n\n三级联动组件的完成由于三级联动组件在 Home、Search、Detail 组件都出现了，把三级联动注册为全局组件\n好处：只需要注册一次，就可以在项目任意地方使用\n// 三级联动组件\nimport TypeNav from '@/pages/Home/TypeNav'\nVue.component('TypeNav', TypeNav)\n\n完成其它静态组件\nHTML + CSS + 图片资源 —- 细心【结构、样式、图片资源】\nPostman接口测试工具测试三级联动接口：\nhttp://gmall-h5-api.atguigu.cn/api/product/getBaseCategoryList\n\n\n如果服务器返回的数据code字段200，代表服务器返回数据成功。\n整个项目，接口的前缀都有/api字样\n\naxios 二次封装向服务器发起请求的方式有很多\n\nXMLHttpRequestr、fetach、jQuery、axios\n\n为什么需要进行二次封装？主要是为了设置请求拦截器、响应拦截器\n\n请求拦截器：可以在请求发起之前处理一些业务\n响应拦截器：当服务器数据返回后，可以处理一些事情\n\n安装 axiosnpm install --save axios@^0.24.0\nyarn add axios@^0.24.0 --save\n\n在项目中经常会有一个API文件夹，一般放置axios请求\n接口当中路径都带有 /api， baseURL: &quot;/api&quot; 的作用是在发请求的时候都自动带上 /api 在 url 中\n\n不写baseURL 发请求的时候需要写 /api/list/card\n加上了后发请求的时候只需要 /list/card\n\nimport axios from 'axios'\n\n// 1.利用axios对象的方法create，创建一个axios实例\n// 2.request就是axios，只不过可以稍微配置一些\nconst requests = axios.create(&#123;\n\t// 配置对象\n\tbaseURL: '/api',\n\t// 代表请求超时时间 5s\n\ttimeout: 5000,\n&#125;)\n\n// 请求拦截器：在发请求之前，请求拦截器可以监测到，可以在请求发出去之前做一些事情\nrequests.interceptors.request.use((config) => &#123;\n\t// config是一个配置对象，对象里面有一个属性 headers 请求头很重要\n\treturn config\n&#125;)\n\n// 响应拦截器\nrequests.interceptors.response.use(\n\t(res) => &#123;\n\t\t// 成功的回调函数，服务器数据回来之后，响应拦截器可以监测到\n\t\treturn res.data\n\t&#125;,\n\t(error) => &#123;\n\t\tconsole.log(error.message)\n\t\treturn Promise.reject(new Error('fail'))\n\t&#125;\n)\n\nexport default requests\n\nAPI接口统一管理\n项目很小：完全可以在组件的声明周期函数中发请求\n项目较大：axios.get(&#39;xxx&#39;)，这样写多了后面改就不方便了\n\nimport requests from '@/api/request'\n\n// 三级联动的接口 /api/product/getBaseCategoryList  GET请求 不需要携带参数\n// 发请求 axios 发请求返回结果是Promise对象\nexport const reqCategoryList = () =>\n\trequests(&#123;\n\t\turl: '/product/getBaseCategoryList',\n\t\tmethods: 'get',\n\t&#125;)\n\n跨域问题什么是跨域：协议、域名、端口号其中有一个不同，就会触发浏览器的同源策略产生跨域。\n前台项目本地服务器：http://localhost:8080/#/home\n后台服务器地址：http://gmall-h5-api.atguigu.cn\n解决跨域的方法有：JSONP、CORS、服务器代理\n代理跨域通常是在webpack.config.js中配置，目前我们是vue项目所以需要配置到 vue.config.js中，服务器与服务器之间是没有跨域问题的，前台项目在发请求的时候路径中 /api那么就会通过代理服务器帮我们发送请求\nmodule.exports = &#123;\n\tdevServer: &#123;\n\t\tproxy: &#123;\n\t\t\t'/api': &#123;\n\t\t\t\ttarget: 'http://gmall-h5-api.atguigu.cn',\n\t\t\t\t// pathRewriter:&#123;'^/api':''&#125;\n\t\t\t&#125;,\n\t\t&#125;,\n\t&#125;,\n&#125;\n\nNprogress进度条的使用安装nprogress：\nnpm install@^0.2.0 --save nprogress\nyarn add nprogress@^0.2.0 --save\n\n接下来只要项目发送请求，就开启进度条，服务器数据响应回来就关闭进度条。\n// 引入进度条\nimport nprogress from 'nprogress'\n// 引入进度条的样式\nimport 'nprogress/nprogress.css' // 可以通过修改源码的方式修改进度条的样式\nconsole.log(nprogress) // nprogress 身上start代表进度条开始，done代表进度条结束\n// 请求拦截器：在发请求之前，请求拦截器可以监测到，可以在请求发出去之前做一些事情\nrequests.interceptors.request.use((config) => &#123;\n\t// config是一个配置对象，对象里面有一个属性 headers 请求头很重要\n\t// 进度条开始\n\tnprogress.start()\n\treturn config\n&#125;)\n\n// 响应拦截器\nrequests.interceptors.response.use(\n\t(res) => &#123;\n\t\t// 成功的回调函数，服务器数据回来之后，响应拦截器可以监测到\n\t\t// 进度条结束\n\t\tnprogress.done()\n\t\treturn res.data\n\t&#125;,\n\t(error) => &#123;\n\t\tconsole.log(error.message)\n\t\treturn Promise.reject(new Error('fail'))\n\t&#125;\n)\n\nVuex状态管理库Vuex是什么？\nVuex官方提供的一个插件，是一个状态管理库，集中式管理项目中组件共用的数据。\n并不是全部的项目都需要Vuex，如果项目很小，完全不需要Vuex，如果项目很大，组件很多，数据很多维护起来很费劲，才会使用Vuex。\n安装Vuex\nnpm install --save vue@^3.6.2\nyarn add vuex@^3.6.2 --save\n\nVuex有几大核心概念\nstate：仓库存储数据的地方\nmutations：修改state的唯一手段\nactions：处理action，可以书写自己的业务逻辑，也可以处理异步\ngetters：理解为计算属性，用于简化仓库数据，让组件获取仓库数据更加方便\nmodules\n\nVuex基本使用在src文件夹下新建一个store文件夹用于存储Vuex相关文件\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n// 使用Vuex插件\nVue.use(Vuex)\nconst state = &#123;\n\tcount: 0,\n&#125;\nconst mutations = &#123;\n\tADD(state) &#123;\n\t\tstate.count++\n\t&#125;,\n&#125;\nconst actions = &#123;\n\t// 这里可以书写业务逻辑，但是不能修改state\n\tadd(&#123; commit &#125;) &#123;\n\t\tcommit('ADD')\n\t&#125;,\n&#125;\nconst getters = &#123;&#125;\n\n// 对外暴露Store类的实例\nexport default new Vuex.Store(&#123;\n\tstate,\n\tmutations,\n\tactions,\n\tgetters,\n&#125;)\n\nVuex 实现模块式开发项目比较小的是 Vuex 里面我们直接写成一个配置对象，当我们项目比较大组件、接口、数据都很多的时候，建议给Vuex分成模块开发把大仓库变成一个个小仓库。\n// 模拟很多模块的数据全部放在一个state中\n&#123;\n    count:1,\n    search:&#123;a:1&#125;,\n    detail:&#123;sss&#125;,\n pay:&#123;xx&#125;,\n    home:&#123;xxx&#125;,\n&#125;\n\n\n// store index.js\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n// 使用Vuex插件\nVue.use(Vuex)\nimport home from '@/store/home'\nimport search from '@/store/search'\n\n// 对外暴露Store类的实例\nexport default new Vuex.Store(&#123;\n\t// 实现Vuex仓库模块式开发\n\tmodules: &#123;\n\t\thome,\n\t\tsearch,\n\t&#125;,\n&#125;)\n\n// search 模块的小仓库\nconst state = &#123;&#125;\nconst mutations = &#123;&#125;\nconst actions = &#123;&#125;\nconst getters = &#123;&#125;\n\nexport default &#123;\n\tstate,\n\tmutations,\n\tactions,\n\tgetters,\n&#125;\n\n完成TypeNav组件三级联动展示数据业务[\n\t&#123;\n\t\t\"id\": 1,\n\t\t\"name\": \"电子书\",\n\t\t\"child\": [&#123; \"id\": 2, \"name\": \"喜洋洋\", \"child\": [] &#125;]\n\t&#125;\n]\n\n一级分类动态添加背景颜色第一种解决方案：采用样式完成\n.item:hover &#123;\n\tbackground: skyblue;\n&#125;\n\n第二种解决方案：通过JS完成\n控制响应式数据控制样式的显示和隐藏\n&lt;div @mouseleave=\"leaveIndex\"> // 事件委派\n &lt;h3 @mouseenter=\"changeIndex(index)\">&lt;/h3>\n&lt;/div>\n\ndata () &#123;\n    return &#123;\n      //  存储用户鼠标移到哪一个一级分类\n      currentIndex: -1\n    &#125;\n  &#125;,\nmethods: &#123;\n    //  鼠标进入修改响应式数据currentIndex属性\n    changeIndex (index) &#123;\n      // index 鼠标移到某个一级分类的元素的索引值\n      this.currentIndex = index\n    &#125;,\n    //  一级分类鼠标移除的回调\n    leaveIndex () &#123;\n      //  鼠标移除currentIndex，变成-1\n      this.currentIndex = -1\n    &#125;\n  &#125;\n\n通过 JS 控制二三级商品分类的显示与隐藏最开始的时候，是通过改变 CSS 样式display:block | none显示与隐藏二三级商品分类的。\n&lt;!-- 二级、三级分类-->\n&lt;div\n\tclass=\"item-list clearfix\"\n\t:style=\"&#123;display:currentIndex===index?'block':'none'&#125;\"\n>\n\t// js动态控制二三级分类显示与隐藏\n\t&lt;div class=\"subitem\" v-for=\"(c2) in c1.categoryChild\" :key=\"c2.categoryId\">\n\t\t&lt;dl class=\"fore\">\n\t\t\t&lt;dt>\n\t\t\t\t&lt;a href=\"\">&#123;&#123; c2.categoryName &#125;&#125;&lt;/a>\n\t\t\t&lt;/dt>\n\t\t\t&lt;dd>\n\t\t\t\t&lt;em v-for=\"(c3) in c2.categoryChild\" :key=\"c3.categoryId\">\n\t\t\t\t\t&lt;a href=\"\">&#123;&#123; c3.categoryName &#125;&#125;&lt;/a>\n\t\t\t\t&lt;/em>\n\t\t\t&lt;/dd>\n\t\t&lt;/dl>\n\t&lt;/div>\n&lt;/div>\n\n项目卡顿现象正常：事件触发非常频繁，而且每一次的触发，回调函数都要去执行（如果时间很短，而回调函数内部存在计算，那么可能导致浏览器出现卡顿）。\n\n正常情况用户慢慢的操作，鼠标进入，每一个一级分类h3，都会触发鼠标进入时间\n非正常情况用户操作很快，本身全部的一级分类都应该触发鼠标进入事件，但是经过测试只有部分的h3触发了\n由于用户行为过快，导致浏览器反应不过来，如果当前回调函数中有大量的业务，有可能出现卡顿现象\n\n节流：在规定的时间间隔范围内不会重复触发回调，只有大于这个事件间隔才会触发回调，把频繁触发变为少量触发。\n防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发，只会执行一次。\n完成三级联动节流操作import throttle from 'lodash/throttle' // 按需引入，因为是默认暴露所以不需要大括号\n// throttle 回调函数别用箭头函数，可能会出现上下文this问题\nchangeIndex: throttle(function (index) &#123;\n  // index 鼠标移到某个一级分类的元素的索引值\n  this.currentIndex = index\n&#125;, 50),\n\n三级联动路由跳转分析三级联动用户可以点击：一级分类、二级分类、三级分类，当你点击的时候\nHome模块跳转到Search模块，一级会把用户选中的产品（产品的名字、产品的 ID）在路由跳转的时候进行传递。\n路由跳转：\n\n声明式导航：router-link\n编程式导航：push|replace\n\n三级联动：如果使用声明式导航 router-link，可以实现路由的跳转与传递参数，但是会出现卡顿现象。\nrouter-link：它是一个组件，当服务器的数据返回之后，循环出很多router-link组件，会创建很多组件实例对象\n创建组件实例的时候，一瞬间创建1000+组件实例，是很耗内存的，所以不能使用声明式导航\n编程式导航使用 @click 在每一级分类标签上触发回调函数的方式，也不是特别好，因为在循环语句中它会创建很多个回调函数。\n&lt;div class=\"all-sort-list2\">\n\t&lt;div\n\t\tclass=\"item\"\n\t\tv-for=\"(c1,index) in categoryList\"\n\t\t:key=\"c1.categoryId\"\n\t\t:class=\"&#123;cur:currentIndex===index&#125;\"\n\t>\n\t\t&lt;h3 @mouseenter=\"changeIndex(index)\">\n\t\t\t&lt;a @click=\"goSearch\">&#123;&#123; c1.categoryName &#125;&#125;&lt;/a>\n\t\t&lt;/h3>\n\t\t&lt;!-- 二级、三级分类-->\n\t\t&lt;div\n\t\t\tclass=\"item-list clearfix\"\n\t\t\t:style=\"&#123;display:currentIndex===index?'block':'none'&#125;\"\n\t\t>\n\t\t\t&lt;div\n\t\t\t\tclass=\"subitem\"\n\t\t\t\tv-for=\"(c2) in c1.categoryChild\"\n\t\t\t\t:key=\"c2.categoryId\"\n\t\t\t>\n\t\t\t\t&lt;dl class=\"fore\">\n\t\t\t\t\t&lt;dt>\n\t\t\t\t\t\t&lt;a @click=\"goSearch\">&#123;&#123; c2.categoryName &#125;&#125;&lt;/a>\n\t\t\t\t\t&lt;/dt>\n\t\t\t\t\t&lt;dd>\n\t\t\t\t\t\t&lt;em v-for=\"(c3) in c2.categoryChild\" :key=\"c3.categoryId\">\n\t\t\t\t\t\t\t&lt;a @click=\"goSearch\">&#123;&#123; c3.categoryName &#125;&#125;&lt;/a>\n\t\t\t\t\t\t&lt;/em>\n\t\t\t\t\t&lt;/dd>\n\t\t\t\t&lt;/dl>\n\t\t\t&lt;/div>\n\t\t&lt;/div>\n\t&lt;/div>\n&lt;/div>\n\n// 进行路由跳转的方法\ngoSearch () &#123;\n    this.$router.push('/search')\n&#125;\n\n最好的解决方案：编程式导航 + 事件委派利用事件委派存在一定的问题：\n\n父节点下面有很多子节点，子节点h3/dt/dl/em的事件委派给了父级节点，只有点击a标签的时候才会进行路由跳转怎么知道点击的一定是a标签\n即使能够确定是a标签，又如何确认是一级还是二级、三级的a标签\n路由跳转的时候需要传递参数，那么如何获取到 1/2/3 级分类的产品的名字、id？\n\n完成三级联动的路由跳转与传递参数第一个问题：把子节点当中的 a 标签，加上自定义属性 data-categoryName，其余的子节点是没有的\n&lt;div class=\"all-sort-list2\" @click=\"goSearch\">\n\t&lt;div\n\t\tclass=\"item\"\n\t\tv-for=\"(c1,index) in categoryList\"\n\t\t:key=\"c1.categoryId\"\n\t\t:class=\"&#123;cur:currentIndex===index&#125;\"\n\t>\n\t\t&lt;h3 @mouseenter=\"changeIndex(index)\">\n\t\t\t&lt;a :data-categoryName=\"c1.categoryName\" :data-category1Id=\"c1.categoryId\"\n\t\t\t\t>&#123;&#123; c1.categoryName &#125;&#125;&lt;/a\n\t\t\t>\n\t\t&lt;/h3>\n\t\t&lt;!-- 二级、三级分类-->\n\t\t&lt;div\n\t\t\tclass=\"item-list clearfix\"\n\t\t\t:style=\"&#123;display:currentIndex===index?'block':'none'&#125;\"\n\t\t>\n\t\t\t&lt;div\n\t\t\t\tclass=\"subitem\"\n\t\t\t\tv-for=\"(c2) in c1.categoryChild\"\n\t\t\t\t:key=\"c2.categoryId\"\n\t\t\t>\n\t\t\t\t&lt;dl class=\"fore\">\n\t\t\t\t\t&lt;dt>\n\t\t\t\t\t\t&lt;a\n\t\t\t\t\t\t\t:data-categoryName=\"c2.categoryName\"\n\t\t\t\t\t\t\t:data-category2Id=\"c2.categoryId\"\n\t\t\t\t\t\t\t>&#123;&#123; c2.categoryName &#125;&#125;&lt;/a\n\t\t\t\t\t\t>\n\t\t\t\t\t&lt;/dt>\n\t\t\t\t\t&lt;dd>\n\t\t\t\t\t\t&lt;em v-for=\"(c3) in c2.categoryChild\" :key=\"c3.categoryId\">\n\t\t\t\t\t\t\t&lt;a\n\t\t\t\t\t\t\t\t:data-categoryName=\"c3.categoryName\"\n\t\t\t\t\t\t\t\t:data-category3Id=\"c3.categoryId\"\n\t\t\t\t\t\t\t\t>&#123;&#123; c3.categoryName &#125;&#125;&lt;/a\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t&lt;/em>\n\t\t\t\t\t&lt;/dd>\n\t\t\t\t&lt;/dl>\n\t\t\t&lt;/div>\n\t\t&lt;/div>\n\t&lt;/div>\n&lt;/div>\n\n// 进行路由跳转的方法\n    goSearch (event) &#123;\n      //  最好的解决方案：编程式导航 + 事件委派\n      let element = event.target\n      //  获取到当前触发这个事件的节点可能是 h3/a/dt/dl，需要带有 data-categoryname的节点，这个就是a标签\n      //  节点有一个属性dataset属性，可以获取节点的自定义属性与属性值\n      let &#123;categoryname, category1id, category2id, category3id&#125; = element.dataset;\n      //  如果标签身上有categoryname一定是a标签\n      if (categoryname) &#123;\n        //  整理路由跳转的参数\n        let location = &#123;name: 'search'&#125;;\n        let query = &#123;categoryName: categoryname&#125;\n        //  区分一级分类、二级分类、三级分类\n        if (category1id) &#123;\n          query.category1Id = category1id\n        &#125; else if (category2id) &#123;\n          query.category2Id = category2id\n        &#125; else &#123;\n          query.category3Id = category3id\n        &#125;\n        //  整理完参数\n        location.query = query\n        //  路由跳转\n        this.$router.push(location)\n      &#125;\n    &#125;\n\n总结\n商品分类的三级列表由静态变为动态形式（获取服务器数据：解决跨域问题）\n防抖和节流（常问）\n路由跳转：声明式导航（router-link）是组件实例，在循环中会创建很多个导致性能消耗很高、最终采用编程式导航\n编程式导航如何确定用户点击了那个 a 标签，解决这个问题我们采用了自定义属性 :data-categoryName 有这个属性的一定是a标签， 再通过另一个:data-categoryXId=&quot;cX.categoryId&quot; 来区分是一级还是二级、三级分类\n\nSearch 模块中商品分类与过渡动画开发 Search 模块中的 TypeNav 商品分类菜单（有过渡动画效果）\n过渡动画：前提是组件|元素务必要有 v-if | v-show 指令才能进行过渡动画，使用 transition 标签包裹有 v-if | v-show 指令的标签。\n&lt;transition name=\"sort\">\n\t&lt;div class=\"sort\" v-show=\"show\">xxxxx&lt;/div>\n&lt;/transition>\n\n// 过渡动画开始状态（进入）\n.sort-enter &#123;\n\theight: 0;\n&#125;\n\n// 过渡动画的结束状态（进入）\n.sort-enter-to &#123;\n\theight: 461px;\n&#125;\n\n//  定义动画的时间、速率\n.sort-enter.active &#123;\n\ttransition: all 0.5s linear;\n&#125;\n\n优化商品分类三级列表我们在 TypeNav 中发送了请求向服务器获取数据\n// 派发action 通知Vuex发请求，获取数据，存储在仓库中\nthis.$store.dispatch('categoryList')\n\n而 Home 组件和 Search 组件都用到了 TypeNav，在路由跳转的时候组件会进行销毁和创建，然后又发送了请求向服务器获取数据，这样每一次路由跳转都发送了一次请求性能消耗高。\n优化方案：将派发action的操作放到 App.vue 根组件的 mounted 中，根组件mounted只会执行一次，这样就不会再重复发送请求，而且数据也可以拿到。\n\n\n\n\n\n\n\n\n\n那么 main.js 也只会执行一次能不能放在 main.js 中呢？ 不能，因为main.js不是一个组件实例。\n合并params与query参数Header 组件\ngoSearch () &#123;\n  // 代表的是如果有 query 参数也带过去\n  if (this.$route.query) &#123;\n    let location = &#123;name: \"search\", params: &#123;keyword: this.keyword || undefined&#125;&#125;\n    location.query = this.$route.query\n    this.$router.push(location)\n  &#125;\n&#125;,\n\nTypeNav 组件\ngoSearch (event) &#123;\n     //  最好的解决方案：编程式导航 + 事件委派\n     let element = event.target\n     //  获取到当前触发这个事件的节点可能是 h3/a/dt/dl，需要带有 data-categoryname的节点，这个就是a标签\n     //  节点有一个属性dataset属性，可以获取节点的自定义属性与属性值\n     let &#123;categoryname, category1id, category2id, category3id&#125; = element.dataset;\n     //  如果标签身上有categoryname一定是a标签\n     if (categoryname) &#123;\n       //  整理路由跳转的参数\n       let location = &#123;name: 'search'&#125;;\n       let query = &#123;categoryName: categoryname&#125;\n       //  区分一级分类、二级分类、三级分类\n       if (category1id) &#123;\n         query.category1Id = category1id\n       &#125; else if (category2id) &#123;\n         query.category2Id = category2id\n       &#125; else &#123;\n         query.category3Id = category3id\n       &#125;\n       // 判断路由跳转的时候，带有params参数，也捎带过去\n       if (this.$route.params) &#123;\n         location.params = this.$route.params\n         //  动态给location配置对象添加query属性\n         location.query = query\n         //  路由跳转\n         this.$router.push(location)\n       &#125;\n     &#125;\n   &#125;,\n\n开发 Home 首页主要是开发首页中的 ListContainer组件与Floor组件\n这里服务器返回的数据（接口）只有商品分类菜单，对于ListContainer组件与Floor组件的数据服务器是没有提供的。\n我们需要 mock 数据：我们需要使用一个插件 mockjs\n安装 MockJSnpm install mockjs@^1.1.0\nyarn add mockjs@^1.1.0\n\n使用步骤：\n\n在项目文件夹src中创建一个mock文件夹\n准备json数据\n把mock数据需要的图片放到 public 文件夹中，public文件夹在打包的时候，会把相应的静态资源原封不动打包到dist文件夹中\n开始mock，通过mockjs模块实现，把JSON数据格式引入进来，JSON文件没有对外暴露，同样可以引入，因为webpack默认对外暴露的：图片、JSON数据格式，不要export，因为图片没办法暴露。\n把 mockServe.js文件在入口文件中引入，至少需要执行一次，才能模拟数据\n\nbanner.json\n[\n\t&#123;\n\t\t\"id\": \"1\",\n\t\t\"imgUrl\": \"/images/banner1.jpg\" // /代表打包之后的根目录 public\n\t&#125;,\n\t&#123;\n\t\t\"id\": \"2\",\n\t\t\"imgUrl\": \"/images/banner2.jpg\"\n\t&#125;,\n\t&#123;\n\t\t\"id\": \"3\",\n\t\t\"imgUrl\": \"/images/banner3.jpg\"\n\t&#125;,\n\t&#123;\n\t\t\"id\": \"4\",\n\t\t\"imgUrl\": \"/images/banner4.jpg\"\n\t&#125;\n]\n\nfloor.json\n[\n\t&#123;\n\t\t\"id\": \"001\",\n\t\t\"name\": \"家用电器\",\n\t\t\"keywords\": [\n\t\t\t\"节能补贴\",\n\t\t\t\"4K电视\",\n\t\t\t\"空气净化器\",\n\t\t\t\"IH电饭煲\",\n\t\t\t\"滚筒洗衣机\",\n\t\t\t\"电热水器\"\n\t\t],\n\t\t\"imgUrl\": \"/images/floor-1-1.png\",\n\t\t\"navList\": [\n\t\t\t&#123;\n\t\t\t\t\"url\": \"#\",\n\t\t\t\t\"text\": \"热门\"\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\t\"url\": \"#\",\n\t\t\t\t\"text\": \"大家电\"\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\t\"url\": \"#\",\n\t\t\t\t\"text\": \"生活电器\"\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\t\"url\": \"#\",\n\t\t\t\t\"text\": \"厨房电器\"\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\t\"url\": \"#\",\n\t\t\t\t\"text\": \"应季电器\"\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\t\"url\": \"#\",\n\t\t\t\t\"text\": \"空气/净水\"\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\t\"url\": \"#\",\n\t\t\t\t\"text\": \"高端电器\"\n\t\t\t&#125;\n\t\t],\n\t\t\"carouselList\": [\n\t\t\t&#123;\n\t\t\t\t\"id\": \"0011\",\n\t\t\t\t\"imgUrl\": \"/images/floor-1-b01.png\"\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\t\"id\": \"0012\",\n\t\t\t\t\"imgUrl\": \"/images/floor-1-b02.png\"\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\t\"id\": \"0013\",\n\t\t\t\t\"imgUrl\": \"/images/floor-1-b03.png\"\n\t\t\t&#125;\n\t\t],\n\t\t\"recommendList\": [\n\t\t\t\"/images/floor-1-2.png\",\n\t\t\t\"/images/floor-1-3.png\",\n\t\t\t\"/images/floor-1-5.png\",\n\t\t\t\"/images/floor-1-6.png\"\n\t\t],\n\t\t\"bigImg\": \"/images/floor-1-4.png\"\n\t&#125;,\n\t&#123;\n\t\t\"id\": \"002\",\n\t\t\"name\": \"手机通讯\",\n\t\t\"keywords\": [\n\t\t\t\"节能补贴2\",\n\t\t\t\"4K电视2\",\n\t\t\t\"空气净化器2\",\n\t\t\t\"IH电饭煲2\",\n\t\t\t\"滚筒洗衣机2\",\n\t\t\t\"电热水器2\"\n\t\t],\n\t\t\"imgUrl\": \"/images/floor-1-1.png\",\n\t\t\"navList\": [\n\t\t\t&#123;\n\t\t\t\t\"url\": \"#\",\n\t\t\t\t\"text\": \"热门2\"\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\t\"url\": \"#\",\n\t\t\t\t\"text\": \"大家电2\"\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\t\"url\": \"#\",\n\t\t\t\t\"text\": \"生活电器2\"\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\t\"url\": \"#\",\n\t\t\t\t\"text\": \"厨房电器2\"\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\t\"url\": \"#\",\n\t\t\t\t\"text\": \"应季电器2\"\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\t\"url\": \"#\",\n\t\t\t\t\"text\": \"空气/净水2\"\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\t\"url\": \"#\",\n\t\t\t\t\"text\": \"高端电器2\"\n\t\t\t&#125;\n\t\t],\n\t\t\"carouselList\": [\n\t\t\t&#123;\n\t\t\t\t\"id\": \"0011\",\n\t\t\t\t\"imgUrl\": \"/images/floor-1-b01.png\"\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\t\"id\": \"0012\",\n\t\t\t\t\"imgUrl\": \"/images/floor-1-b02.png\"\n\t\t\t&#125;,\n\t\t\t&#123;\n\t\t\t\t\"id\": \"0013\",\n\t\t\t\t\"imgUrl\": \"/images/floor-1-b03.png\"\n\t\t\t&#125;\n\t\t],\n\t\t\"recommendList\": [\n\t\t\t\"/images/floor-1-2.png\",\n\t\t\t\"/images/floor-1-3.png\",\n\t\t\t\"/images/floor-1-5.png\",\n\t\t\t\"/images/floor-1-6.png\"\n\t\t],\n\t\t\"bigImg\": \"/images/floor-1-4.png\"\n\t&#125;\n]\n\nmockServe.js\n// 引入 mockjs模块\nimport Mock from 'mockjs'\n// 把JSON数据格式引入进来，JSON文件没有对外暴露，但是可以引入，webpack默认对外暴露的：图片、JSON数据格式\nimport banner from './banner.json'\nimport floor from './floor.json'\n\n// mock 数据：第一个参数请求地址，第二个参数是请求数据\nMock.mock('/mock/banner', &#123; code: 200, data: banner &#125;) // 模拟首页大的轮播图的数据\nMock.mock('/mock/floor', &#123; code: 200, data: floor &#125;)\n\n// 在main.js中引入 mockServe.js --- mock数据\nimport '@/mock/mockServe'\n\nBanner 实现轮播图解决方案：定时器ListContainer 组件开发重点\n安装 Swiper@^5.4.5\nnpm install --save swiper@^5.4.5\nyarn add swiper@^5.4.5 --save\n\n\n引入 Swiper 相应的 JS 和 CSS包\n页面中的结构务必要已经存在了\n然后 new Swiper 实例，给轮播图添加动态效果，new Swiper 实例放在 mounted 当中，没有效果。\n在 new Swiper 实例是之前，页面中的结构必须得有，现在把 new Swiper 的实例放在 mounted 中发现不行，为什么？\nbannerList 的数据是从 vuex 中获取的，dispatch当中涉及异步的，导致 v-for 遍历这条语句的时候，因为结构是不完整的，前提是异步请求数据返回之后才能 v-for 遍历出数据。\n\n&lt;div class=\"swiper-slide\" v-for=\"(carousel) in bannerList\" :key=\"carousel.id\">\n\t&lt;img :src=\"carousel.imgUrl\" />\n&lt;/div>\n\nmounted () &#123;\n    //  派发action：通过Vuex发起ajax请求，将数据存储在仓库中\n    this.$store.dispatch('getBannerList')  // 这一行代码是异步的\n    // new Swiper(&#123;初始化Swiper实例&#125;) // 在这里初始化实例仓库中还没有捞到数据，结构就不是完整的，在这里new Swiper 是不对的，组件还没有数据\n    // 笨方法\n    setTimeout(() => &#123;\n      new Swiper(document.querySelector('.swiper-container'), &#123;\n        loop: true,\n        //  如果需要分页器\n        pagination: &#123;\n          el: '.swiper-pagination'\n        &#125;,\n        //  如果需要前进后退\n        navigation: &#123;\n          nextEl: '.swiper-button-next',\n          prevEl: '.swiper-button-prev'\n        &#125;\n      &#125;)\n    &#125;, 2000)\n  &#125;,\n// 获取\ncomputed: &#123;\n    ...mapState(&#123;\n      bannerList: state => state.home.bannerList\n    &#125;)\n  &#125;\n\n//\t获取首页轮播图的数据\nasync getBannerList (&#123;commit&#125;) &#123;\n    let result = await reqGetBannerList()\n    if (result.code === 200) &#123;\n    \tcommit('GETBANNERLIST', result.data)\n    &#125;\n&#125;\n\nGETBANNERLIST (state, bannerList) &#123;\n state.bannerList = bannerList\n&#125;\n\n轮播图最理想的解决方案 watch + nextTickwatch：数据监听，监听已有的数据变化\n仓库中的bannerList最开始是一个空数组，然后服务器发请求数据回来，获取到图片数据，这里是有数据变化的。\n通过 watch 监听 bannerList 属性值的变化，当我们监听的这个回调执行力，代表组件实例身上这个属性的数据已经有了。\nwatch: &#123;\n  //  监听bannerList数据的变化\n  bannerList:&#123;\n    handler(newValue,oldValue)&#123;\n      new Swiper(document.querySelector('.swiper-container'), &#123;\n        loop: true,\n        //  如果需要分页器\n        pagination: &#123;\n          el: '.swiper-pagination',\n          clickable:true\n        &#125;,\n        //  如果需要前进后退\n        navigation: &#123;\n          nextEl: '.swiper-button-next',\n          prevEl: '.swiper-button-prev'\n        &#125;\n      &#125;)\n    &#125;\n  &#125;\n&#125;\n\n那watch这种写法可以吗？还是不行~\n在这里new Swiper 还是没有结构，这里只能保证数据已经有了，但是 v-for 有没有执行完毕把结构渲染出来还是不确定的。\n$nextTick：在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即执行这个方法，获取更新后的DOM。\nbannerList 初始状态是一个空数组，数据拿到它发生数组中有了数据，DOM 已经更新完毕了，这里指的就是下次DOM更新，v-for 循环结束了结构已经有了，就是循环结束之后然后再延迟执行回调。\n在修改数据之后，bannerList就是一个空数组，服务器数据已经拿到了，v-for 循环结束之后，在执行 nextTick回调。\n$nextTick：可以保证页面中结构一定是有的，经常和很多插件一起使用，这些插件都需要DOM已经存在了。\n最终代码\nwatch: &#123;\n    //  监听bannerList数据的变化\n    bannerList: &#123;\n      handler (newValue, oldValue) &#123;\n        this.$nextTick(() => &#123;\n          new Swiper(document.querySelector('.swiper-container'), &#123;\n            loop: true,\n            //  如果需要分页器\n            pagination: &#123;\n              el: '.swiper-pagination',\n              clickable:true\n            &#125;,\n            //  如果需要前进后退\n            navigation: &#123;\n              nextEl: '.swiper-button-next',\n              prevEl: '.swiper-button-prev'\n            &#125;\n          &#125;)\n        &#125;)\n      &#125;\n    &#125;\n  &#125;\n\n开发 Floor 组件getFloorList 拿到的数据是一个数组，数组里面是两个对象分别给两个 Floor 组件使用的， Floor 组件我们是在Home中使用，并且使用了两次，所以不能直接在Floor组件中发请求。\ngetFloorList 只能在 Home 路由组件触发，拿到数据后 在Home组件中 v-for 遍历 Floor 组件。\nv-for 也可以在自定义组件(标签)上使用。\n组件通信的方式有哪些？\n\nprops 用于父子组件通信\n自定义事件 $on $emit 可以实现子给父通信\n全局事件总线：$bus 全能\npubsub-js：在Vue中几乎不用， 全能\n还有 插槽：默认插槽、具名插槽、作用域插槽\nVuex\n\n这次请求是父组件发的，然后父组件通过props传递给了Floor，在结构都已经有了的情况下执行mounted，所以就不会遇到之前 new Swiper 实例拿不到 DOM 结构的问题了。\n// Floor 组件\n&lt;script>\nimport Swiper from 'swiper'\n\nexport default &#123;\n  name: \"Floor\",\n  props: ['list'],\n  mounted () &#123;\n    // 第一次写 Swiper的时候，在mounted中写是不可以的，为什么在这里就可以了\n    // 之前写轮播图的时候，是在当前组件内部发请求，动态渲染解构，前台需要服务器的数据回来，因此之前的写法在这里不行\n    // 这里new Swiper的时候父组件已经发请求拿到数据了，数据给了Floor，Floor早已经把数据遍历完了\n    new Swiper(this.$refs.floor1Swiper, &#123;\n      loop: true,\n      //  如果需要分页器\n      pagination: &#123;\n        el: '.swiper-pagination',\n        clickable: true\n      &#125;,\n      //  如果需要前进后退\n      navigation: &#123;\n        nextEl: '.swiper-button-next',\n        prevEl: '.swiper-button-prev'\n      &#125;\n    &#125;)\n  &#125;\n&#125;\n&lt;/script>\n\n// Home组件\n&lt;template>\n    &lt;!-- Floor这个组件自己在组件内部是没有发请求的，数据是父组件给的 -->\n\t&lt;Floor v-for=\"(floor) in floorList\" :key=\"floor.id\" :list=\"floor\"/>\n&lt;/template>\nmounted () &#123;\n    //  派发action 获取 floor 组件的数据\n    this.$store.dispatch('getFloorList')\n  &#125;,\n  computed: &#123;\n    ...mapState(&#123;\n      floorList: state => state.home.floorList\n    &#125;)\n  &#125;\n\n把首页当中的轮播图拆分为一个全局共用的组件在开发项目的时候，如果某一个组件在很多地方都使用，就把它变为全局组件，注册一次，可以在任意地方使用，共用的组件和非路由组件放在 components 文件夹中。\nCarousel.vue封装&lt;template&gt;\n\t&lt;div class&#x3D;&quot;swiper-container&quot; ref&#x3D;&quot;cur&quot;&gt;\n\t\t&lt;div class&#x3D;&quot;swiper-wrapper&quot;&gt;\n\t\t\t&lt;div class&#x3D;&quot;swiper-slide&quot; v-for&#x3D;&quot;carousel in list&quot; :key&#x3D;&quot;carousel.id&quot;&gt;\n\t\t\t\t&lt;img :src&#x3D;&quot;carousel.imgUrl&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t&lt;&#x2F;div&gt;\n\n\t\t&lt;!-- 如果需要分页器 --&gt;\n\t\t&lt;div class&#x3D;&quot;swiper-pagination&quot;&gt;&lt;&#x2F;div&gt;\n\n\t\t&lt;!-- 如果需要导航按钮 --&gt;\n\t\t&lt;div class&#x3D;&quot;swiper-button-prev&quot;&gt;&lt;&#x2F;div&gt;\n\t\t&lt;div class&#x3D;&quot;swiper-button-next&quot;&gt;&lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Swiper from &#39;swiper&#39;\n\nexport default &#123;\n\tname: &#39;Carousel&#39;,\n\tprops: [&#39;list&#39;],\n\twatch: &#123;\n\t\tlist: &#123;\n\t\t\t&#x2F;&#x2F; 不管数据有没有变化，上来立即监听一次\n\t\t\t&#x2F;&#x2F; 为什么watch监听不到list，因为这个数据从来没有发生过变化，数据是父亲给的，来的时候就是一个对象，对象里面该有的书都存在\n\t\t\timmediate: true,\n\t\t\thandler() &#123;\n\t\t\t\t&#x2F;&#x2F;  只能监听到数据已经有了，但是 v-for动态渲染解构我们还是没有办法确定，因此还是需要用nextTic\n\t\t\t\tthis.$nextTick(() &#x3D;&gt; &#123;\n\t\t\t\t\tnew Swiper(this.$refs.cur, &#123;\n\t\t\t\t\t\tloop: true,\n\t\t\t\t\t\t&#x2F;&#x2F; 如果需要分页器\n\t\t\t\t\t\tpagination: &#123;\n\t\t\t\t\t\t\tel: &#39;.swiper-pagination&#39;,\n\t\t\t\t\t\t\t&#x2F;&#x2F;点击小球的时候也切换图片\n\t\t\t\t\t\t\tclickable: true,\n\t\t\t\t\t\t&#125;,\n\t\t\t\t\t\t&#x2F;&#x2F; 如果需要前进后退按钮\n\t\t\t\t\t\tnavigation: &#123;\n\t\t\t\t\t\t\tnextEl: &#39;.swiper-button-next&#39;,\n\t\t\t\t\t\t\tprevEl: &#39;.swiper-button-prev&#39;,\n\t\t\t\t\t\t&#125;,\n\t\t\t\t\t&#125;)\n\t\t\t\t&#125;)\n\t\t\t&#125;,\n\t\t&#125;,\n\t&#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;&lt;&#x2F;style&gt;\n\n使用 Carousel组件\n&lt;!--banner轮播--&gt;\n&lt;Carousel :list&#x3D;&quot;bannerList&quot; &#x2F;&gt;\n\nSearch 模块开发\n先写静态页面 + 静态组件拆分\n发请求（API）\nvuex （dispatch、commit、mutation修改state）\n组件获取仓库数据，动态展示数据\n\n这里注意一些问题有可能在请求 /api/list 这个接口的时候浏览器显示返回来 201 没有拿到数据，遇到这种情况怎么排查呢\n\n确认自己代码没有写错，比如说 axios 中对象写法 method: &#39;post&#39; 没有写成 methods: &#39;post&#39; 此类错误。\n如果是在找不到自己代码那里有问题就把源代码copy过来替换成自己的代码在继续运行。\n将gitee上的源代码下载运行起来看看请求是不是成功，如果成功证明服务器没有问题，如果不成功证明服务器可能这个接口就是连接不上（运行源代码的时候先把vue.config.js中的服务器代理地址换成最新的）\n\n如果没有在vuex中使用getters简化数据，那么我们在组件中获取数据是这么写的：\ncomputed: &#123;\n    ...mapState(&#123;\n      goodsList: state => state.search.searchList.goodsList\n    &#125;)\n  &#125;\n\n// 计算属性：为了简化仓库中的数据而生，让组件使用数据的时候简单一些\nconst getters = &#123;\n\t// 当前形参state是当前仓库中的state\n\tgoodsList(state) &#123;\n\t\treturn state.searchList.goodsList\n\t&#125;,\n\ttrademarkList(state) &#123;\n\t\treturn state.searchList.trademarkList\n\t&#125;,\n\tattrsList(state) &#123;\n\t\treturn state.searchList.attrsList\n\t&#125;,\n&#125;\n\n使用 getters 后获取数据的方式，这样就简化了后续组件使用时的操作\ncomputed: &#123;\n  // mapGetters 里面的写法：传递的是数组，因为getters计算时没有划分模块的[home/search]\n  ...mapGetters(['goodsList', 'trademarkList', 'attrsList'])\n&#125;\n\n\nstate.searchList.goodsList 如果服务器的数据回来了，没问题是一个数组。\n假如网络不给力或者没有网络，那么我们应该返回一个空数组，不返回的就是一个undefined\nundefined再去遍历的话就不对了\n\n修改之前getters代码如果没有数据返回一个空数组。\n// 计算属性：为了简化仓库中的数据而生，让组件使用数据的时候简单一些\nconst getters = &#123;\n\t// 当前形参state是当前仓库中的state\n\tgoodsList(state) &#123;\n\t\treturn state.searchList.goodsList || []\n\t&#125;,\n\ttrademarkList(state) &#123;\n\t\treturn state.searchList.trademarkList || []\n\t&#125;,\n\tattrsList(state) &#123;\n\t\treturn state.searchList.attrsList || []\n\t&#125;,\n&#125;\n\nsearch模块根据不同参数获取数据展示在发请求之前，把接口需要传递的参数进行整理，服务器就会返回查询的数据\n方法一：在beforeMount中使用Object.assign()方法合并对象\nObject.assign(this.searchParams, this.$route.query, this.$route.params)\n\n方法二：在beforeMount中使用 ... 扩展运算符的方式合并对象\nthis.searchParams = &#123;\n\t...this.searchParams,\n\t...this.$route.query,\n\t...this.$route.params,\n&#125;\n\n目前 Search 组件的 实现方式还存在问题，当用户点击手机跳转到 Search 页面，我们在输入oppo点击搜索，这是时候没办法发起第二次请求。\nmounted挂载只会执行一次，怎么能让它再次发送请求，不管是params还是query，搜索的时候地址栏都会发生变化。\n通过 watch 监听 $route 的变化来重新整理数据和发送ajax请求。\nwatch: &#123;\n  $route () &#123;\n    //  再次发请求之前整理带给服务器的参数\n    Object.assign(this.searchParams, this.$route.params, this.$route.query)\n    //  再次发起ajax请求\n    this.getData()\n  &#125;\n&#125;\n\n面包屑每一次请求完毕，应该把相应的1/2/3级分类的 id 置空，让它接受下一次相应的1/2/3级id\n分类名字与关键字不用清理，因为每一次路由发生变化的时候，都会赋予它新的数据\nwatch: &#123;\n  $route () &#123;\n    Object.assign(this.searchParams, this.$route.params, this.$route.query)\n    this.getData()\n    this.searchParams.category1Id = ''\n    this.searchParams.category2Id = ''\n    this.searchParams.category3Id = ''\n  &#125;\n&#125;\n\n带给服务器参数说明是可有可无的，如果属性为空的字符串还是会把相应的字段带给服务器，但是把响应的字段变为undefined，当前这个字段不会带给服务器，性能会更好一些\n地址栏也需要修改，进行路由跳转，使用编程式导航自己跳自己， params 参数在路由跳转刷新的时候回消失，当准备删除query参数的时候，路由跳转的时候应该带着。\nclearCategoryInfo () &#123;\n     this.searchParams.category1Id = undefined\n     this.searchParams.category2Id = undefined\n     this.searchParams.category3Id = undefined\n   &#125;,\n   removeCategoryName () &#123;\n     // 将带给服务器的参数置空，然后重新发送请求\n     this.searchParams.categoryName = undefined\n     this.clearCategoryInfo()\n     this.getData()\n     //  地址栏也需要修改，进行路由跳转，自己跳自己，并且params参数也姚带上\n      this.$router.push(&#123;name: 'search', params: this.$route.params&#125;)\n   &#125;\n\n面包屑处理关键字当面包屑中的关键字清除以后，需要让Header组件搜索框中的关键字清除\n涉及组件通信中的兄弟组件通信：使用全局事件总线 $bus\n在main.js的new Vue中配置事件总线\nnew Vue(&#123;\n\trender: (h) => h(App),\n\t// 全局事件总线配置\n\tbeforeCreate() &#123;\n\t\tVue.prototype.$bus = this\n\t&#125;,\n\t//需要把router进行注册\n\t//可以让全部的组件（非路由|路由组件）都可以获取到$route|$router属性\n\t//$route(路由)：可以获取到路由信息（path、query、params）\n\t//$router:进行编程式导航路由跳转push||replace\n\trouter,\n\t// 注册仓库：组件实例身上会多一个属性$store\n\tstore,\n&#125;).$mount('#app')\n\n然后就可以在 Search 组件中使用 $emit 触发 Header 组件去清除keyword 了\n//  通知Header清除关键字\nthis.$bus.$emit('clear')\n\nHeader 组件在 mounted中用$on响应事件\nmounted () &#123;\n  this.$bus.$on('clear', () => &#123;\n    this.keyword = ''\n  &#125;)\n&#125;\n\n面包屑处理品牌信息点击了品牌（苹果），我们还需要整理参数，向服务器发请求获取相应的数据进行展示，发请求的操作要在父组件中发起，我们整理的 searchParams 参数是父组件整理的然后再给服务器。\n所以我们点击了子组件 searchSelector ，searchSelector要把点击的品牌信息给父组件传递过去，使用自定义事件。\n&#x2F;&#x2F; 父组件 search 给子组件 searchSelector 绑定自定义事件\n&lt;SearchSelector @trademarkInfo&#x3D;&quot;trademarkInfo&quot; &#x2F;&gt;\n\n子组件 searchSelector 给每个品牌（li标签）绑定点击事件 tradeMarkHandle\ntradeMarkHandle (trademark) &#123;\n  // 点击了品牌，还是需要整理参数，向服务器发请求获取相应的数据进行展示\n  // 触发回调函数，将品牌数据传递过去\n  this.$emit('trademarkInfo', trademark)\n&#125;\n\n整理品牌字段的参数，&quot;ID:品牌名称&quot;\n//  自定义事件的回调\n   trademarkInfo (trademark) &#123;\n     this.searchParams.trademark = `$&#123;trademark.tmId&#125;:$&#123;trademark.tmName&#125;`\n     // 再次发请求获取search模块列表数据进行展示\n     this.getData()\n   &#125;\n\n&lt;!-- 品牌的面包屑--&gt;\n&lt;li class&#x3D;&quot;with-x&quot; v-if&#x3D;&quot;searchParams.trademark&quot;&gt;\n  &#123;&#123; searchParams.trademark.split(&#39;:&#39;)[1] &#125;&#125;\n  &lt;i @click&#x3D;&quot;removeTradeMark&quot;&gt;x&lt;&#x2F;i&gt;\n&lt;&#x2F;li&gt;\nmethods:&#123; removeTradeMark () &#123; this.searchParams.trademark &#x3D; undefined\nthis.getData() &#125; &#125;\n\n平台售卖属性新增获取平台售卖属性的回调，还是采用自定义事件触发回调函数的方式让 searchSelector 给父组件 Search传递数据。\n&lt;!--Search.vue--&gt;\n&lt;SearchSelector @trademarkInfo&#x3D;&quot;trademarkInfo&quot; @attrInfo&#x3D;&quot;attrInfo&quot; &#x2F;&gt;\n\n&lt;!--SearchSelector.vue  --&gt;\n&lt;!-- 平台售卖属性--&gt;\n    &lt;div class&#x3D;&quot;type-wrap&quot; v-for&#x3D;&quot;(attr) in attrsList&quot; :key&#x3D;&quot;attr.attrId&quot;&gt;\n      &lt;!--      平台售卖属性：比如说颜色--&gt;\n      &lt;div class&#x3D;&quot;fl key&quot;&gt;&#123;&#123; attr.attrName &#125;&#125;&lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;fl value&quot;&gt;\n        &lt;ul class&#x3D;&quot;type-list&quot;&gt;\n          &lt;!--平台相应售卖属性的属性值：粉色、蓝色、黑色--&gt;\n          &lt;li v-for&#x3D;&quot;(attrValue,index) in attr.attrValueList&quot; :key&#x3D;&quot;index&quot; @click&#x3D;&quot;attrInfo(attr,attrValue)&quot;&gt; &#x2F;&#x2F; 点击平台售卖属性触发回调函数传递属性ID:属性值:属性名等参数\n            &lt;a&gt;&#123;&#123; attrValue &#125;&#125;&lt;&#x2F;a&gt;\n          &lt;&#x2F;li&gt;\n        &lt;&#x2F;ul&gt;\n      &lt;&#x2F;div&gt;\n      &lt;div class&#x3D;&quot;fl ext&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n\n子组件 SearchSelector.vue 使用 this.$emit 触发回调，并且传递参数\n\nmethods: &#123;\n  tradeMarkHandle (trademark) &#123;\n    //  点击了品牌，还是需要整理参数，向服务器发请求获取相应的数据进行展示\n    this.$emit('trademarkInfo', trademark)\n  &#125;,\n  // 平台售卖属性值的点击事件\n  attrInfo (attr, attrValue) &#123;\n    // [\"属性ID:属性值:属性名\"]\n    this.$emit('attrInfo', attr, attrValue)\n  &#125;\n&#125;\n\n平台售卖属性面包屑\n&lt;!-- 平台的售卖属性值展示--&gt;\n&lt;li\n\tclass&#x3D;&quot;with-x&quot;\n\tv-for&#x3D;&quot;(attrValue, index) in searchParams.props&quot;\n\t:key&#x3D;&quot;index&quot;\n&gt;\n   &#123;&#123; attrValue.split(&#39;:&#39;)[1] &#125;&#125;\n   &lt;i @click&#x3D;&quot;removeAttr&quot;&gt;x&lt;&#x2F;i&gt;\n&lt;&#x2F;li&gt;\n\n父组件 Search.vue 收集平台属性回调函数\nattrInfo (attr, attrValue) &#123;\n      // 参数格式整理好  [\"属性ID:属性值:属性名\"]\n      let props = `$&#123;attr.attrId&#125;:$&#123;attrValue&#125;:$&#123;attr.attrName&#125;`;\n      // 数组去重\n      if (this.searchParams.props.indexOf(props) === -1) &#123;\n        this.searchParams.props.push(props)\n      &#125;\n      // 再次发送请求\n      this.getData()\n&#125;\n\nremoveAttr (index) &#123;\n      // 再次整理参数\n      this.searchParams.props.splice(index, 1)\n      this.getData()\n&#125;\n\n商品排序\n综合排序\n价格排序\nasc 升序，desc 降序\n示例：&quot;1:desc&quot;\n\norder 的属性值最多有多上中写法：\n\n1:asc\n1:desc\n2:asc\n2:desc\n\n排序的初始状态应该是综合且降序\ndata()&#123;\n\treturn&#123;\n\t\t....\n\t\torder: \"1:desc\",\n\t&#125;\n&#125;\n\n默认是综合有类名，点击价格给价格类名，通过判断 order 中 包含1还是2比如&quot;1:desc&quot; 还是 &quot;2:desc&quot;，变成2就是价格。\n综合和价格商品排序谁有类名就显示有箭头，箭头采用 iconfont.cn 中的icon图标。\n在index.html引入 icon，然后Search组件中 使用icon，通过动态类名+computed的方式来切换icon-UP 还是 icon-DOWN\n&lt;link\n\trel=\"stylesheet\"\n\thref=\"https://at.alicdn.com/t/font_2758111_9hehey1sgko.css\"\n/>\n\n&lt;li :class&#x3D;&quot;&#123; active: isOne &#125;&quot;&gt;\n  &lt;a&gt;综合\n    &lt;span v-show&#x3D;&quot;isOne&quot; class&#x3D;&quot;iconfont&quot; :class&#x3D;&quot;&#123;&#39;icon-UP&#39;:isAsc,&#39;icon-DOWN&#39;:isDesc&#125;&quot;&gt;&lt;&#x2F;span&gt;\n  &lt;&#x2F;a&gt;\n&lt;&#x2F;li&gt;\n&lt;li :class&#x3D;&quot;&#123; active: isTwo &#125;&quot;&gt;\n  &lt;a&gt;价格 &lt;span v-show&#x3D;&quot;isTwo&quot; class&#x3D;&quot;iconfont&quot; :class&#x3D;&quot;&#123;&#39;icon-UP&#39;:isAsc,&#39;icon-DOWN&#39;:isDesc&#125;&quot;&gt;&lt;&#x2F;span&gt;\n  &lt;&#x2F;a&gt;\n&lt;&#x2F;li&gt;\n\ncomputed: &#123;\n  isOne () &#123;\n    return this.searchParams.order.indexOf('1') !== -1\n  &#125;,\n  isTwo () &#123;\n    return this.searchParams.order.indexOf('2') !== -1\n  &#125;,\n  isAsc () &#123;\n    return this.searchParams.order.indexOf('asc') !== -1\n  &#125;,\n  isDesc () &#123;\n    return this.searchParams.order.indexOf('desc') !== -1\n  &#125;\n&#125;,\n\n然后我们给每一个li（综合、价格） 绑定单击事件\n&lt;li :class&#x3D;&quot;&#123; active: isOne &#125;&quot; @click&#x3D;&quot;changeOrder(&#39;1&#39;)&quot;&gt;\n      &lt;a&gt;综合\n          &lt;span v-show&#x3D;&quot;isOne&quot; class&#x3D;&quot;iconfont&quot; :class&#x3D;&quot;&#123;&#39;icon-UP&#39;:isAsc,&#39;icon-DOWN&#39;:isDesc&#125;&quot;&gt;&lt;&#x2F;span&gt;\n      &lt;&#x2F;a&gt;\n&lt;&#x2F;li&gt;\n&lt;li :class&#x3D;&quot;&#123; active: isTwo &#125;&quot; @click&#x3D;&quot;changeOrder(&#39;2&#39;)&quot;&gt;\n    &lt;a&gt;价格 &lt;span v-show&#x3D;&quot;isTwo&quot; class&#x3D;&quot;iconfont&quot; :class&#x3D;&quot;&#123;&#39;icon-UP&#39;:isAsc,&#39;icon-DOWN&#39;:isDesc&#125;&quot;&gt;&lt;&#x2F;span&gt;\n    &lt;&#x2F;a&gt;\n&lt;&#x2F;li&gt;\n\n完成商品排序操作\nchangeOrder (flag) &#123;\n    // flag 它是一个标记，代表用户点击的是综合还是价格\n    // 获取order初始状态【咱们需要通过初始状态去判断接下来做什么】\n    let originOrder = this.searchParams.order\n    let originFlag = originOrder.split(':')[0]\n    let originSort = originOrder.split(':')[1]\n    // 准备一个新的order 属性值\n    let newOrder = ''\n    // 判断的是多次点击是不是同一个按钮\n    if (flag === originFlag) &#123;\n        newOrder = `$&#123;originFlag&#125;:$&#123;originSort === 'desc' ? 'asc' : 'desc'&#125;`\n    &#125; else &#123;\n        //  点击的不是同一个按钮\n        newOrder = `$&#123;flag&#125;:$&#123;'desc'&#125;`\n    &#125;\n    // 将新的 order 传给 searchParams\n    this.searchParams.order = newOrder\n    //  再次发请求\n    this.getData()\n&#125;\n\n分页器功能为什么很多项目采用分页功能，主要是平台同时展示的数据有很多（1W+）浏览器加载出来就会很卡，所以需要采用分页功能。\nElementUI 是有相应的分页组件的使用起来很简单，但是还是需要自己了解分页功能具体怎么实现，可以自定义分页工。\n分页器的展示需要那些数据\n需要知道当前页数是第几页，pageNo 字段代表当前页数\n需要知道每一页需要展示多少条数据，pageSize 字段\ntotal 字段代表，分页器一共需要展示多少条数据，这里可以确定一共有多少页的信息\n需要知道分页器连续的页码个数5|7奇数比较对称，偶数显示效果不对称\n\n总结：对于分页器而言，自定义前提需要知道四个前提条件\n\npageNo：当前第几个\npageSize：代表每一页展示多少条数据\ntotal：代表整个分页一共要展示多少条数据\ncontinues：代表分页连续页码个数\n\n自定义分页器，在开发的时候先自己mock数据，调试成功后，在使用服务器的数据。\n对于分页器而言，很重要的一点是要算出来连续页码起始数字和结束数字，当前页是第8页那么就是 ...6 7 8 9 10 ...\n如果是第15页，那么就是... 13 14 15 16 17 ...，前面是当前页码-2后面是当前页码+2这样显示\n同时我们要让分页器连续页码可以随时调整，比如当前是第8页，连续页码 5 页就是 6 7 8 9 10，当前第 8 页，连续页码 7 页那么就是 5 6 7 8 9 10 11。\n分页器的数字没有 0 ，也不能是负数，所以如果出现这种不正常的现象应该让数字往前挪动。\n//  计算出连续的页码的起始数字与结束数字(连续的页码数字：至少是5)\nstartNumAndEndNum () &#123;\n  const &#123;pageNo, continues, totalPage&#125; = this\n  //  先定义两个变量存储起始数字与结束数字\n  let start = 0, end = 0;\n  // 先判断连续页码至少五页，如果不够五页，总页数没有连续的页码多\n  if (continues > totalPage) &#123;\n    start = 1;\n    end = totalPage;\n  &#125; else &#123;\n    //  连续的页码5，但是我们的总页数一定是大于5页的\n    // 起始数字\n    start = pageNo - parseInt(continues / 2);\n    // 结束数字\n    end = pageNo + parseInt(continues / 2)\n    //  start 出现0还有负数，我们需要纠正\n    if (start &lt; 1) &#123;\n      start = 1\n      end = continues\n    &#125;\n    //  end 数字大于总页码了\n    if (end > totalPage) &#123;\n      end = totalPage\n      start = totalPage - continues + 1\n    &#125;\n  &#125;\n  return &#123;start, end&#125;\n&#125;\n\n分页器动态展示v-for可以遍历 Array Object Number String\n自定义分页器实现完整代码\n&lt;template&gt;\n\t&lt;div class&#x3D;&quot;pagination&quot;&gt;\n\t\t&lt;h1&gt;&#123;&#123; startNumAndEndNum &#125;&#125;---当前页码&#123;&#123; pageNo &#125;&#125;&lt;&#x2F;h1&gt;\n\t\t&lt;button :disabled&#x3D;&quot;pageNo &#x3D;&#x3D;&#x3D; 1&quot; @click&#x3D;&quot;$emit(&#39;getPageNo&#39;, pageNo - 1)&quot;&gt;\n\t\t\t上一页\n\t\t&lt;&#x2F;button&gt;\n\t\t&lt;button v-show&#x3D;&quot;startNumAndEndNum.start &gt; 1&quot; @click&#x3D;&quot;$emit(&#39;getPageNo&#39;, 1)&quot;&gt;\n\t\t\t1\n\t\t&lt;&#x2F;button&gt;\n\t\t&lt;button v-show&#x3D;&quot;startNumAndEndNum.start &gt; 2&quot;&gt;....&lt;&#x2F;button&gt;\n\n\t\t&lt;!-- 中间部分--&gt;\n\t\t&lt;button\n\t\t\tv-for&#x3D;&quot;(page, index) in startNumAndEndNum.end&quot;\n\t\t\t:key&#x3D;&quot;index&quot;\n\t\t\tv-show&#x3D;&quot;page &gt;&#x3D; startNumAndEndNum.start&quot;\n\t\t\t@click&#x3D;&quot;$emit(&#39;getPageNo&#39;, page)&quot;\n\t\t&gt;\n\t\t\t&#123;&#123; page &#125;&#125;\n\t\t&lt;&#x2F;button&gt;\n\n\t\t&lt;button v-show&#x3D;&quot;startNumAndEndNum.end &lt; totalPage - 1&quot;&gt;...&lt;&#x2F;button&gt;\n\t\t&lt;button\n\t\t\tv-if&#x3D;&quot;startNumAndEndNum.end &lt; totalPage&quot;\n\t\t\t@click&#x3D;&quot;$emit(&#39;getPageNo&#39;, totalPage)&quot;\n\t\t&gt;\n\t\t\t&#123;&#123; totalPage &#125;&#125;\n\t\t&lt;&#x2F;button&gt;\n\t\t&lt;button\n\t\t\t:disabled&#x3D;&quot;pageNo &#x3D;&#x3D;&#x3D; totalPage&quot;\n\t\t\t@click&#x3D;&quot;$emit(&#39;getPageNo&#39;, pageNo + 1)&quot;\n\t\t&gt;\n\t\t\t下一页\n\t\t&lt;&#x2F;button&gt;\n\t\t&lt;button style&#x3D;&quot;margin-left: 30px&quot;&gt;共&#123;&#123; total &#125;&#125;条&lt;&#x2F;button&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n\tname: &#39;Pagination&#39;,\n\tprops: [&#39;pageNo&#39;, &#39;pageSize&#39;, &#39;total&#39;, &#39;continues&#39;],\n\tcomputed: &#123;\n\t\t&#x2F;&#x2F;  总共有多少页\n\t\ttotalPage() &#123;\n\t\t\t&#x2F;&#x2F; 向上取整\n\t\t\treturn Math.ceil(this.total &#x2F; this.pageSize)\n\t\t&#125;,\n\t\t&#x2F;&#x2F;  计算出连续的页码的起始数字与结束数字(连续的页码数字：至少是5)\n\t\tstartNumAndEndNum() &#123;\n\t\t\tconst &#123; pageNo, continues, totalPage &#125; &#x3D; this\n\t\t\t&#x2F;&#x2F;  先定义两个变量存储起始数字与结束数字\n\t\t\tlet start &#x3D; 0,\n\t\t\t\tend &#x3D; 0\n\t\t\t&#x2F;&#x2F; 先判断连续页码至少五页，如果不够五页，总页数没有连续的页码多\n\t\t\tif (continues &gt; totalPage) &#123;\n\t\t\t\tstart &#x3D; 1\n\t\t\t\tend &#x3D; totalPage\n\t\t\t&#125; else &#123;\n\t\t\t\t&#x2F;&#x2F;  连续的页码5，但是我们的总页数一定是大于5页的\n\t\t\t\t&#x2F;&#x2F; 起始数字\n\t\t\t\tstart &#x3D; pageNo - parseInt(continues &#x2F; 2)\n\t\t\t\t&#x2F;&#x2F; 结束数字\n\t\t\t\tend &#x3D; pageNo + parseInt(continues &#x2F; 2)\n\t\t\t\t&#x2F;&#x2F;  start 出现0还有负数，我们需要纠正\n\t\t\t\tif (start &lt; 1) &#123;\n\t\t\t\t\tstart &#x3D; 1\n\t\t\t\t\tend &#x3D; continues\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F;  end 数字大于总页码了\n\t\t\t\tif (end &gt; totalPage) &#123;\n\t\t\t\t\tend &#x3D; totalPage\n\t\t\t\t\tstart &#x3D; totalPage - continues + 1\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\treturn &#123; start, end &#125;\n\t\t&#125;,\n\t&#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n开发商品详情页面\n静态组件（详情页组件）\n发请求\nvuex\n动态展示组件\n\n首先增加 Detail 组件的路由，并且跳转到商品详情页的时候是需要带上产品的Id，配置路由的时候需要占位\n// router.js\n&#123;\n path: \"/detail:skuid\",\n component: Detail,\n meta: &#123;isShow: false&#125;,\n&#125;,\n\nVueRouter滚动行为使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。\n注意: 这个功能只在支持 history.pushState 的浏览器中可用。\nscrollBehavior 方法与 routes 平级放在一起：\nexport default new VueRouter(&#123;\n\t//配置路由\n\t//第一:路径的前面需要有/(不是二级路由)\n\t//路径中单词都是小写的\n\t//component右侧V别给我加单引号【字符串：组件是对象（VueComponent类的实例）】\n\troutes,\n\tscrollBehavior(to, from, savedPosition) &#123;\n\t\t// return 期望滚动到哪个的位置 y=0 代表的滚动条在最上方\n\t\treturn &#123; y: 0 &#125;\n\t&#125;,\n&#125;)\n\n写请求接口API\n// 获取产品详情的接口 URL: /api/item/&#123;skuId&#125; 请求方式 get\nexport const reqGoodsInfo = (skuId) =>\n\trequests(&#123;\n\t\turl: `/item/$&#123;skuId&#125;`,\n\t\tmethod: 'get',\n\t&#125;)\n\nVuex 获取产品详情信息\nVuex中新增一个模块 detail，然后在 Detail 组件中mounted挂载时获取产品数据详情\nimport &#123; reqGoodsInfo &#125; from '@/api'\n\nconst state = &#123;\n\tgoodInfo: &#123;&#125;,\n&#125;\nconst mutations = &#123;\n\tGETGOODINFO(state, goodInfo) &#123;\n\t\tstate.goodInfo = goodInfo\n\t&#125;,\n&#125;\nconst actions = &#123;\n\t// 获取产品信息的action\n\tasync getGoodInfo(&#123; commit &#125;, skuId) &#123;\n\t\tlet result = await reqGoodsInfo(skuId)\n\t\tif (result.code === 200) &#123;\n\t\t\tcommit('GETGOODINFO', result.data)\n\t\t&#125;\n\t&#125;,\n&#125;\nconst getters = &#123;&#125;\nexport default &#123;\n\tstate,\n\tmutations,\n\tactions,\n\tgetters,\n&#125;\n\n我们使用getters简化数据给组件使用的时候，数据可能不存在。比如 state.goodInfo 初始状态空对象，空对象的categoryView属性值undefined当前计算出的 categoryView 属性值至少是一个空对象，报错就不会有了。\nconst getters = &#123;\n\tcategoryView(state) &#123;\n\t\t// 比如 state.goodInfo 初始状态空对象，空对象的categoryView属性值undefined\n\t\t// 当前计算出的 categoryView 属性值至少是一个空对象,报错就不会有了\n\t\treturn state.goodInfo.categoryView || &#123;&#125;\n\t&#125;,\n&#125;\n\n总结封装分页器原理\n\n知道当前是第几页：pageNo\n知道分页数据一共有多少条：total\n知道每一页需要展示数据的个数：pageSize 同时计算出 — totalPage\n连续的页码数：5|7奇数比较对称\n最终要的还是分解出连续的页码的起始数字与结束数字\n\n连续的页码数 — 5 （暗含条件是分页器至少五页）\nstart等于当前页码-2，end是当前页码+2特殊情况也要考虑，pageNo是1的话那么连续的页码就会变成-1 0 1 2 3，这样不行。\n项目当中控制台\nvue-warn：警告（不影响的你程序），对于你的代码提出一个警告。\n对于程序没有任何影响，俗称假报错。\nZoom 放大镜显示数据父组件detail给子组件zoom传递数据， 但是服务器的数据有可能没有回来，skuInfo这个对象是一个空对象，会导致控制台报错\n\n\n如果是空对象重新计算给它一个默认值为一个空数组。\n//  给子组件的数据\nskuImageList () &#123;\n  return this.skuInfo.skuImageList || []\n&#125;\n\n同时子组件 Zoom 中也需要重新计算，数组的第 0 项也可是个空对象\n&lt;template&gt;\n\t&lt;div class&#x3D;&quot;spec-preview&quot;&gt;\n\t\t&lt;img :src&#x3D;&quot;imgObj.imgUrl&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;\n\t\t&lt;div class&#x3D;&quot;event&quot;&gt;&lt;&#x2F;div&gt;\n\t\t&lt;div class&#x3D;&quot;big&quot;&gt;\n\t\t\t&lt;img :src&#x3D;&quot;imgObj.imgUrl&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;\n\t\t&lt;&#x2F;div&gt;\n\t\t&lt;div class&#x3D;&quot;mask&quot;&gt;&lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\ncomputed: &#123;\n  imgObj () &#123;\n    return this.skuImageList[0] || &#123;&#125;\n  &#125;\n&#125;\n\n数据解释—售卖属性[\n\t&#123;\n\t\t\"attr\": \"颜色\",\n\t\t\"attrValue\": [\"粉色\", \"天蓝色\", \"红色\"]\n\t&#125;,\n\t&#123;\n\t\t\"attr\": \"版本\",\n\t\t\"attrValue\": [\"16\", \"29\"]\n\t&#125;\n]\n\n点击谁谁亮 — 排他，知道当前有几个数据点击的是谁，点击的是售卖属性的值 dd\n&lt;dd\n\tchangepirce=\"0\"\n\t:class=\"&#123;active:spuSaleAttrValue.isChecked === '1'&#125;\"\n\tv-for=\"(spuSaleAttrValue,index) in spuSaleAttr.spuSaleAttrValueList\"\n\t:key=\"spuSaleAttrValue.id\"\n\t@click=\"changeActive(spuSaleAttrValue,spuSaleAttr.spuSaleAttrValueList)\"\n>\n\t&#123;&#123; spuSaleAttrValue.saleAttrValueName &#125;&#125;\n&lt;/dd>\n\n// 产品的售卖属性值切换高亮\n   changeActive (saleAttrValue, arr) &#123;\n     // 遍历全部售卖属性值isChecked为0没有高亮了\n     arr.forEach(item => &#123;\n       item.isChecked = 0\n     &#125;)\n     //  点击的那个售卖属性值高亮\n     saleAttrValue.isChecked = '1'\n   &#125;\n\n放大镜操作\n设置商品详情页图片下面的轮播图。\n通过事件总线的方式点击下方轮播图切换产品图片。\nImageList.vue\n&lt;template&gt;\n\t&lt;div class&#x3D;&quot;swiper-container&quot; ref&#x3D;&quot;cur&quot;&gt;\n\t\t&lt;div class&#x3D;&quot;swiper-wrapper&quot;&gt;\n\t\t\t&lt;div\n\t\t\t\tclass&#x3D;&quot;swiper-slide&quot;\n\t\t\t\tv-for&#x3D;&quot;(slide, index) in skuImageList&quot;\n\t\t\t\t:key&#x3D;&quot;slide.id&quot;\n\t\t\t&gt;\n\t\t\t\t&lt;img\n\t\t\t\t\t:src&#x3D;&quot;slide.imgUrl&quot;\n\t\t\t\t\t:class&#x3D;&quot;&#123; active: currentIndex &#x3D;&#x3D;&#x3D; index &#125;&quot;\n\t\t\t\t\t@click&#x3D;&quot;changeCurrentIndex(index)&quot;\n\t\t\t\t&#x2F;&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t&lt;&#x2F;div&gt;\n\t\t&lt;div class&#x3D;&quot;swiper-button-next&quot;&gt;&lt;&#x2F;div&gt;\n\t\t&lt;div class&#x3D;&quot;swiper-button-prev&quot;&gt;&lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport Swiper from &#39;swiper&#39;\n\nexport default &#123;\n\tname: &#39;ImageList&#39;,\n\tdata() &#123;\n\t\treturn &#123;\n\t\t\tcurrentIndex: 0,\n\t\t&#125;\n\t&#125;,\n\tprops: [&#39;skuImageList&#39;],\n\twatch: &#123;\n\t\t&#x2F;&#x2F; 监听数据可以保证数据一定是ok的，但是不能保证v-for遍历结构是否完事\n\t\tskuImageList() &#123;\n\t\t\tthis.$nextTick(() &#x3D;&gt; &#123;\n\t\t\t\tnew Swiper(this.$refs.cur, &#123;\n\t\t\t\t\t&#x2F;&#x2F; 如果需要前进后退按钮\n\t\t\t\t\tnavigation: &#123;\n\t\t\t\t\t\tnextEl: &#39;.swiper-button-next&#39;,\n\t\t\t\t\t\tprevEl: &#39;.swiper-button-prev&#39;,\n\t\t\t\t\t&#125;,\n\t\t\t\t\t&#x2F;&#x2F;  显示几个图片的设置\n\t\t\t\t\tslidesPerView: 3,\n\t\t\t\t&#125;)\n\t\t\t&#125;)\n\t\t&#125;,\n\t&#125;,\n\tmethods: &#123;\n\t\tchangeCurrentIndex(index) &#123;\n\t\t\t&#x2F;&#x2F; 修改响应式数据\n\t\t\tthis.currentIndex &#x3D; index\n\t\t\t&#x2F;&#x2F;  通知Zoom当前索引值为几\n\t\t\tthis.$bus.$emit(&#39;getIndex&#39;, this.currentIndex)\n\t\t&#125;,\n\t&#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\nZoom.vue\n&lt;template&gt;\n\t&lt;div class&#x3D;&quot;spec-preview&quot;&gt;\n\t\t&lt;img :src&#x3D;&quot;imgObj.imgUrl&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;\n\t\t&lt;div class&#x3D;&quot;event&quot; @mousemove&#x3D;&quot;handler&quot;&gt;&lt;&#x2F;div&gt;\n\t\t&lt;div class&#x3D;&quot;big&quot;&gt;\n\t\t\t&lt;img :src&#x3D;&quot;imgObj.imgUrl&quot; alt&#x3D;&quot;&quot; ref&#x3D;&quot;big&quot; &#x2F;&gt;\n\t\t&lt;&#x2F;div&gt;\n\t\t&lt;div class&#x3D;&quot;mask&quot; ref&#x3D;&quot;mask&quot;&gt;&lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n\tname: &#39;Zoom&#39;,\n\tdata() &#123;\n\t\treturn &#123;\n\t\t\tcurrentIndex: 0,\n\t\t&#125;\n\t&#125;,\n\tprops: [&#39;skuImageList&#39;],\n\tcomputed: &#123;\n\t\timgObj() &#123;\n\t\t\treturn this.skuImageList[this.currentIndex] || &#123;&#125;\n\t\t&#125;,\n\t&#125;,\n\tmounted() &#123;\n\t\t&#x2F;&#x2F; 全局事件总线获取兄弟组件传递过来的索引值\n\t\tthis.$bus.$on(&#39;getIndex&#39;, (index) &#x3D;&gt; &#123;\n\t\t\t&#x2F;&#x2F; 当拿到兄弟给的index后修改当前的currentIndex\n\t\t\tthis.currentIndex &#x3D; index\n\t\t&#125;)\n\t&#125;,\n\tmethods: &#123;\n\t\thandler(event) &#123;\n\t\t\tlet mask &#x3D; this.$refs.mask\n\t\t\tlet big &#x3D; this.$refs.big\n\t\t\tlet left &#x3D; event.offsetX - mask.offsetWidth &#x2F; 2\n\t\t\tlet top &#x3D; event.offsetY - mask.offsetHeight &#x2F; 2\n\t\t\t&#x2F;&#x2F; 约束范围\n\t\t\tif (left &lt;&#x3D; 0) left &#x3D; 0\n\t\t\tif (left &gt;&#x3D; mask.offsetWidth) left &#x3D; mask.offsetWidth\n\t\t\tif (top &lt;&#x3D; 0) top &#x3D; 0\n\t\t\tif (top &gt;&#x3D; mask.offsetHeight) top &#x3D; mask.offsetHeight\n\t\t\t&#x2F;&#x2F;  修改元素的left|top属性值\n\t\t\tmask.style.left &#x3D; left + &#39;px&#39;\n\t\t\tmask.style.top &#x3D; top + &#39;px&#39;\n\t\t\tbig.style.left &#x3D; -2 * left + &#39;px&#39;\n\t\t\tbig.style.top &#x3D; -2 * top + &#39;px&#39;\n\t\t&#125;,\n\t&#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n\n加购物车前的用户输入表单操作，要判断用户输入的是不是正常的数字，既不能小于 1 也不能有小数点。\n&lt;div class&#x3D;&quot;controls&quot;&gt;\n  &lt;input autocomplete&#x3D;&quot;off&quot; class&#x3D;&quot;itxt&quot; v-model&#x3D;&quot;skuNum&quot; @change&#x3D;&quot;changeSkuNum&quot;&#x2F;&gt;\n  &lt;a href&#x3D;&quot;javascript:&quot; class&#x3D;&quot;plus&quot; @click&#x3D;&quot;skuNum++&quot;&gt;+&lt;&#x2F;a&gt;\n  &lt;a href&#x3D;&quot;javascript:&quot; class&#x3D;&quot;mins&quot; @click&#x3D;&quot;skuNum&gt;1?skuNum--:skuNum&#x3D;1&quot;&gt;-&lt;&#x2F;a&gt;\n&lt;&#x2F;div&gt;\n\nchangeSkuNum (event) &#123;\n  // 用户输入进来的文本 * 1\n  let value = event.target.value * 1\n  // 如果用户输入进来的非法，出现NaN或者小于1\n  if (isNaN(value) || value &lt; 1) &#123;\n    this.skuNum = 1;\n  &#125; else &#123;\n    // 正常大于1，大于1整数不能出现小数\n    this.skuNum = parseInt(value)\n  &#125;\n&#125;\n\n加购物车\n发送请求，将当前产品告诉服务器买的是什么买了多少个\n服务器存储成功之后进行路由器的跳转，跳转到商品已成功加入购物车页面\n跳转的时候一些产品信息如产品标题和数量通过query参数传递过去\n\n新增 API 接口// 将产品添加到购物车中，或者更新某一个产品的个数\nexport const reqAddOrUpdateShopCart = (skuId, skuNum) =>\n\trequests(&#123;\n\t\turl: `/cart/addToCart/$&#123;skuId&#125;/$&#123;skuNum&#125;`,\n\t\tmethod: 'post',\n\t&#125;)\n\n在store中的detail.js文件增加action回调\n// 加入购物车的或者修改某一个产品的个数\nasync addOrUpdateShopCart(&#123;commit&#125;,&#123;skuid,skuNum&#125;)&#123;\n    // 发请求:前端带一些参数给服务器，需要存储这些数据，存储成功了，没有返回数据，这里不需要仓库存储数据了\n    // 注意：async 函数执行返回的结构一定是一个promise，要么成功要么失败\n\tlet result = await reqAddOrUpdateShopCart(skuid,skuNum);\n    if(reuslt.code===200)&#123;\n        // 返回的是成功的标记\n        return 'ok';\n    &#125;else&#123;\n        // 返回的是失败的标记\n        return Promise.reject(new Error('fail'))\n    &#125;\n&#125;\n\n在Detail.vue 组件中派发action\n这里我们需要在路由跳转的时候还需要将产品的信息带给下一级的路由组件，通过路由传递 skuInfo 对象参数的方式太丑了，地址栏很长，所以使用浏览器的存储。\n浏览器存储功能：HTML5中新增的，本地存储和会话存储\n本地存储：持久化的，最多存储5M\n会话存储：不是持久的，窗口（会话）关闭数据就消失\n不管是本地存储还是会话存储，一般存储的都是字符串，不能存一个对象，所以我们需要把对象变成一个字符串去存储。\n产品信息（skuInfo）的数据比较复杂，所以选择通过会话储存的方式存在浏览器中，它不会持久化，这样用户频繁操作的时候不会存太多无用的信息。\naddShopCart()&#123;\n    try &#123;\n        // 1.再点击加入购物车按钮的时候，第一件事情就是将参数带给服务器（发请求），通知服务器加入购物车的产品是什么\n    \t// this.$store.dispatch('detail/addOrUpdateShopCart')... 这行代码实际上是在调用 vuex 中的addOrUpdateShopCart\n        await this.$store.dispatch('detail/addOrUpdateShopCart', &#123;\n          skuId: this.$route.params.skuid,\n          skuNum: this.skuNum\n        &#125;)\n        //  路由跳转\n        sessionStorage.setItem('SKUINFO', JSON.stringify(this.skuInfo))\n        await this.$router.push(&#123;name: 'addcartsuccess', query: &#123;skuNum: this.skuNum&#125;&#125;)\n      &#125; catch (error) &#123;\n       // 2.需要知道这次请求成功还是失败，如果成功进行路由跳转，如果失败，需要给用户提示\n        console.log(error)\n      &#125;\n&#125;\n\n在AddCartSuccess组件中用 sessionStorage 中的数据的时候先通过计算属性简化：\ncomputed: &#123;\n  skuInfo () &#123;\n    return JSON.parse(sessionStorage.getItem('SKUINFO'))\n  &#125;\n&#125;\n\n增加购物车组件 ShopCart.vue&lt;template&gt;\n\t&lt;div class&#x3D;&quot;cart&quot;&gt;\n\t\t&lt;h4&gt;全部商品&lt;&#x2F;h4&gt;\n\t\t&lt;div class&#x3D;&quot;cart-main&quot;&gt;\n\t\t\t&lt;div class&#x3D;&quot;cart-th&quot;&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;cart-th1&quot;&gt;全部&lt;&#x2F;div&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;cart-th2&quot;&gt;商品&lt;&#x2F;div&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;cart-th3&quot;&gt;单价（元）&lt;&#x2F;div&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;cart-th4&quot;&gt;数量&lt;&#x2F;div&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;cart-th5&quot;&gt;小计（元）&lt;&#x2F;div&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;cart-th6&quot;&gt;操作&lt;&#x2F;div&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t\t&lt;div class&#x3D;&quot;cart-body&quot;&gt;\n\t\t\t\t&lt;ul class&#x3D;&quot;cart-list&quot;&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con1&quot;&gt;\n\t\t\t\t\t\t&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;chk_list&quot; &#x2F;&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con2&quot;&gt;\n\t\t\t\t\t\t&lt;img src&#x3D;&quot;.&#x2F;images&#x2F;goods1.png&quot; &#x2F;&gt;\n\t\t\t\t\t\t&lt;div class&#x3D;&quot;item-msg&quot;&gt;\n\t\t\t\t\t\t\t米家（MIJIA） 小米小白智能摄像机增强版\n\t\t\t\t\t\t\t1080p高清360度全景拍摄AI增强\n\t\t\t\t\t\t&lt;&#x2F;div&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con4&quot;&gt;\n\t\t\t\t\t\t&lt;span class&#x3D;&quot;price&quot;&gt;399.00&lt;&#x2F;span&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con5&quot;&gt;\n\t\t\t\t\t\t&lt;a href&#x3D;&quot;javascript:void(0)&quot; class&#x3D;&quot;mins&quot;&gt;-&lt;&#x2F;a&gt;\n\t\t\t\t\t\t&lt;input\n\t\t\t\t\t\t\tautocomplete&#x3D;&quot;off&quot;\n\t\t\t\t\t\t\ttype&#x3D;&quot;text&quot;\n\t\t\t\t\t\t\tvalue&#x3D;&quot;1&quot;\n\t\t\t\t\t\t\tminnum&#x3D;&quot;1&quot;\n\t\t\t\t\t\t\tclass&#x3D;&quot;itxt&quot;\n\t\t\t\t\t\t&#x2F;&gt;\n\t\t\t\t\t\t&lt;a href&#x3D;&quot;javascript:void(0)&quot; class&#x3D;&quot;plus&quot;&gt;+&lt;&#x2F;a&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con6&quot;&gt;\n\t\t\t\t\t\t&lt;span class&#x3D;&quot;sum&quot;&gt;399&lt;&#x2F;span&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con7&quot;&gt;\n\t\t\t\t\t\t&lt;a href&#x3D;&quot;#none&quot; class&#x3D;&quot;sindelet&quot;&gt;删除&lt;&#x2F;a&gt;\n\t\t\t\t\t\t&lt;br &#x2F;&gt;\n\t\t\t\t\t\t&lt;a href&#x3D;&quot;#none&quot;&gt;移到收藏&lt;&#x2F;a&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t&lt;&#x2F;ul&gt;\n\n\t\t\t\t&lt;ul class&#x3D;&quot;cart-list&quot;&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con1&quot;&gt;\n\t\t\t\t\t\t&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;chk_list&quot; id&#x3D;&quot;&quot; value&#x3D;&quot;&quot; &#x2F;&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con2&quot;&gt;\n\t\t\t\t\t\t&lt;img src&#x3D;&quot;.&#x2F;images&#x2F;goods2.png&quot; &#x2F;&gt;\n\t\t\t\t\t\t&lt;div class&#x3D;&quot;item-msg&quot;&gt;\n\t\t\t\t\t\t\t华为（MIJIA） 华为metaPRO 30 浴霸4摄像 超清晰\n\t\t\t\t\t\t&lt;&#x2F;div&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con4&quot;&gt;\n\t\t\t\t\t\t&lt;span class&#x3D;&quot;price&quot;&gt;5622.00&lt;&#x2F;span&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con5&quot;&gt;\n\t\t\t\t\t\t&lt;a href&#x3D;&quot;javascript:void(0)&quot; class&#x3D;&quot;mins&quot;&gt;-&lt;&#x2F;a&gt;\n\t\t\t\t\t\t&lt;input\n\t\t\t\t\t\t\tautocomplete&#x3D;&quot;off&quot;\n\t\t\t\t\t\t\ttype&#x3D;&quot;text&quot;\n\t\t\t\t\t\t\tvalue&#x3D;&quot;1&quot;\n\t\t\t\t\t\t\tminnum&#x3D;&quot;1&quot;\n\t\t\t\t\t\t\tclass&#x3D;&quot;itxt&quot;\n\t\t\t\t\t\t&#x2F;&gt;\n\t\t\t\t\t\t&lt;a href&#x3D;&quot;javascript:void(0)&quot; class&#x3D;&quot;plus&quot;&gt;+&lt;&#x2F;a&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con6&quot;&gt;\n\t\t\t\t\t\t&lt;span class&#x3D;&quot;sum&quot;&gt;5622&lt;&#x2F;span&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con7&quot;&gt;\n\t\t\t\t\t\t&lt;a href&#x3D;&quot;#none&quot; class&#x3D;&quot;sindelet&quot;&gt;删除&lt;&#x2F;a&gt;\n\t\t\t\t\t\t&lt;br &#x2F;&gt;\n\t\t\t\t\t\t&lt;a href&#x3D;&quot;#none&quot;&gt;移到收藏&lt;&#x2F;a&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t&lt;&#x2F;ul&gt;\n\n\t\t\t\t&lt;ul class&#x3D;&quot;cart-list&quot;&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con1&quot;&gt;\n\t\t\t\t\t\t&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;chk_list&quot; id&#x3D;&quot;&quot; value&#x3D;&quot;&quot; &#x2F;&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con2&quot;&gt;\n\t\t\t\t\t\t&lt;img src&#x3D;&quot;.&#x2F;images&#x2F;goods3.png&quot; &#x2F;&gt;\n\t\t\t\t\t\t&lt;div class&#x3D;&quot;item-msg&quot;&gt;\n\t\t\t\t\t\t\tiphone 11 max PRO 苹果四摄 超清晰 超费电 超及好用\n\t\t\t\t\t\t&lt;&#x2F;div&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con4&quot;&gt;\n\t\t\t\t\t\t&lt;span class&#x3D;&quot;price&quot;&gt;11399.00&lt;&#x2F;span&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con5&quot;&gt;\n\t\t\t\t\t\t&lt;a href&#x3D;&quot;javascript:void(0)&quot; class&#x3D;&quot;mins&quot;&gt;-&lt;&#x2F;a&gt;\n\t\t\t\t\t\t&lt;input\n\t\t\t\t\t\t\tautocomplete&#x3D;&quot;off&quot;\n\t\t\t\t\t\t\ttype&#x3D;&quot;text&quot;\n\t\t\t\t\t\t\tvalue&#x3D;&quot;1&quot;\n\t\t\t\t\t\t\tminnum&#x3D;&quot;1&quot;\n\t\t\t\t\t\t\tclass&#x3D;&quot;itxt&quot;\n\t\t\t\t\t\t&#x2F;&gt;\n\t\t\t\t\t\t&lt;a href&#x3D;&quot;javascript:void(0)&quot; class&#x3D;&quot;plus&quot;&gt;+&lt;&#x2F;a&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con6&quot;&gt;\n\t\t\t\t\t\t&lt;span class&#x3D;&quot;sum&quot;&gt;11399&lt;&#x2F;span&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con7&quot;&gt;\n\t\t\t\t\t\t&lt;a href&#x3D;&quot;#none&quot; class&#x3D;&quot;sindelet&quot;&gt;删除&lt;&#x2F;a&gt;\n\t\t\t\t\t\t&lt;br &#x2F;&gt;\n\t\t\t\t\t\t&lt;a href&#x3D;&quot;#none&quot;&gt;移到收藏&lt;&#x2F;a&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t&lt;&#x2F;ul&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t&lt;&#x2F;div&gt;\n\t\t&lt;div class&#x3D;&quot;cart-tool&quot;&gt;\n\t\t\t&lt;div class&#x3D;&quot;select-all&quot;&gt;\n\t\t\t\t&lt;input class&#x3D;&quot;chooseAll&quot; type&#x3D;&quot;checkbox&quot; &#x2F;&gt;\n\t\t\t\t&lt;span&gt;全选&lt;&#x2F;span&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t\t&lt;div class&#x3D;&quot;option&quot;&gt;\n\t\t\t\t&lt;a href&#x3D;&quot;#none&quot;&gt;删除选中的商品&lt;&#x2F;a&gt;\n\t\t\t\t&lt;a href&#x3D;&quot;#none&quot;&gt;移到我的关注&lt;&#x2F;a&gt;\n\t\t\t\t&lt;a href&#x3D;&quot;#none&quot;&gt;清除下柜商品&lt;&#x2F;a&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t\t&lt;div class&#x3D;&quot;money-box&quot;&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;chosed&quot;&gt;已选择 &lt;span&gt;0&lt;&#x2F;span&gt;件商品&lt;&#x2F;div&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;sumprice&quot;&gt;\n\t\t\t\t\t&lt;em&gt;总价（不含运费） ：&lt;&#x2F;em&gt;\n\t\t\t\t\t&lt;i class&#x3D;&quot;summoney&quot;&gt;0&lt;&#x2F;i&gt;\n\t\t\t\t&lt;&#x2F;div&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;sumbtn&quot;&gt;\n\t\t\t\t\t&lt;a class&#x3D;&quot;sum-btn&quot; href&#x3D;&quot;###&quot; target&#x3D;&quot;_blank&quot;&gt;结算&lt;&#x2F;a&gt;\n\t\t\t\t&lt;&#x2F;div&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t&lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nexport default &#123;\n\tname: &#39;ShopCart&#39;,\n&#125;\n&lt;&#x2F;script&gt;\n\n&lt;style lang&#x3D;&quot;less&quot; scoped&gt;\n.cart &#123;\n\twidth: 1200px;\n\tmargin: 0 auto;\n\n\th4 &#123;\n\t\tmargin: 9px 0;\n\t\tfont-size: 14px;\n\t\tline-height: 21px;\n\t&#125;\n\n\t.cart-main &#123;\n\t\t.cart-th &#123;\n\t\t\tbackground: #f5f5f5;\n\t\t\tborder: 1px solid #ddd;\n\t\t\tpadding: 10px;\n\t\t\toverflow: hidden;\n\n\t\t\t&amp; &gt; div &#123;\n\t\t\t\tfloat: left;\n\t\t\t&#125;\n\n\t\t\t.cart-th1 &#123;\n\t\t\t\twidth: 25%;\n\n\t\t\t\tinput &#123;\n\t\t\t\t\tvertical-align: middle;\n\t\t\t\t&#125;\n\n\t\t\t\tspan &#123;\n\t\t\t\t\tvertical-align: middle;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\t\t\t.cart-th2 &#123;\n\t\t\t\twidth: 25%;\n\t\t\t&#125;\n\n\t\t\t.cart-th3,\n\t\t\t.cart-th4,\n\t\t\t.cart-th5,\n\t\t\t.cart-th6 &#123;\n\t\t\t\twidth: 12.5%;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t.cart-body &#123;\n\t\t\tmargin: 15px 0;\n\t\t\tborder: 1px solid #ddd;\n\n\t\t\t.cart-list &#123;\n\t\t\t\tpadding: 10px;\n\t\t\t\tborder-bottom: 1px solid #ddd;\n\t\t\t\toverflow: hidden;\n\n\t\t\t\t&amp; &gt; li &#123;\n\t\t\t\t\tfloat: left;\n\t\t\t\t&#125;\n\n\t\t\t\t.cart-list-con1 &#123;\n\t\t\t\t\twidth: 15%;\n\t\t\t\t&#125;\n\n\t\t\t\t.cart-list-con2 &#123;\n\t\t\t\t\twidth: 35%;\n\n\t\t\t\t\timg &#123;\n\t\t\t\t\t\twidth: 82px;\n\t\t\t\t\t\theight: 82px;\n\t\t\t\t\t\tfloat: left;\n\t\t\t\t\t&#125;\n\n\t\t\t\t\t.item-msg &#123;\n\t\t\t\t\t\tfloat: left;\n\t\t\t\t\t\twidth: 150px;\n\t\t\t\t\t\tmargin: 0 10px;\n\t\t\t\t\t\tline-height: 18px;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\n\t\t\t\t.cart-list-con4 &#123;\n\t\t\t\t\twidth: 10%;\n\t\t\t\t&#125;\n\n\t\t\t\t.cart-list-con5 &#123;\n\t\t\t\t\twidth: 17%;\n\n\t\t\t\t\t.mins &#123;\n\t\t\t\t\t\tborder: 1px solid #ddd;\n\t\t\t\t\t\tborder-right: 0;\n\t\t\t\t\t\tfloat: left;\n\t\t\t\t\t\tcolor: #666;\n\t\t\t\t\t\twidth: 6px;\n\t\t\t\t\t\ttext-align: center;\n\t\t\t\t\t\tpadding: 8px;\n\t\t\t\t\t&#125;\n\n\t\t\t\t\tinput &#123;\n\t\t\t\t\t\tborder: 1px solid #ddd;\n\t\t\t\t\t\twidth: 40px;\n\t\t\t\t\t\theight: 33px;\n\t\t\t\t\t\tfloat: left;\n\t\t\t\t\t\ttext-align: center;\n\t\t\t\t\t\tfont-size: 14px;\n\t\t\t\t\t&#125;\n\n\t\t\t\t\t.plus &#123;\n\t\t\t\t\t\tborder: 1px solid #ddd;\n\t\t\t\t\t\tborder-left: 0;\n\t\t\t\t\t\tfloat: left;\n\t\t\t\t\t\tcolor: #666;\n\t\t\t\t\t\twidth: 6px;\n\t\t\t\t\t\ttext-align: center;\n\t\t\t\t\t\tpadding: 8px;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\n\t\t\t\t.cart-list-con6 &#123;\n\t\t\t\t\twidth: 10%;\n\n\t\t\t\t\t.sum &#123;\n\t\t\t\t\t\tfont-size: 16px;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\n\t\t\t\t.cart-list-con7 &#123;\n\t\t\t\t\twidth: 13%;\n\n\t\t\t\t\ta &#123;\n\t\t\t\t\t\tcolor: #666;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\n\t.cart-tool &#123;\n\t\toverflow: hidden;\n\t\tborder: 1px solid #ddd;\n\n\t\t.select-all &#123;\n\t\t\tpadding: 10px;\n\t\t\toverflow: hidden;\n\t\t\tfloat: left;\n\n\t\t\tspan &#123;\n\t\t\t\tvertical-align: middle;\n\t\t\t&#125;\n\n\t\t\tinput &#123;\n\t\t\t\tvertical-align: middle;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t.option &#123;\n\t\t\tpadding: 10px;\n\t\t\toverflow: hidden;\n\t\t\tfloat: left;\n\n\t\t\ta &#123;\n\t\t\t\tfloat: left;\n\t\t\t\tpadding: 0 10px;\n\t\t\t\tcolor: #666;\n\t\t\t&#125;\n\t\t&#125;\n\n\t\t.money-box &#123;\n\t\t\tfloat: right;\n\n\t\t\t.chosed &#123;\n\t\t\t\tline-height: 26px;\n\t\t\t\tfloat: left;\n\t\t\t\tpadding: 0 10px;\n\t\t\t&#125;\n\n\t\t\t.sumprice &#123;\n\t\t\t\twidth: 200px;\n\t\t\t\tline-height: 22px;\n\t\t\t\tfloat: left;\n\t\t\t\tpadding: 0 10px;\n\n\t\t\t\t.summoney &#123;\n\t\t\t\t\tcolor: #c81623;\n\t\t\t\t\tfont-size: 16px;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\n\t\t\t.sumbtn &#123;\n\t\t\t\tfloat: right;\n\n\t\t\t\ta &#123;\n\t\t\t\t\tdisplay: block;\n\t\t\t\t\tposition: relative;\n\t\t\t\t\twidth: 96px;\n\t\t\t\t\theight: 52px;\n\t\t\t\t\tline-height: 52px;\n\t\t\t\t\tcolor: #fff;\n\t\t\t\t\ttext-align: center;\n\t\t\t\t\tfont-size: 18px;\n\t\t\t\t\tfont-family: &#39;Microsoft YaHei&#39;;\n\t\t\t\t\tbackground: #e1251b;\n\t\t\t\t\toverflow: hidden;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n&lt;&#x2F;style&gt;\n\nUUID游客身份获取购物车数据增加 API 接口\n// 获取购物车列表数据接口\nexport const reqCartList = () =>\n\trequests(&#123; url: '/cart/cartList', method: 'get' &#125;)\n\n向服务器发起ajax请求vuex 获取数据\nimport &#123; reqCartList &#125; from '@/api'\n\nconst state = &#123;&#125;\nconst mutations = &#123;&#125;\nconst actions = &#123;\n\t// 获取购物车列表数据\n\tasync getCartList(&#123; commit &#125;) &#123;\n\t\tlet result = await reqCartList()\n\t\tconsole.log(result)\n\t&#125;,\n&#125;\nconst getters = &#123;&#125;\n\nexport default &#123;\n\tnamespaced: true,\n\tstate,\n\tmutations,\n\tactions,\n\tgetters,\n&#125;\n\n通过组件展示数据，发请求的时候获取不到用户购物车里面的数据，因为服务器不知道当前用户是谁。\ndetail组件加入购物车的瞬间，告诉服务器UUID\n新建 utils 文件夹，在文件夹内新建一个uuid_token.js 文件，提供随机生成uuid功能，且支持持久化存储\nimport &#123; v4 as uuidv4 &#125; from 'uuid'\n\n// 要生成一个随机字符串，且每次执行不能发生变化，游客身份持久存储\nexport const getUUID = () => &#123;\n\t// 先从本地存储获取uuid，验证本地存储是否存在\n\tlet uuid_token = localStorage.getItem('UUIDTOKEN')\n\t// 如果没有，生成\n\tif (!uuid_token) &#123;\n\t\t// 生成游客临时身份\n\t\tuuid_token = uuidv4()\n\t\t// 本地存储一次\n\t\tlocalStorage.setItem('UUIDTOKEN', uuid_token)\n\t&#125;\n&#125;\n\n在 detail 组件的仓库中新增游客临时身份字段\nimport &#123; getUUID &#125; from '@/utils/uuid_token'\nconst state = &#123;\n\tgoodInfo: &#123;&#125;,\n\t// 游客临时身份\n\tuuid_token: getUUID(),\n&#125;\n\n通过在请求拦截器中给请求头添加一个字段的方式向后台传递参数\nimport store from '@/store'\n// 请求拦截器：在发请求之前，请求拦截器可以监测到，可以在请求发出去之前做一些事情\nrequests.interceptors.request.use((config) => &#123;\n\t//\tconfig是一个配置对象，对象里面有一个属性 headers 请求头很重要\n\tif (store.state.detail.uuid_token) &#123;\n\t\t//\t请求头添加一个字段(userTempId)，需要和后台商量\n\t\tconfig.headers.userTempId = store.state.detail.uuid_token\n\t&#125;\n\t// 进度条开始懂\n\tnprogress.start()\n\treturn config\n&#125;)\n\n目前仓库中能获取当前用户的购物车数据了，接下来就是仓库存储，组件捞取数据动态展示，并且修改产品数量\n&lt;template&gt;\n\t&lt;div class&#x3D;&quot;cart&quot;&gt;\n\t\t&lt;h4&gt;全部商品&lt;&#x2F;h4&gt;\n\t\t&lt;div class&#x3D;&quot;cart-main&quot;&gt;\n\t\t\t&lt;div class&#x3D;&quot;cart-th&quot;&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;cart-th1&quot;&gt;全部&lt;&#x2F;div&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;cart-th2&quot;&gt;商品&lt;&#x2F;div&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;cart-th3&quot;&gt;单价（元）&lt;&#x2F;div&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;cart-th4&quot;&gt;数量&lt;&#x2F;div&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;cart-th5&quot;&gt;小计（元）&lt;&#x2F;div&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;cart-th6&quot;&gt;操作&lt;&#x2F;div&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t\t&lt;div class&#x3D;&quot;cart-body&quot;&gt;\n\t\t\t\t&lt;ul class&#x3D;&quot;cart-list&quot; v-for&#x3D;&quot;cart in cartInfoList&quot; :key&#x3D;&quot;cart.id&quot;&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con1&quot;&gt;\n\t\t\t\t\t\t&lt;input\n\t\t\t\t\t\t\ttype&#x3D;&quot;checkbox&quot;\n\t\t\t\t\t\t\tname&#x3D;&quot;chk_list&quot;\n\t\t\t\t\t\t\t:checked&#x3D;&quot;cart.isChecked &#x3D;&#x3D;&#x3D; 1&quot;\n\t\t\t\t\t\t&#x2F;&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con2&quot;&gt;\n\t\t\t\t\t\t&lt;img :src&#x3D;&quot;cart.imgUrl&quot; &#x2F;&gt;\n\t\t\t\t\t\t&lt;div class&#x3D;&quot;item-msg&quot;&gt;&#123;&#123; cart.skuName &#125;&#125;&lt;&#x2F;div&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con4&quot;&gt;\n\t\t\t\t\t\t&lt;span class&#x3D;&quot;price&quot;&gt;&#123;&#123; cart.skuPrice &#125;&#125;.00&lt;&#x2F;span&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con5&quot;&gt;\n\t\t\t\t\t\t&lt;a\n\t\t\t\t\t\t\thref&#x3D;&quot;javascript:void(0)&quot;\n\t\t\t\t\t\t\tclass&#x3D;&quot;mins&quot;\n\t\t\t\t\t\t\t@click&#x3D;&quot;handler(&#39;minus&#39;, -1, cart)&quot;\n\t\t\t\t\t\t\t&gt;-&lt;&#x2F;a\n\t\t\t\t\t\t&gt;\n\t\t\t\t\t\t&lt;input\n\t\t\t\t\t\t\tautocomplete&#x3D;&quot;off&quot;\n\t\t\t\t\t\t\ttype&#x3D;&quot;text&quot;\n\t\t\t\t\t\t\tminnum&#x3D;&quot;1&quot;\n\t\t\t\t\t\t\tclass&#x3D;&quot;itxt&quot;\n\t\t\t\t\t\t\t:value&#x3D;&quot;cart.skuNum&quot;\n\t\t\t\t\t\t\t@change&#x3D;&quot;handler(&#39;change&#39;, $event.target.value * 1, cart)&quot;\n\t\t\t\t\t\t&#x2F;&gt;\n\t\t\t\t\t\t&lt;a\n\t\t\t\t\t\t\thref&#x3D;&quot;javascript:void(0)&quot;\n\t\t\t\t\t\t\tclass&#x3D;&quot;plus&quot;\n\t\t\t\t\t\t\t@click&#x3D;&quot;handler(&#39;add&#39;, 1, cart)&quot;\n\t\t\t\t\t\t\t&gt;+&lt;&#x2F;a\n\t\t\t\t\t\t&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con6&quot;&gt;\n\t\t\t\t\t\t&lt;span class&#x3D;&quot;sum&quot;&gt;&#123;&#123; cart.skuNum * cart.skuPrice &#125;&#125;&lt;&#x2F;span&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t\t&lt;li class&#x3D;&quot;cart-list-con7&quot;&gt;\n\t\t\t\t\t\t&lt;a class&#x3D;&quot;sindelet&quot; @click&#x3D;&quot;deleteCartById(cart)&quot;&gt;删除&lt;&#x2F;a&gt;\n\t\t\t\t\t\t&lt;br &#x2F;&gt;\n\t\t\t\t\t\t&lt;a href&#x3D;&quot;#none&quot;&gt;移到收藏&lt;&#x2F;a&gt;\n\t\t\t\t\t&lt;&#x2F;li&gt;\n\t\t\t\t&lt;&#x2F;ul&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t&lt;&#x2F;div&gt;\n\t\t&lt;div class&#x3D;&quot;cart-tool&quot;&gt;\n\t\t\t&lt;div class&#x3D;&quot;select-all&quot;&gt;\n\t\t\t\t&lt;input class&#x3D;&quot;chooseAll&quot; type&#x3D;&quot;checkbox&quot; :checked&#x3D;&quot;isAllCheck&quot; &#x2F;&gt;\n\t\t\t\t&lt;span&gt;全选&lt;&#x2F;span&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t\t&lt;div class&#x3D;&quot;option&quot;&gt;\n\t\t\t\t&lt;a href&#x3D;&quot;#none&quot;&gt;删除选中的商品&lt;&#x2F;a&gt;\n\t\t\t\t&lt;a href&#x3D;&quot;#none&quot;&gt;移到我的关注&lt;&#x2F;a&gt;\n\t\t\t\t&lt;a href&#x3D;&quot;#none&quot;&gt;清除下柜商品&lt;&#x2F;a&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t\t&lt;div class&#x3D;&quot;money-box&quot;&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;chosed&quot;&gt;已选择 &lt;span&gt;0&lt;&#x2F;span&gt;件商品&lt;&#x2F;div&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;sumprice&quot;&gt;\n\t\t\t\t\t&lt;em&gt;总价（不含运费） ：&lt;&#x2F;em&gt;\n\t\t\t\t\t&lt;i class&#x3D;&quot;summoney&quot;&gt;&#123;&#123; totalPrice &#125;&#125;&lt;&#x2F;i&gt;\n\t\t\t\t&lt;&#x2F;div&gt;\n\t\t\t\t&lt;div class&#x3D;&quot;sumbtn&quot;&gt;\n\t\t\t\t\t&lt;a class&#x3D;&quot;sum-btn&quot; href&#x3D;&quot;###&quot; target&#x3D;&quot;_blank&quot;&gt;结算&lt;&#x2F;a&gt;\n\t\t\t\t&lt;&#x2F;div&gt;\n\t\t\t&lt;&#x2F;div&gt;\n\t\t&lt;&#x2F;div&gt;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nimport &#123; mapGetters &#125; from &#39;vuex&#39;\n\nexport default &#123;\n\tname: &#39;ShopCart&#39;,\n\tmounted() &#123;\n\t\tthis.getData()\n\t&#125;,\n\tmethods: &#123;\n\t\t&#x2F;&#x2F;获取个人购物车数据\n\t\tgetData() &#123;\n\t\t\tthis.$store.dispatch(&#39;shopCart&#x2F;getCartList&#39;)\n\t\t&#125;,\n\t\t&#x2F;&#x2F;  修改某一个产品的个数\n\t\tasync handler(type, disNum, cart) &#123;\n\t\t\t&#x2F;&#x2F; type是为了区分这三个元素\n\t\t\t&#x2F;&#x2F; disNum形参： + 变化量（1） -变化量（-1） input 最终的个数并不是变化量\n\t\t\t&#x2F;&#x2F; cart代表是点击那个产品，身上有id\n\t\t\t&#x2F;&#x2F; 向服务器发请求，修改数量\n\t\t\tswitch (type) &#123;\n\t\t\t\tcase &#39;add&#39;:\n\t\t\t\t\tdisNum &#x3D; 1\n\t\t\t\t\tbreak\n\t\t\t\tcase &#39;minus&#39;:\n\t\t\t\t\t&#x2F;&#x2F; 判断产品的个数大于1，才能传递给服务器-1，如果出现产品数量&lt;等于1，传递给服务器个数0（原封不动）\n\t\t\t\t\tdisNum &#x3D; cart.skuNum &gt; 1 ? -1 : 0\n\t\t\t\t\tbreak\n\t\t\t\tcase &#39;change&#39;:\n\t\t\t\t\t&#x2F;&#x2F; 用户输入进来的最终量，如果非法的如带有汉字|出现负数，给服务器传0，用户输入正常数字（如有小数取整）然后用户输入的数 - 产品原始个数\n\t\t\t\t\tdisNum &#x3D;\n\t\t\t\t\t\tisNaN(disNum) || disNum &lt; 1 ? 0 : parseInt(disNum) - cart.skuNum\n\t\t\t\t\tbreak\n\t\t\t&#125;\n\t\t\ttry &#123;\n\t\t\t\t&#x2F;&#x2F; 修改成功\n\t\t\t\tawait this.$store.dispatch(&#39;detail&#x2F;addOrUpdateShopCart&#39;, &#123;\n\t\t\t\t\tskuId: cart.skuId,\n\t\t\t\t\tskuNum: disNum,\n\t\t\t\t&#125;)\n\t\t\t\t&#x2F;&#x2F; 再一次获取服务器最新的数据并展示\n\t\t\t\tthis.getData()\n\t\t\t&#125; catch (error) &#123;\n\t\t\t\tthrow new Error(&#39;fail&#39;)\n\t\t\t&#125;\n\t\t&#125;,\n\t&#125;,\n\tcomputed: &#123;\n\t\t...mapGetters(&#39;shopCart&#39;, [&#39;cartList&#39;]),\n\t\t&#x2F;&#x2F; 购物车数据\n\t\tcartInfoList() &#123;\n\t\t\treturn this.cartList.cartInfoList || []\n\t\t&#125;,\n\t\t&#x2F;&#x2F;  计算购买产品的总价\n\t\ttotalPrice() &#123;\n\t\t\tlet sum &#x3D; 0\n\t\t\tthis.cartInfoList.forEach((item) &#x3D;&gt; &#123;\n\t\t\t\tsum +&#x3D; item.skuNum * item.skuPrice\n\t\t\t&#125;)\n\t\t\treturn sum\n\t\t&#125;,\n\t\t&#x2F;&#x2F; 判断底部复选框是否勾选\n\t\tisAllCheck() &#123;\n\t\t\t&#x2F;&#x2F; 遍历数组中的元素，只要全部元素isChecked属性都为真 &#x3D;&#x3D;&#x3D; 真，只要有一个为false就都false\n\t\t\treturn this.cartInfoList.every((item) &#x3D;&gt; item.isChecked &#x3D;&#x3D;&#x3D; 1)\n\t\t&#125;,\n\t&#125;,\n&#125;\n&lt;&#x2F;script&gt;\n\n删除某一产品\n在删除产品之前，修改产品个数这里我们需要给函数节流，因为在用户快速操作的时候容易出现产品个数为0的情况。\nimport throttle from 'lodash/throttle'\n\n//  修改某一个产品的个数\nhandler: throttle(async function (type, disNum, cart) &#123;\n  // type是为了区分这三个元素\n  // disNum形参： + 变化量（1） -变化量（-1） input 最终的个数并不是变化量\n  // cart代表是点击那个产品，身上有id\n  // 向服务器发请求，修改数量\n  switch (type) &#123;\n    case 'add':\n      disNum = 1;\n      break;\n    case 'minus':\n      // 判断产品的个数大于1，才能传递给服务器-1，如果出现产品数量&lt;等于1，传递给服务器个数0（原封不动）\n      disNum = cart.skuNum > 1 ? -1 : 0;\n      break;\n    case 'change':\n      // 用户输入进来的最终量，如果非法的如带有汉字|出现负数，给服务器传0，用户输入正常数字（如有小数取整）然后用户输入的数 - 产品原始个数\n      disNum = (isNaN(disNum) || disNum &lt; 1) ? 0 : parseInt(disNum) - cart.skuNum\n      break;\n  &#125;\n  try &#123;\n    // 修改成功\n    await this.$store.dispatch('detail/addOrUpdateShopCart', &#123;skuId: cart.skuId, skuNum: disNum&#125;)\n    // 再一次获取服务器最新的数据并展示\n    this.getData();\n  &#125; catch (error) &#123;\n    throw new Error('fail')\n  &#125;\n&#125;, 1500),\n\n请求接口地址 /api/cart/deleteCart/&#123;skuId&#125; ，请求方式 DELETE\n// 删除购物车产品的接口\nexport const reqDeleteCartById = (skuId) =>\n\trequests(&#123; url: `/cart/deleteCart/$&#123;skuId&#125;`, method: 'delete' &#125;)\n\nshopCart.vue\n// 删除某个产品\nasync deleteCartById(cart) &#123;\n  try &#123;\n    await this.$store.dispatch('shopCart/deleteCartListBySkuId',cart.skuId)\n    this.getData()\n  &#125; catch (error) &#123;\n    console.log(error)\n  &#125;\n&#125;\n\nshopCart\\index.js\n//  删除购物车产品\n async deleteCartListBySkuId(&#123;commit&#125;, skuId) &#123;\n  let result = await reqDeleteCartById(skuId)\n  if (result.code === 200) &#123;\n   return 'ok'\n  &#125; else &#123;\n   return Promise.reject(new Error('fail'))\n  &#125;\n &#125;\n\n修改产品状态\n接口地址：/api/cart/checkCart/&#123;skuId&#125;/&#123;isChecked&#125;，请求方式GET\nischecked参数，0代表取消，1代表选中\n// 修改产品勾选状态\nupdateChecked(cart, event) &#123;\n  let isChecked = event.target.checked ? '1' : '0'\n  try &#123;\n    this.$store.dispatch('shopCart/updateCheckedById', &#123;skuId: cart.skuId, isChecked&#125;)\n    this.getData()\n  &#125; catch (error) &#123;\n    console.log(error)\n  &#125;\n&#125;\n\n全选状态修改\nshopCart.vue\n//修改全部产品的选中状态\nasync updateAllCartChecked(event) &#123;\n  try &#123;\n    let isChecked = event.target.checked ? \"1\" : \"0\";\n    //派发action\n    await this.$store.dispatch(\"shopCart/updateAllCartIsChecked\", isChecked);\n    this.getData();\n  &#125; catch (error) &#123;\n    console.log(error.message);\n  &#125;\n&#125;,\n\nstore/hopCart/index.js\n//修改全部产品的状态\nupdateAllCartIsChecked(&#123; dispatch, state &#125;, isChecked) &#123;\n //数组\n let promiseAll = [];\n state.cartList[0].cartInfoList.forEach((item) => &#123;\n  let promise = dispatch(\"updateCheckedById\", &#123;\n   skuId: item.skuId,\n   isChecked,\n  &#125;);\n  promiseAll.push(promise);\n &#125;);\n //最终返回结果\n return Promise.all(promiseAll);\n&#125;,\n\n删除选中的全部产品操作\n\n\n\n\n\n\n\n\n\n注意： 没有一次删除多个产品的接口，但是有通过ID删除产品的接口一次删除一个\nvuex 中store仓库里的actions中写的action函数都有一个默认参数 context 小仓库，小仓库包含以下几个功能。\n\ncommit 提交mutation修改 state\ngetters 计算属性\ndispatch 派发 action\nstate 当前仓库数据\n\n//store/shopCart/index.js 删除全部勾选的产品\ndeleteAllCheckedCart(&#123;dispatch, getters&#125;) &#123;\n let PromiseAll = []\n // 获取购物车中全部的产品（一个数组）\n getters.cartList.cartInfoList.forEach(item => &#123;\n  let promise = item.isChecked === 1 ? dispatch('deleteCartListBySkuId', item.skuId) : '';\n  // 将每一次返回的promise添加到数组中\n  PromiseAll.push(promise)\n &#125;)\n // p1,p2,p3...全部成功返回结果就是成功，只要有一个失败，则返回失败的结果\n return PromiseAll.all(PromiseAll)\n&#125;\n\nshopCart.vue\n// 删除全部选中的产品\nasync deleteAllCheckedCart() &#123;\n  try &#123;\n    await this.$store.dispatch('shopCart/deleteAllCheckedCart')\n    this.getData()\n  &#125;catch (error)&#123;\n    console.log(error.message)\n  &#125;\n&#125;\n\n登录与注册引入登录与注册的静态组件\n\n\n\n\n\n\n\n\n\n\n在CSS中也可以使用@代替src，但是需要在前面加~\n注册业务|登录业务的表单验证留到最后处理。\n获取验证码接口 /api/user/passport/sendCode/&#123;phone&#125; ，请求方式get。\n// 获取验证码\nexport const reqGetCode = (phone) =>\n\trequests(&#123; url: `/user/passport/sendCode/$&#123;phone&#125;`, method: 'get' &#125;)\n\n// 注册\nexport const reqUserRegister = (data) =>\n\trequests(&#123;\n\t\turl: '/user/passport/register',\n\t\tdata,\n\t\tmethod: 'post',\n\t&#125;)\n\n登录的接口//登录接口\nexport const reqUserLogin = (data) =>\n\trequests(&#123; url: '/user/passport/login', data, method: 'post' &#125;)\n\n登录的前提是先注册，通过数据库存储用户信息（名字&#x2F;密码）\n登录成功的时候，后台为了区分用户是谁，后台给前端传递了一个token令牌用户的唯一标识，前台需要持久化存储token，后面用户进行操作的时候前台要带着token去找服务器要数据。\n\n\n\n\n\n\n\n\n\n注意：Vuex仓库存储的数据不是持久化的\n当用户注册完成，用户通过用户名+密码登录向服务器发请求（组件派发action:userLogin），登录成功获取到token，存储在仓库中（非持久化），路由跳转到Home首页。\n然后在首页的mounted中再次发送请求this.$store.dispatch(&#39;user/getUserInfo&#39;)去获取用户信息，以及动态展示header组件内容\n目前这种存储在vuex中的数据，一刷新token就没了，也就拿不到用户信息了，所以需要持久化存储token\n存在的问题\n\n每一个组件中都要获取到用户信息，需要在每一个组件的mounted中触发this.$store.dispatch(&#39;user/getUserInfo&#39;)\n用户已经登录了，就不应该在跳转到登录页了\n\n退出登录退出登录需要做的事情\n\n需要发请求，通知服务器退出登录，清除一些数据(token)\n清除项目中的数据 userInfo/token\n\n接口 /api/user/passport/logout，get请求。\n// 退出登录\nexport const reqLogout = () =>\n\trequests(&#123; url: '/user/passport/logout', method: 'get' &#125;)\n\n导航守卫导航表示路由正在发生变化，进行路由跳转，守卫表示跳转时需要经过守卫确认。\n场景：当用户已经登录了，那么就不能在返回登录页面了。\n路由守卫分为：全局守卫、独享守卫、组件内守卫\n\n全局前置：只要路由发生变化，那么全局守卫就能监听到\n独享守卫：判断当前路由是否需要进行权限控制，针对单个路由\n组件内守卫：通过路由规则，进入该组件时被调用\n\nimport store from '@/store'\nrouter.beforeEach(async (to,from,next)=>&#123;\n\t// to:获取到要跳转的路由信息\n\t// from: 获取到要从那个路由跳转过来的信息\n\t// next: next() 放行  next(path)放行\n\tnext();\n\t// 获取仓库中的token，确定用户是登录了\n\tlet token = store.state.user.token\n    let name = store.state.user.userInfo.name;\n\t// 用户登录了\n\tif(token)&#123;\n        // 已经登录了，还想去login页面\n\t\tif(to.path==='/login' &amp;&amp; to.path==='/register')&#123;\n            next('/')\n        &#125;else&#123;\n            // 已经登录了并且有用户信息，访问其他页面\n            if(nama)&#123;\n                next();\n            &#125;else&#123;\n                // 登陆了但是木有用户信息，在跳转之前获取用户信息\n               try&#123;\n                   await store.dispatch('getUserInfo');\n                   next();\n               &#125;catch(error)&#123;\n                   console.log(error.message);\n                   // token失效重新登录\n                   await store.dispatch('userLogout');\n                   next('/login')\n               &#125;\n            &#125;\n\t&#125;else&#123;\n\t\t// 用户未登录\n        next();\n\t&#125;\n&#125;)\n\n结算功能获取用户地址信息 /api/user/userAddress/auth/findUserAddressList，get请求\nexport const reqGetAddressInfo = () =>\n\trequests(&#123; url: '/user/userAddress/auth/findUserAddressList', method: 'get' &#125;)\n\n获取交易页面的用户信息，一定要先登录，用户登录了才可以获取地址信息。\n\n\n\n\n\n\n\n\n\n统一登录的账号 13700000000 111111\n购物车商品清单地址 api/order/auth/trade ，get请求\nexport const getOrderInfo = () =>\n\trequests(&#123; url: '/order/auth/trade', method: 'get' &#125;)\n\n提交订单\n先完成支付静态组件，点击提交订单按钮的时候，还需要向服务器发起一次请求，把支付的一些信息传递给服务器\n// 提交订单的接口\nexport const reqSubmitOrder = (tradeNo, data) =>\n\trequests(&#123;\n\t\turl: `/order/auth/submitOrder?tradeNo=$&#123;tradeNo&#125;`,\n\t\tdata,\n\t\tmethod: 'post',\n\t&#125;)\n\n不使用Vuex的方式发送请求\n// 统一接收api文件夹中全部的函数\nimport * as API from '@/api'\n\nnew Vue(&#123;\n\trender: (h) => h(App),\n\t// 全局事件总线配置\n\tbeforeCreate() &#123;\n\t\tVue.prototype.$bus = this\n\t\tVue.prototype.$API = API\n\t&#125;,\n\t//需要把router进行注册\n\t//可以让全部的组件（非路由|路由组件）都可以获取到$route|$router属性\n\t//$route(路由)：可以获取到路由信息（path、query、params）\n\t//$router:进行编程式导航路由跳转push||replace\n\trouter,\n\t// 注册仓库：组件实例身上会多一个属性$store\n\tstore,\n&#125;).$mount('#app')\n\n// 提交订单的接口\nexport const reqSubmitOrder = (tradeNo, data) =>\n\trequests(&#123;\n\t\turl: `/order/auth/submitOrder?tradeNo=$&#123;tradeNo&#125;`,\n\t\tdata,\n\t\tmethod: 'post',\n\t&#125;)\n\n// 获取支付信息\nexport const reqPayInfo = (orderId) =>\n\trequests(&#123; url: `/payment/weixin/createNative/$&#123;orderId&#125;`, method: 'get' &#125;)\n\n//提交订单\nasync submitOrder () &#123;\n  //交易编码\n  let &#123;tradeNo&#125; = this.orderInfo;\n  //其余的六个参数\n  let data = &#123;\n    consignee: this.userDefaultAddress.consignee, //最终收件人的名字\n    consigneeTel: this.userDefaultAddress.phoneNum, //最终收件人的手机号\n    deliveryAddress: this.userDefaultAddress.fullAddress, //收件人的地址\n    paymentWay: \"ONLINE\", //支付方式\n    orderComment: this.msg, //买家的留言信息\n    orderDetailList: this.orderInfo.detailArrayList, //商品清单\n  &#125;;\n  //需要带参数的：tradeNo\n  let result = await this.$API.reqSubmitOrder(tradeNo, data);\n  //提交订单成功\n  if (result.code === 200) &#123;\n    this.orderId = result.data;\n    //路由跳转 + 路由传递参数\n    await this.$router.push('/pay?orderId=' + this.orderId);\n    //提交的订单失败\n  &#125; else &#123;\n    alert(result.data);\n  &#125;\n&#125;,\n\n不能在生命周期函数的前面加 async|await\n安装 Element UI\nnpm install --save element-ui@^2.15.5\nyarn add element-ui@^2.15.5 --save\n\n安装按需加载组件的插件\nnpm i babel-plugin-component -D\nyarn add babel-plugin-component -D\n\n再修改babel.config.js配置文件，并重启项目\nmodule.exports = &#123;\n\tpresets: ['@vue/cli-plugin-babel/preset'],\n\tplugins: [\n\t\t[\n\t\t\t'component',\n\t\t\t&#123;\n\t\t\t\tlibraryName: 'element-ui',\n\t\t\t\tstyleLibraryName: 'theme-chalk',\n\t\t\t&#125;,\n\t\t],\n\t],\n&#125;\n\nQRCode 生成二维码npm i qrcode --save\nyarn add qrcode --save\n\nES6用法\nasync open () &#123;\n  // 生成二维码 传入字符产返回图片地址\n  let url = await QRCode.toDataURL(this.payInfo.codeUrl);\n  await this.$alert(`&lt;img src=\"$&#123;url&#125;\" alt=\"收款码\"/>`, '使用微信支付', &#123;\n    dangerouslyUseHTMLString: true,\n    center: true,\n    showCancelButton: true,\n    cancelButtonText: '支付失败',\n    confirmButtonText: '已支付成功',\n    //右上角的x\n    showClose: false\n  &#125;)\n  // 后面还需要知道支付成功还是失败\n  //  支付成功，路由跳转，如果支付失败，提示信息\n  //  没有定时器,要开启一个新的定时器\n  if (!this.timer) &#123;\n    this.timer = setInterval(async () => &#123;\n      //  发请求获取用户支付状态\n      let result = await this.$API.reqPayStatus(this.orderId)\n      console.log(result.code)\n      if (result.code === 200) &#123;\n        //清除定时器\n        clearInterval(this.timer)\n        this.timer = null\n        //  保存支付成功的code\n        this.code = result.code\n        //  关闭遮罩层\n        this.$msgbox.close()\n        //  跳转到支付成功路由\n        await this.$router.push('/paysuccess')\n      &#125;\n    &#125;, 1000)\n  &#125;\n&#125;\n\n// 获取支付订单状态\nexport const reqPayStatus = (orderId) =>\n\trequests(&#123; url: `/payment/weixin/queryPayStatus/$&#123;orderId&#125;`, method: 'get' &#125;)\n\n个人中心搭建二级路由// routes.js\n&#123;\n path: '/center',\n component: Center,\n meta: &#123;isShow: true&#125;,\n // 二级路由组件\n children: [\n  &#123;\n   path: 'myorder',\n   component:myOrder\n  &#125;,\n  &#123;\n   path: 'grouporder',\n   component:groupOrder\n  &#125;,\n  &#123;\n      path:'/center',\n      redirect:'/center/myorder'\n   &#125;\n ]\n&#125;,\n\n&lt;dd&gt;\n  &lt;router-link to&#x3D;&quot;&#x2F;center&#x2F;myorder&quot;&gt;我的订单&lt;&#x2F;router-link&gt;\n&lt;&#x2F;dd&gt;\n&lt;dd&gt;\n  &lt;router-link to&#x3D;&quot;&#x2F;center&#x2F;grouporder&quot;&gt;团购订单&lt;&#x2F;router-link&gt;\n&lt;&#x2F;dd&gt;\n\n&lt;!-- 右侧内容 --&gt;\n&lt;!-- 路由组件出口的位置 --&gt;\n&lt;router-view&gt;\n  &lt;my-order&#x2F;&gt;\n  &lt;group-order&#x2F;&gt;\n&lt;&#x2F;router-view&gt;\n\n// 获取个人中心的数据\nexport const reqOrderCenter = (page, limit) =>\n\trequests(&#123; url: `/order/auth/$&#123;page&#125;/$&#123;limit&#125;`, method: 'get' &#125;)\n\n全局守卫\n未登录访问：交易相关（trade）支付相关（pay/paysuccess）用户中心（center）相关跳转到登录页面\n// 全局前置守卫（在路由跳转之前进行判断）\nrouter.beforeEach(async (to, from, next) => &#123;\n\t//  to:可以获取到你跳转的路由信息\n\t// from:可以获取到你从那个路由而来的信息\n\t// next:放行函数 next()放行 next(path)放行到指定路由 next(false)\n\t// next()\n\tlet token = store.state.user.token\n\tlet name = store.state.user.userInfo.name\n\t// 用户是否登录\n\tif (token) &#123;\n\t\tif (to.path === '/login') &#123;\n\t\t\tnext('/home')\n\t\t&#125; else &#123;\n\t\t\tif (name) &#123;\n\t\t\t\tnext()\n\t\t\t&#125; else &#123;\n\t\t\t\t// 没有用户信息 获取用户信息在首页展示\n\t\t\t\ttry &#123;\n\t\t\t\t\tawait store.dispatch('user/getUserInfo')\n\t\t\t\t\tnext()\n\t\t\t\t&#125; catch (error) &#123;\n\t\t\t\t\t// token失效 清除token\n\t\t\t\t\tawait store.dispatch('user/userLogout')\n\t\t\t\t\tnext('/login')\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125; else &#123;\n\t\t// 未登录不能去交易相关的页面 --- 应该去登录页\n\t\tlet toPath = to.path\n\t\tif (\n\t\t\ttoPath.indexOf('/trade') !== -1 ||\n\t\t\ttoPath.indexOf('/pay') !== -1 ||\n\t\t\ttoPath.indexOf('/center') !== -1\n\t\t) &#123;\n\t\t\t// 把未登录的时候要去的地方但是被拦截的地址存放在url中\n\t\t\tnext('/login?redirect=' + toPath)\n\t\t&#125; else &#123;\n\t\t\t// 去的不是交易相关路由 --- 放行\n\t\t\tnext()\n\t\t&#125;\n\t&#125;\n&#125;)\n\n// 登录的回调函数\nasync userLogin () &#123;\n  try &#123;\n    const &#123;phone, password&#125; = this;\n    (phone &amp;&amp; password) &amp;&amp; (await this.$store.dispatch('user/userLogin', &#123;phone, password&#125;));\n    //  登录的路由组件,看路由中是否包含query参数,有:调到query参数指定路由,没有:跳到home\n    let toPath = this.$route.query.redirect || '/home'\n    await this.$router.push(toPath)\n  &#125; catch (error) &#123;\n    console.log(error.message)\n  &#125;\n&#125;\n\n路由独享守卫\n只有从购物车界面才能跳转到交易页面（创建订单）\n唯有从交易页面（创建订单）才能跳转到支付页面\n从支付页面才能跳转到支付成功页面\n\n//  路由独享守卫\nbeforeEnter (to, from, next) &#123;\n // 去交易页面必须是从购物车页面去\n if (from.path === '/shopcart') &#123;\n  next()\n &#125; else &#123;\n  // 其它路由组件直接输url过去，停留在当前页面\n  next(false)\n &#125;\n&#125;\n\n组件内守卫\n\n在渲染该组件对于的路由被 confirm 之前调用\n不能获取组件实力 this，因为当守卫执行前，组件实例还没有被创建\n\n\nbeforeRouteEnter (to, from, next) &#123;\n\n  if (from.path &#x3D;&#x3D;&#x3D; &#39;&#x2F;pay&#39;) &#123;\n    next()\n  &#125; else &#123;\n    next(false)\n  &#125;\n&#125;\n\n图片懒加载https://github.com/hilongjw/vue-lazyload#readme\n安装 vue-lazyload\n$ npm i vue-lazyload@^1.3.3 -S\n$ yarn add vue-lazyload@^1.3.3\n\n注册插件\nimport atm from '@/assets/1.gif'\n//引入插件\nimport VueLazyload from 'vue-lazyload'\n//注册插件\nVue.use(VueLazyload, &#123;\n\t//懒加载默认的图片\n\tloading: atm,\n&#125;)\n\n在组件中使用\n&lt;!-- 路由跳转的时候需要带上参数 params --&gt;\n&lt;router-link :to&#x3D;&quot;&#96;&#x2F;detail&#x2F;$&#123;good.id&#125;&#96;&quot; target&#x3D;&quot;_blank&quot;&gt;\n  &lt;img v-lazy&#x3D;&quot;good.defaultImg&quot; alt&#x3D;&quot;&quot;&#x2F;&gt;\n&lt;&#x2F;router-link&gt;\n\n自定义插件\n// Vue插件一定是对外暴露一个对象\nlet myPlugins = &#123;&#125;\n\nmyPlugins.install = function (Vue, options) &#123;\n\t// Vue.prototype.$bus:任何组件都能用\n\t// Vue。directive() Vue.component 全局指令任何人都能用\n\tVue.directive(options.name, (element, params) => &#123;\n\t\tconsole.log(element, params)\n\t\telement.innerText = params.value.toLocaleUpperCase()\n\t&#125;)\n&#125;\n\nexport default myPlugins\n\n注册自定插件\n// 引入自定义插件\nimport myPlugins from '@/plugins/myPlugins'\n\nVue.use(myPlugins, &#123;\n\tname: 'upper',\n&#125;)\n\n使用\n&lt;h1 v-upper=\"msg\">&lt;/h1>\n\nvee-validate 表单验证应用安装\n# Install with yarn\nyarn add vee-validate@^2.2.15\n\n# Install with npm\nnpm install vee-validate@^2.2.15 --save\n\nvalidate.js\n// vee-validate 表达验证插件\nimport Vue from 'vue'\nimport VeeValidate from 'vee-validate'\n// 中文提示信息\nimport zh_CN from 'vee-validate/dist/locale/zh_CN'\n\nVue.use(VeeValidate, &#123;&#125;)\n\nVeeValidate.Validator.localize('zh_CN', &#123;\n\tmessages: &#123;\n\t\t...zh_CN.messages,\n\t\tis: (field) => `$&#123;field&#125;必须与密码相同`, // 修改内置规则的 message，让确认密码和密码相同\n\t&#125;,\n\tattributes: &#123;\n\t\t// 给校验的 field 属性名映射中文名称\n\t\tphone: '手机号',\n\t\tcode: '验证码',\n\t\tpassword: '密码',\n\t\tconfirmPassword: '确认密码',\n\t\tisCheck: '协议',\n\t&#125;,\n&#125;)\n\n//自定义校验规则\n//定义协议必须打勾同意\nVeeValidate.Validator.extend('agree', &#123;\n\tvalidate: (value) => &#123;\n\t\treturn value\n\t&#125;,\n\tgetMessage: (field) => field + '必须同意',\n&#125;)\n\n使用\n&lt;div class&#x3D;&quot;content&quot;&gt;\n  &lt;label&gt;手机号:&lt;&#x2F;label&gt;\n  &lt;input placeholder&#x3D;&quot;请输入你的手机号&quot; v-model&#x3D;&quot;phone&quot; name&#x3D;&quot;phone&quot; v-validate&#x3D;&quot;&#123; required: true, regex: &#x2F;^1\\d&#123;10&#125;$&#x2F; &#125;&quot;\n         :class&#x3D;&quot;&#123; invalid: errors.has(&#39;phone&#39;) &#125;&quot;&#x2F;&gt;\n  &lt;span class&#x3D;&quot;error-msg&quot;&gt;&#123;&#123; errors.first(&quot;phone&quot;) &#125;&#125;&lt;&#x2F;span&gt;\n&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;content&quot;&gt;\n  &lt;label&gt;验证码:&lt;&#x2F;label&gt;\n  &lt;input placeholder&#x3D;&quot;请输入你的验证码&quot; v-model&#x3D;&quot;code&quot; name&#x3D;&quot;code&quot; v-validate&#x3D;&quot;&#123; required: true, regex: &#x2F;^\\d&#123;6&#125;$&#x2F; &#125;&quot;\n         :class&#x3D;&quot;&#123; invalid: errors.has(&#39;code&#39;) &#125;&quot;&#x2F;&gt;\n  &lt;button style&#x3D;&quot;width: 100px;height: 38px;margin-left: 10px;&quot; @click&#x3D;&quot;getCode&quot;&gt;获取验证码&lt;&#x2F;button&gt;\n  &lt;span class&#x3D;&quot;error-msg&quot;&gt;&#123;&#123; errors.first(&quot;code&quot;) &#125;&#125;&lt;&#x2F;span&gt;\n&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;content&quot;&gt;\n  &lt;label&gt;登录密码:&lt;&#x2F;label&gt;\n  &lt;input placeholder&#x3D;&quot;请输入你的密码&quot; v-model&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;\n         v-validate&#x3D;&quot;&#123; required: true, regex: &#x2F;^[\\dA-Za-z]&#123;8,20&#125;$&#x2F; &#125;&quot;\n         :class&#x3D;&quot;&#123; invalid: errors.has(&#39;password&#39;) &#125;&quot;&#x2F;&gt;\n  &lt;span class&#x3D;&quot;error-msg&quot;&gt;&#123;&#123; errors.first(&quot;password&quot;) &#125;&#125;&lt;&#x2F;span&gt;\n&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;content&quot;&gt;\n  &lt;label&gt;确认密码:&lt;&#x2F;label&gt;\n  &lt;input placeholder&#x3D;&quot;请输入确认密码&quot; v-model&#x3D;&quot;confirmPassword&quot; name&#x3D;&quot;confirmPassword&quot;\n         v-validate&#x3D;&quot;&#123; required: true, is:password &#125;&quot;\n         :class&#x3D;&quot;&#123; invalid: errors.has(&#39;confirmPassword&#39;) &#125;&quot;&#x2F;&gt;\n  &lt;span class&#x3D;&quot;error-msg&quot;&gt;&#123;&#123; errors.first(&quot;confirmPassword&quot;) &#125;&#125;&lt;&#x2F;span&gt;\n&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;controls&quot;&gt;\n  &lt;input type&#x3D;&quot;checkbox&quot; placeholder&#x3D;&quot;请输入确认密码&quot; v-model&#x3D;&quot;agree&quot; name&#x3D;&quot;agree&quot;\n         v-validate&#x3D;&quot;&#123; required: true, agree:true &#125;&quot;\n         :class&#x3D;&quot;&#123; invalid: errors.has(&#39;agree&#39;) &#125;&quot;&#x2F;&gt;\n  &lt;span&gt;同意协议并注册《尚品汇用户协议》&lt;&#x2F;span&gt;\n  &lt;span class&#x3D;&quot;error-msg&quot;&gt;&#123;&#123; errors.first(&quot;agree&quot;) &#125;&#125;&lt;&#x2F;span&gt;\n&lt;&#x2F;div&gt;\n\nasync userRegister () &#123;\n    const success = await this.$validator.validateAll();\n    // 全部表单验证成功在向服务器发请求\n    if (success) &#123;\n        try &#123;\n            const &#123;phone, code, password, confirmPassword&#125; = this;\n            if (phone &amp;&amp; code &amp;&amp; password === confirmPassword) &#123;\n                await this.$store.dispatch('user/userRegister', &#123;phone, code, password&#125;)\n                await this.$router.push('/login')\n            &#125;\n        &#125; catch (error) &#123;\n            console.log(error.message)\n        &#125;\n    &#125;\n&#125;\n\n路由懒加载当打包构建应用的时候，JavaScript 有时候会很大，影响页面加载。\n可以将不同路由对于的组件部分分割成不同的代码块，然后当路由被访问的时候才加载对于组件，这样会更加高效。\n&#123;\n path: '/home',\n component: () => import(\"@/pages/Home\"),\n //路由元信息key不能瞎写：只能叫做meta\n meta: &#123;isShow: true&#125;,\n&#125;,\n&#123;\n //下面这种写法：代表的是params参数可以传递|当然也可以不传递  ?(正则:两次代表出现次数0|1)\n //切记?带上，因为项目当中params参数就可以传递|不传递也可以\n path: '/search/:keyword?',\n component: () => import(\"@/pages/Search\"),\n meta: &#123;isShow: true&#125;,\n // 命名路由\n name: 'search',\n //路由是可以给组件传递props的\n //函数的写法才是重要的\n props: (route) => (&#123;\n  keyword: route.params.keyword,\n  big: route.query.big,\n &#125;),\n&#125;\n\n处理 map 文件打包 npm run build，打包后目录。\n\n项目打包后，代码都是经过压缩加密的，如果运行时报错，输出的错误无法准确得知是哪里的代码报错\n打包后的js文件夹中有map文件，主要用于上线后map可以像未加密的代码一样，准确输出是哪一行那一列有错，但是它的体积太大了，而且线上不能直接改代码所以基本没用，项目在打包的时候就可以去掉加速打包速度。\n\n在 vue.config.js 中配置\nmodule.exports = &#123;\n\tlintOnSave: false,\n\t// 代理跨域\n\tdevServer: &#123;\n\t\tproxy: &#123;\n\t\t\t'/api': &#123;\n\t\t\t\ttarget: 'http://gmall-h5-api.atguigu.cn',\n\t\t\t&#125;,\n\t\t&#125;,\n\t&#125;,\n\tproductionSourceMap: false,\n&#125;\n","slug":"VueShop","date":"2022-06-10T09:13:57.000Z","categories_index":"","tags_index":"Vue","author_index":"R桑"},{"id":"13faca11ddbbdde1b46790dd04adcbcb","title":"小程序开发","content":"只需要在 app.json -&gt; pages 中新增页面存放路径。小程序开发者工具即可帮我们自动创建对于的页面文件\npages 配置项中的第一行默认为小程序的首页。\n\nWXML 模板一、什么是WXML\nWXML（WeiXin Markup Language） 是小程序框架设计的一套标签语言，用来构建小程序页面的结构，其作用类似于网页开发中的HTML。\n二、WXML 和 HTML 的区别\n\n标签名不同\nHTML（div、span、img、a）\nWXML（view、text、image、navigator）\n\n\n属性节点不同\n&lt;a href=&quot;#&quot;&gt;超链接&lt;/a&gt;\n&lt;navigator url=&quot;/pages/home/home&quot;&gt;&lt;/navigator&gt;\n\n\nWXML 提供了类似 Vue 中的模板语法\n数据绑定：&#123;&#123;data&#125;&#125;\n列表渲染：wx:for\n条件渲染：wx:if\n\n\n\nWXSS 样式一、什么是 WXSS\nWXSS（WeiXin Style Sheets）是一套样式语言，用于描述 WXML 的组件样式，类似于网页开发中的 CSS。\n二、WXSS 和 CSS 的区别\n\n新增了 rpx 尺寸单位\nCSS 中需要手动的进行像素单位换算，例如rem\nWXSS 在底层支持新的尺寸单位rpx，在不同大小的屏幕上小程序会自动进行换算\n\n\n提供了全局的样式和局部样式\n项目根目录中的 app.wxss 会作用于所有小程序页面\n局部页面的 .wxss 样式仅对当前页面生效\n\n\nWXSS 仅支持部分 CSS 选择器\n.class 和 #id\nelement\n并集选择器、后代选择器\n::after 和 ::before 等伪类选择器\n\n\n\nJS 逻辑交互一、小程序中的 .js 文件\n一个项目仅仅提供界面展示是不太够的，在小程序中，我们通过 .js 文件来处理用户的操作。例如：响应用户点击、获取用户的位置等等。\n二、小程序中 .js 文件的分类\n\napp.js\n是整个小程序项目的入口文件，通过调用 App() 函数来启动整个小程序\n\n\n页面的 .js 文件\n是页面的入口文件，通过调用 Page() 函数来创建并运行页面\n\n\n普通的 .js 文件\n是普通的功能模块文件，用来封装公共的函数或属性供页面使用，比如 util.js\n\n\n\n","slug":"小程序开发","date":"2022-06-09T15:38:00.000Z","categories_index":"","tags_index":"小程序","author_index":"R桑"},{"id":"c9bf0a586238a4fe73dc5b5acc64d356","title":"我们在浏览器中输入URL并回车后都发生了什么？","content":"\n一、解析 URLURL（Universal Resource Locator）：统一资源定位符。俗称网页地址或者网址。URL用来表示某个资源的地址。（通过俗称就能看出来）\nURL 主要由以下几个部分组成：\n\n传输协议\n服务器\n域名\n端口\n虚拟目录\n文件名\n锚\n参数\n\n现在来讨论URL解析，当在浏览器中输入URL后，浏览器首先对拿到的URL进行识别，抽取出域名字段。\n二、DNS 解析DNS解析（域名解析），DNS实际上是一个域名和IP对应的数据库。\nIP地址往都难以记住，但机器间互相只认IP地址，于是人们发明了域名，让域名与IP地址之间一一对应，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，整个过程是自动进行的。\n可以在浏览器中输入IP地址浏览网站，也可以输入域名查询网站，虽然得出的内容是一样的，但是调用的过程不一样，输入IP地址是直接从主机上调用内容，输入域名是通过域名解析服务器指向对应的主机的IP地址，再从主机调用网站的内容。\n在进行DNS解析时，会经历以下步骤：\n\n查询浏览器缓存（浏览器会缓存之前拿到的DNS 2-30 分钟时间），如果没有找到，那么-&gt;\n\n检查系统缓存，检查hosts文件，这个文件保存了一些以前访问过的网站的域名和IP的数据。它就像是一个本地的数据库。如果找到就可以直接获取目标主机的IP地址了。没有找到的话，那么-&gt;\n\n检查路由器缓存，路由器有自己的DNS缓存，可能就包括了这在查询的内容；如果没有，那么-&gt;\n\n查询ISP DNS 缓存：ISP服务商DNS缓存（本地服务器缓存）那里可能有相关的内容，如果还不行的话，那么-&gt;\n\n递归查询：从根域名服务器到顶级域名服务器再到极限域名服务器依次搜索对应目标域名的IP。\n\n\n通过以上的查找，就可以获取到域名对应的IP了。接下来就是向该IP地址定位的HTTP服务器发起TCP连接。\n三、浏览器与网站建立 TCP 连接（三次握手）第一次握手：客户端向服务器端发送请求（SYN&#x3D;1） 等待服务器确认；\n第二次握手：服务器收到请求并确认，回复一个指令（SYN&#x3D;1，ACK&#x3D;1）；\n第三次握手：客户端收到服务器的回复指令并返回确认（ACK&#x3D;1）。\n通过三次握手，建立了客户端和服务器之间的连接，现在可以请求和传输数据了。\n四、请求和传输数据比如要通过get请求访 http://www.dydh.org/，通过抓包可以看到：\n\n请求网址（url）：http://www.dydh.org/\n请求方法：GET\n远程地址：IP\n状态码：200 OK\nHTTP 版本： HTTP/1.1\n请求头： …\n响应头： …\n\n响应头中有一个：Set-Cookie:&quot;PHPSESSID=c882giens9f7d3oglcakhrl994; path=/&quot;\\****，说明浏览器中没有关于这个网站的cookie信息。\n当我们下一次访问相同的网站时：\n可以看到，请求头中包含了这个cookie信息，\nCookie:&quot;PHPSESSID=c882giens9f7d3oglcakhrl994; CNZZDATA1253283365=1870471808-1473694656-%7C1473694656&quot;\ncookie可以用来保存一些有用的信息：Cookies如果是首次访问，会提示服务器建立用户缓存信息，如果不是，可以利用Cookies对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。\n通过这种GET请求，和服务器的响应。可以将服务器上的目标文件传输到浏览器进行渲染。\n关闭TCP连接\n第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；\n第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我”同意”你的关闭请求；\n第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；\n第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了\n\n五、浏览器渲染页面客户端拿到服务器端传输来的文件，找到HTML和MIME文件，通过MIME文件，浏览器知道要用页面渲染引擎来处理HTML文件。\n\n浏览器会解析html源码，然后创建一个 DOM树。\n\n在DOM树中，每一个HTML标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。\n\n\n浏览器解析CSS代码，计算出最终的样式数据，形成css对象模型CSSOM。\n\n首先会忽略非法的CSS代码，之后按照浏览器默认设置——用户设置——外链样式——内联样式——HTML中的style样式顺序进行渲染。\n\n\n利用DOM和CSSOM构建一个渲染树（rendering tree）。\n\n渲染树和DOM树有点像，但是是有区别的。\nDOM树完全和html标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如head、display:none的元素等。\n而且一大段文本中的每一个行在渲染树中都是独立的一个节点，渲染树中的每一个节点都存储有对应的css属性。\n\n\n浏览器就根据渲染树直接把页面绘制到屏幕上\n\n\n","slug":"我们在浏览器中输入URL并回车后都发生了什么？","date":"2022-06-01T09:27:47.000Z","categories_index":"","tags_index":"HTTP","author_index":"R桑"},{"id":"e9014eb277f72a7198d4ff54563938a4","title":"Fetch的使用-关注分离思想","content":"一1.拆分组件、实现静态组件，注意：className、style的写法 2.动态初始化列表，如何确定将数据放在那个组件的state中？—— 某个组件使用：放在自身的state中—— 某些组件使用：放在他们共同的父组件 state 中(官方称为：状态提升) 3.关于父子之间的通信： 1.【父组件】给【子组件】传递数据：通过 props 传递 2.【子组件】给【父组件】传递数据：通过 props 传递，要求父组件提前给子组件传递一个函数 4.注意defaultChecked 和 checked 的区别，类似的还有：defaultValue 和 value 5.状态在哪里，操作状态的方法就在哪里。\n二\n设计状态时要考虑全面，例如带有网络请求的组件，要考虑请求失败怎么办。\nES6知识点：解构赋值+重命名\nlet obj = &#123;a:&#123;b:1&#125;&#125;\nconst &#123;a&#125; = obj; &#x2F;&#x2F;传统解构赋值\nconst &#123;a:&#123;b&#125;&#125; = obj; &#x2F;&#x2F;连续解构赋值\nconst &#123;a:&#123;b:value&#125;&#125; = obj; &#x2F;&#x2F;连续解构赋值+重命名\n\n\n消息订阅与发布机制 1.先订阅，再发布(理解为隔空对话) 2.使用与任何组件间的通信 3.要在组件的componentWillUnmount中取消订阅\nfetch发送请求(关注分离的设计思想)\n\nsearch = async () => &#123;\n\t//获取用户的输入(连续解构赋值+重命名)\n\tconst &#123;\n\t\tkeyWordElement: &#123; value: keyWord &#125;,\n\t&#125; = this\n\t// 发送请求前通知List更新状态\n\t// this.props.updateAppState(&#123; isFirst: false, isLoading: true &#125;)\n\tPubSub.publish('yminami', &#123; isFirst: false, isLoading: true &#125;)\n\t// 发送网络请求(使用axios)\n\t// axios.get(`/api1/search/users2?q=$&#123;keyWord&#125;`).then(\n\t//   response => &#123;\n\t//     // 请求成功后通知App更新状态\n\t//     PubSub.publish('yminami', &#123; isLoading: false, users: response.data.items &#125;)\n\t//   &#125;,\n\t//   error => &#123;\n\t//     //请求失败后通知App更新状态\n\t//     PubSub.publish('yminami', &#123; isLoading: false, err: error.message &#125;)\n\n\t//   &#125;\n\t// )\n\t//   fetch(`/api1/search/users2?q=$&#123;keyWord&#125;`).then(\n\t//     response => &#123;\n\t//       console.log('联系服务器成功了');\n\t//       return response.json()\n\t//     &#125;,\n\t//     // error => &#123;\n\t//     //   console.log('联系服务器失败了', error);\n\t//     //   return new Promise(() => &#123; &#125;)\n\t//     // &#125;\n\t//   ).then(\n\t//     response => &#123; console.log('获取数据成功', response); &#125;,\n\t//     // error => &#123; console.log('获取数据失败了', error); &#125;\n\t//   ).catch(\n\t//     (error) => &#123; console.log('请求出错', error); &#125;\n\t//   )\n\n\ttry &#123;\n\t\tconst response = await fetch(`/api1/search/users2?q=$&#123;keyWord&#125;`)\n\t\tconst data = await response.json()\n\t\tPubSub.publish('yminami', &#123; isLoading: false, users: data.items &#125;)\n\t\tconsole.log(data)\n\t&#125; catch (error) &#123;\n\t\tPubSub.publish('yminami', &#123; isLoading: false, err: error.message &#125;)\n\t\tconsole.log('请求错误', error)\n\t&#125;\n&#125;\n","slug":"Fetch的使用-关注分离思想","date":"2022-05-30T13:42:00.000Z","categories_index":"","tags_index":"HTTP","author_index":"R桑"},{"id":"46cbb2bb63f1ff3e16d9556aa8441940","title":"发布轮子到npm","content":"发布轮子到 npm要做两件事部署官网\n\n让官网上线，有好的文档才更容易让人使用\n\n发布 sakura-ui\n\n让其他开发者可以使用 npm install sakura-ui 安装源码\n\n发布你的官网// 其实就是把 dist 目录上传到网上\nyarn build 时要注意设置 build path\n\n发布官网的步骤\n如果有 dist 目录，则删除 dist 目录\n在 .gitignore 添加一行 &#x2F;dist&#x2F; 然后提交代码\n运行 yarn build 创建出最新的 dist\n运行 hs dist 在本地测试网站是否成功运行\n部署到 GitHub\n\n运行命令\ncd dist\ngit init\ngit add .\ngit commit -m \"first commit\"\ngit branch -M master\ngit remote add origin 以git@开头的仓库地址\ngit push -f -u origin master\ncd ..\n\n开启 sakura-ui 的 Pages 功能\n部署到码云\n设置 build path\n一键部署根目录新建 deploy.sh 文件\nrm -rf dist &amp;&amp;\nyarn build &amp;&amp;\ncd dist &amp;&amp;\ngit init &amp;&amp;\ngit add . &amp;&amp;\ngit commit -m &quot;update&quot; &amp;&amp;\ngit branch -M master &amp;&amp;\ngit remote add origin git@github.com:XXXXXXX&#x2F;XXXXXXX-UI.git &amp;&amp;\ngit push -f -u origin master &amp;&amp;\ncd -\necho https:&#x2F;&#x2F;XXXXXXX.github.io&#x2F;XXXXXXX-UI&#x2F;index.html  &#x2F;&#x2F;预览链接\n\n然后运行 sh deploy.sh\n打包库文件vite 暂不支持，需要自行配置 rollup\n第一步：创建 lib&#x2F;index.ts将所有需要导出的东西导出\nexport &#123; default as Switch &#125; from './Switch.vue'\nexport &#123; default as Button &#125; from './Button.vue'\nexport &#123; default as Tabs &#125; from './Tabs.vue'\nexport &#123; default as Tab &#125; from './Tab.vue'\nexport &#123; default as Dialog &#125; from './Dialog.vue'\nexport &#123; openDialog as openDialog &#125; from './openDialog'\n\n第二步：rollup.config.js告诉 rollup 怎么打包\n// 请先安装 rollup-plugin-esbuild rollup-plugin-vue rollup-plugin-scss sass rollup-plugin-terser\n// 为了保证版本一致，请复制我的 package.json 到你的项目，并把 name 改成你的库名\nimport esbuild from 'rollup-plugin-esbuild'\nimport vue from 'rollup-plugin-vue'\nimport scss from 'rollup-plugin-scss'\nimport dartSass from 'sass'\nimport &#123; terser &#125; from 'rollup-plugin-terser'\n\nexport default &#123;\n\tinput: 'src/lib/index.ts',\n\toutput: [\n\t\t&#123;\n\t\t\tglobals: &#123;\n\t\t\t\tvue: 'Vue',\n\t\t\t&#125;,\n\t\t\tname: 'Sakura',\n\t\t\tfile: 'dist/lib/sakura.js',\n\t\t\tformat: 'umd',\n\t\t\tplugins: [terser()],\n\t\t&#125;,\n\t\t&#123;\n\t\t\tname: 'Sakura',\n\t\t\tfile: 'dist/lib/sakura.esm.js',\n\t\t\tformat: 'es',\n\t\t\tplugins: [terser()],\n\t\t&#125;,\n\t],\n\tplugins: [\n\t\tscss(&#123; include: /\\.scss$/, sass: dartSass &#125;),\n\t\tesbuild(&#123;\n\t\t\tinclude: /\\.[jt]s$/,\n\t\t\tminify: process.env.NODE_ENV === 'production',\n\t\t\ttarget: 'es2015',\n\t\t&#125;),\n\t\tvue(&#123;\n\t\t\tinclude: /\\.vue$/,\n\t\t&#125;),\n\t],\n&#125;\n\n第三步：运行 rollup -c\n请先全局安装 rollup（或者局部安装）\nyarn global add rollup\nnpm i -g rollup\n\n发布 dist&#x2F;lib&#x2F; 目录其实就是上传到 npm 的服务器\n第一步：添加 files 和 main打开 package.json\n&#123;\n  \"name\": \"sakura-ui-dev\",\n  \"version\": \"0.0.1\",\n  \"files\": [\n    \"dist/lib/*\"\n  ],\n  \"main\": \"dist/lib/sakura.js\",\n  \"module\": \"dist/lib/sakura.esm.js\",\n  \"scripts\": &#123;\n    \"dev\": \"vite\",\n    \"build\": \"vite build\"\n  &#125;,\n  \"resolutions\": &#123;\n    \"node-sass\": \"npm:sass@1.26.11\"\n  &#125;,\n  \"dependencies\": &#123;\n    \"github-markdown-css\": \"4.0.0\",\n    \"marked\": \"1.1.1\",\n    \"prismjs\": \"1.21.0\",\n    \"vue\": \"3.0.0\",\n    \"vue-router\": \"4.0.0-beta.3\"\n  &#125;,\n  \"devDependencies\": &#123;\n    \"@vue/compiler-sfc\": \"3.0.0\",\n    \"rollup-plugin-esbuild\": \"2.5.0\",\n    \"rollup-plugin-scss\": \"2.6.0\",\n    \"rollup-plugin-terser\": \"7.0.2\",\n    \"rollup-plugin-vue\": \"6.0.0-beta.10\",\n    \"sass\": \"1.32.11\",\n    \"vite\": \"1.0.0-rc.1\"\n  &#125;\n&#125;\n\n第二步：npm login &amp; npm publish\n\n请确保你没有在使用淘宝源，请使用官方源\nnpm config get registry\nnpm config set registry\nhttps://registry.npmjs.org/\n\n一些可能出现的问题name\n\npackage 的 name 必须是小写字母，可用 - 或 _ 连接\npackage 的 name 不能跟 npm 上现有的 name 重名\n\nversion\n\n每次 publish 的版本不能与上一次的相同\n所以从第二次开始，必须先改 version 再 publish\n\n注册 npmjs.com 账号\n\n用网页注册，然后在命令行使用 npm login 登录\n登录之后才能 npm publish\n使用 npm logout 可以退出登录\n\n如何升级 Vue 2 到 Vue 3使用 Vue 官方提供的工具和教程\n支持低版本的 node\nnode 10、12 不支持 import 和 ?. 语法\n要么我们手动使用旧语法 require 和 if else\n要么我们利用 esbuild 自动把 TS 转译成旧语法\n\nbuild 之后不加载 md 文件这是因为 rollup 不支持 import() 时拼字符串要么让它支持（不靠谱）要么不要拼字符串\n","slug":"发布轮子到npm","date":"2022-05-29T06:20:31.000Z","categories_index":"","tags_index":"npm","author_index":"R桑"},{"id":"7d81c7d2e66457a6322f3eb94b638116","title":"React——Diffing算法初识","content":"首先思考两个问题\nreact&#x2F;vue 中的 key 有什么作用？（key 的内部原理是什么？）\n为什么遍历列表时，key 最好不要用 index?\n\n1.虚拟 DOM 中 key 的作用：\n\n简单的说: key 是虚拟 DOM 对象的标识, 在更新显示时 key 起着极其重要的作用。\n\n详细的说: 当状态中的数据发生变化时，react 会根据【新数据】生成【新的虚拟 DOM】, 随后 React 进行【新虚拟 DOM】与【旧虚拟 DOM】的 diff 比较，比较规则如下：\n\n​ a.旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key：\n\n​ (1).若虚拟 DOM 中内容没变, 直接使用之前的真实 DOM\n\n​ (2).若虚拟 DOM 中内容变了, 则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM\n\n​ b. 旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key\n\n​ 根据数据创建新的真实 DOM，随后渲染到到页面\n\n\n\n\n2.用 index 作为 key 可能会引发的问题：\n\n若对数据进行：逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实 DOM 更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。\n如果结构中还包含输入类的 DOM：会产生错误 DOM 更新 &#x3D;&#x3D;&gt; 界面有问题。\n注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用 index 作为 key 是没有问题的。\n\n开发中如何选择 key?:\n\n最好使用每条数据的唯一标识作为 key, 比如 id、手机号、身份证号、学号等唯一值。\n如果确定只是简单的展示数据，用 index 也是可以的。\n\n使用 index 索引值作为 key初始数据：\n&#123;id:1,name:'小张',age:18&#125;, &#123;id:2,name:'小李',age:19&#125;,\n\n初始的虚拟 DOM：\n&lt;li key=\"0\">小张---18&lt;input type=\"text\" />&lt;/li>\n&lt;li key=\"1\">小李---19&lt;input type=\"text\" />&lt;/li>\n\n更新后的数据：\n&#123;id:3,name:'小王',age:20&#125;, &#123;id:1,name:'小张',age:18&#125;, &#123;id:2,name:'小李',age:19&#125;,\n\n更新数据后的虚拟 DOM：\n&lt;li key=\"0\">小王---20&lt;input type=\"text\" />&lt;/li>\n&lt;li key=\"1\">小张---18&lt;input type=\"text\" />&lt;/li>\n&lt;li key=\"2\">小李---19&lt;input type=\"text\" />&lt;/li>\n\n使用 id 唯一标识作为 key初始数据：\n&#123;id:1,name:'小张',age:18&#125;, &#123;id:2,name:'小李',age:19&#125;,\n\n初始的虚拟 DOM：\n&lt;li key=\"1\">小张---18&lt;input type=\"text\" />&lt;/li>\n&lt;li key=\"2\">小李---19&lt;input type=\"text\" />&lt;/li>\n\n更新后的数据：\n&#123;id:3,name:&#39;小王&#39;,age:20&#125;,\n&#123;id:1,name:&#39;小张&#39;,age:18&#125;,\n&#123;id:2,name:&#39;小李&#39;,age:19&#125;,\n\n更新数据后的虚拟 DOM：\n&lt;li key=\"3\">小王---20&lt;input type=\"text\" />&lt;/li>\n&lt;li key=\"1\">小张---18&lt;input type=\"text\" />&lt;/li>\n&lt;li key=\"2\">小李---19&lt;input type=\"text\" />&lt;/li>\n\n&lt;!DOCTYPE html>\n\n&lt;html lang=\"en\">\n\t&lt;head>\n\t\t&lt;meta charset=\"UTF-8\" />\n\t\t&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n\t\t&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n\t\t&lt;title>key的作用&lt;/title>\n\t&lt;/head>\n\n\t&lt;body>\n\t\t&lt;!-- 准备好一个“容器” -->\n\t\t&lt;div id=\"test\">&lt;/div>\n\n\t\t&lt;!-- 引入react核心库 必须第一个引入-->\n\n\t\t&lt;script\n\t\t\ttype=\"text/javascript\"\n\t\t\tsrc=\"../js/17.0.1/react.development.js\"\n\t\t>&lt;/script>\n\n\t\t&lt;!-- 引入react-dom，用于支持react操作dom -->\n\n\t\t&lt;script\n\t\t\ttype=\"text/javascript\"\n\t\t\tsrc=\"../js/17.0.1/react-dom.development.js\"\n\t\t>&lt;/script>\n\n\t\t&lt;!-- 引入babel，用于将jsx转为js -->\n\n\t\t&lt;script type=\"text/javascript\" src=\"../js/17.0.1/babel.min.js\">&lt;/script>\n\n\t\t&lt;script type=\"text/babel\">\n\t\t\t/*此处一定要写babel*/\n\n\t\t\tclass Person extends React.Component &#123;\n\t\t\t\tstate = &#123;\n\t\t\t\t\tpersons: [\n\t\t\t\t\t\t&#123; id: 1, name: '小张', age: 18 &#125;,\n\t\t\t\t\t\t&#123; id: 2, name: '小龙', age: 19 &#125;,\n\t\t\t\t\t],\n\t\t\t\t&#125;\n\n\t\t\t\tadd = () => &#123;\n\t\t\t\t\tconst &#123; persons &#125; = this.state\n\t\t\t\t\tconst p = &#123; id: persons.length + 1, name: '小王', age: 20 &#125;\n\t\t\t\t\tthis.setState(&#123; persons: [p, ...persons] &#125;)\n\t\t\t\t&#125;\n\n\t\t\t\trender() &#123;\n\t\t\t\t\treturn (\n\t\t\t\t\t\t&lt;div>\n\t\t\t\t\t\t\t&lt;h2>展示人员信息&lt;/h2>\n\t\t\t\t\t\t\t&lt;button onClick=&#123;this.add&#125;>添加一个小王&lt;/button>\n\t\t\t\t\t\t\t&lt;h3>使用index索引值作为key&lt;/h3>\n\t\t\t\t\t\t\t&lt;ul>\n\t\t\t\t\t\t\t\t&#123;this.state.persons.map((personObj, index) => &#123;\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t&lt;li key=&#123;index&#125;>\n\t\t\t\t\t\t\t\t\t\t\t&#123;personObj.name&#125;---&#123;personObj.age&#125; &lt;input type=\"text\" />\n\t\t\t\t\t\t\t\t\t\t&lt;/li>\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t&#125;)&#125;\n\t\t\t\t\t\t\t&lt;/ul>\n\n\t\t\t\t\t\t\t&lt;hr />\n\t\t\t\t\t\t\t&lt;hr />\n\t\t\t\t\t\t\t&lt;h2>展示人员信息&lt;/h2>\n\t\t\t\t\t\t\t&lt;h3>使用id(数据唯一标识)作为key&lt;/h3>\n\t\t\t\t\t\t\t&lt;ul>\n\t\t\t\t\t\t\t\t&#123;this.state.persons.map((personObj) => &#123;\n\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t&lt;li key=&#123;personObj.id&#125;>\n\t\t\t\t\t\t\t\t\t\t\t&#123;personObj.name&#125;---&#123;personObj.age&#125; &lt;input type=\"text\" />\n\t\t\t\t\t\t\t\t\t\t&lt;/li>\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t&#125;)&#125;\n\t\t\t\t\t\t\t&lt;/ul>\n\t\t\t\t\t\t&lt;/div>\n\t\t\t\t\t)\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tReactDOM.render(&lt;Person />, document.getElementById('test'))\n\t\t&lt;/script>\n\t&lt;/body>\n&lt;/html>\n","slug":"React——Diffing算法初识","date":"2022-05-29T06:17:36.000Z","categories_index":"","tags_index":"React","author_index":"R桑"},{"id":"3a8f389ca4eb42bdb599eaaf75910c8e","title":"根据PromiseA+实现一个自己的promise","content":"步骤一：实现成功和失败的回调方法首先需要创建一个构造函数 promise，创建一个 promise类，在使用时传入了一个执行器 executor，executor会传入两个参数：成功(resolve) 和失败(reject)。\n只要成功，就不会失败，只要失败就不会成功。所以，默认情况下，在调用成功时，就返回成功态，调用失败时，返回失败态。代码如下：\nclass Promise &#123;\n constructor(executor)&#123;\n  //默认状态是等待状态\n  this.status = 'pending';\n  this.value = undefined;\n  this.reason = undefined;\n  //存放成功的回调\n  this.onResolvedCallbacks = [];\n  //存放失败的回调\n  this.onRejectedCallbacks = [];\n  let resolve = (data) => &#123; // this指的是实例\n   if(this.status === 'pending')&#123;\n    this.value = data;\n    this.status = 'resolved';\n    this.onResolvedCallbacks.forEach(fn => fn());\n   &#125;\n  &#125;\n  let reject = (reason) => &#123;\n   if(this.status === 'pending')&#123;\n    this.reason = reason;\n    this.status = 'rejected''\n    this.onRejectedCallbacks.forEach(fn => fn())\n   &#125;\n  &#125;\n  try&#123; //执行时可能发生异常\n   executor(resolve,reject);\n  &#125;catch (e)&#123;\n   reject(e); //promise 失败了\n  &#125;\n &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\npromise A+ 规定，在有异常错误时，则执行失败函数\n步骤二：then 方法链式调用then 方法是 promise 的最基本方法，返回的是两个回调，一个成功的回调，一个失败的回调，代码如下：\nthen(onFulFilled,onRejected)&#123;\n if(this.status === 'resolveed')&#123; // 成功状态的回调\n  onFulFilled(this.value)\n &#125;\n if(this.status === 'rejected')&#123; // 失败状态的回调\n  onRejected(this.reason)\n &#125;\n&#125;\n\nlet p = new Promise(function () &#123;\n\tresolve('我是成功')\n&#125;)\np.then(\n\t(data) => &#123;\n\t\tconsole.log(data)\n\t&#125;,\n\t(err) => &#123;&#125;\n)\np.then(\n\t(data) => &#123;\n\t\tconsole.log(data)\n\t&#125;,\n\t(err) => &#123;&#125;\n)\np.then(\n\t(data) => &#123;\n\t\tconsole.log(data)\n\t&#125;,\n\t(err) => &#123;&#125;\n)\n\n\n\n\n\n\n\n\n\n\n我是成功我是成功我是成功\n为了实现这样的效果，则上一次的代码要重新写，我们可以把每次调用 resolve 的结果存入一个数组中，每次调用reject 的结果存入一个数组。这就是为什么在上面定义两个数组，且分别在 resolve() 和 reject() 遍历这两个数组的原因。因此，在调用 resolve() 或者 reject() 之前，我们在 pending 状态时，会把多次 then 中的结果存入数组中，上面代码改写为：\nthen(onFulFilled,onRejected)&#123;\n if(this.status === 'resolved')&#123;\n  onFulFilled(this.value;\n &#125;\n if(this.status === 'rejected')&#123;\n  onRejected(this.reason);\n &#125;\n // 当既没有完成 也没有失败\n if(this.status === 'pending')&#123;\n  // 存放成功的回调\n  this.onResolvedCallbacks.push(() => &#123;\n   onFulFilled(this.value)\n  &#125;);\n  // 存放失败的回调\n  this.onRejectedCallback.push(() => &#123;\n   onRejected(this.reason);\n  &#125;)\n &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\nPromise A+ 规范中规定 then 可以链式调用\n在promise 中，要实现链式调用的结果是返回一个新的promise，第一次then中返回的结果，无论成功或失败，都将返回到下一次then中的成功态中，但第一次then中如果抛出异常错误，则将返回到下一次then中的失败态中。\n链式调用成功时\n链式调用成功会返回值，有多种情况，根据举的例子，大致列出可能会发生的结果。因此将链式调用返回的值单独写入一个方法。方法中传入四个参数，分别是 p2， x ，resolve ， reject ， p2 指的是上一次返回的 promise，x 表示运行 promise 返回的结果，resolve 和 reject 是 &#96;&#96; 的方法。\nfunction resolvePromise(p2,x,resolve,reject)&#123; ... &#125;\n\n返回结果不能是自己\nvar p = new Promise((resolve, reject) => &#123;\n\treturn p // 返回结果不能是自己\n&#125;)\n\n当返回结果是自己时，永远也不会成功或失败，因此当返回自己时，应抛出一个错误。\nfunction resolvePromise(p2, x, resolve, reject) &#123;\n\tif (p2 === x) &#123;\n\t\treturn reject(new TypeError('自己引用了自己'))\n\t&#125;\n&#125;\n\n返回结果可能是 promise\nfunction resolvePromise(promise2, x, resolve, reject) &#123;\n\t// 判断 x 是不是 promise\n\t// 规范中规定：我们允许别人乱写，这个代码可以实现我们的promise和别人的promise进行交互\n\tif (promsie2 === x) &#123;\n\t\t// 不能等待自己完成\n\t\treturn reject(new TypeError('循环引用'))\n\t&#125;\n\t// x 是除了 null 以外的对象或者函数\n\tif (x != null &amp;&amp; (typeof x === 'object' || typeof x === 'function')) &#123;\n\t\tlet called //防止成功后调用失败\n\t\ttry &#123;\n\t\t\t// 防止取then时出现异常，object.definedProperty\n\t\t\tlet then = x.then // 取 x 的 then方法\n\t\t\tif (typeof then === 'function') &#123;\n\t\t\t\t//如果then是函数就认为它是promise\n\t\t\t\t//call第一个参数是this，后面的是成功的回调和失败的的回调\n\t\t\t\tthen.call(\n\t\t\t\t\tx,\n\t\t\t\t\t(y) => &#123;\n\t\t\t\t\t\t// 如果y是promise就继续递归\n\t\t\t\t\t\tif (called) return\n\t\t\t\t\t\tcalled = true\n\t\t\t\t\t\tresolvePromise(promise2, y, resolve, reject)\n\t\t\t\t\t&#125;,\n\t\t\t\t\t(r) => &#123;\n\t\t\t\t\t\t// 只要失败了就失败了\n\t\t\t\t\t\tif (called) return\n\t\t\t\t\t\tcalled = true\n\t\t\t\t\t\treject(r)\n\t\t\t\t\t&#125;\n\t\t\t\t)\n\t\t\t&#125; else &#123;\n\t\t\t\t// then 是一个普通对象，就直接成功即可\n\t\t\t\tresolve(x)\n\t\t\t&#125;\n\t\t&#125; catch (e) &#123;\n\t\t\tif (called) return\n\t\t\tcalled = true\n\t\t\treject(e)\n\t\t&#125;\n\t&#125; else &#123;\n\t\t// x = 123 x 就是一个普通值 作为下一个then成功的参数\n\t\tresolve(x)\n\t&#125;\n&#125;\n\n\n返回结果可能是一个普通值，则直接 resolve(x);\nPromise 一次只能调用成功或失败\n\n也就是当调用成功就不能再调用失败了，如果两个都调用的时候，那个先调用就执行哪一个。根据 Promise A+ 的规范原理，promise 在自己的框架中，封装了一系列的内置方法。\n\n捕获错误的方法 catch()\n解析全部方法 all()\n谁先执行就以谁为准的方法 race()\n生成一个成功的 promise resolve()\n生成一个失败的 promise reject()\n\n最后是完整代码：\nfunction resolvePromise(promise2,x,resolve,reject)&#123;\n    //判断x是不是promise\n    //规范中规定：我们允许别人乱写，这个代码可以实现我们的promise和别人的promise 进行交互\n    if(promise2 === x)&#123;//不能自己等待自己完成\n        return reject(new TypeError('循环引用'));\n    &#125;;\n    // x是除了null以外的对象或者函数\n    if(x !=null &amp;&amp; (typeof x === 'object' || typeof x === 'function'))&#123;\n        let called;//防止成功后调用失败\n        try&#123;//防止取then是出现异常  object.defineProperty\n            let then = x.then;//取x的then方法 &#123;then:&#123;&#125;&#125;\n            if(typeof then === 'function')&#123;//如果then是函数就认为他是promise\n                //call第一个参数是this，后面的是成功的回调和失败的回调\n                then.call(x,y => &#123;//如果Y是promise就继续递归promise\n                    if(called) return;\n                    called = true;\n                    resolvePromise(promise2,y,resolve,reject)\n                &#125;,r => &#123; //只要失败了就失败了\n                    if(called) return;\n                    called = true;\n                    reject(r);\n                &#125;);\n            &#125;else&#123;//then是一个普通对象，就直接成功即可\n                resolve(x);\n            &#125;\n        &#125;catch (e)&#123;\n            if(called) return;\n            called = true;\n            reject(e)\n        &#125;\n    &#125;else&#123;//x = 123 x就是一个普通值 作为下个then成功的参数\n        resolve(x)\n    &#125;\n\n&#125;\n\nclass Promise &#123;\n    constructor (executor)&#123;\n        //默认状态是等待状态\n        this.status = 'panding';\n        this.value = undefined;\n        this.reason = undefined;\n        //存放成功的回调\n        this.onResolvedCallbacks = [];\n        //存放失败的回调\n        this.onRejectedCallbacks = [];\n        let resolve = (data) => &#123;//this指的是实例\n            if(this.status === 'pending')&#123;\n                this.value = data;\n                this.status = \"resolved\";\n                this.onResolvedCallbacks.forEach(fn => fn());\n            &#125;\n\n        &#125;\n        let reject = (reason) => &#123;\n            if(this.status === 'pending')&#123;\n                this.reason = reason;\n                this.status = 'rejected';\n                this.onRejectedCallbacks.forEach(fn => fn());\n            &#125;\n        &#125;\n        try&#123;//执行时可能会发生异常\n            executor(resolve,reject);\n        &#125;catch (e)&#123;\n            reject(e);//promise失败了\n        &#125;\n\n    &#125;\n    then(onFuiFilled,onRejected)&#123;\n        //防止值得穿透\n        onFuiFilled = typeof onFuiFilled === 'function' ? onFuiFilled : y => y;\n        onRejected = typeof onRejected === 'function' ? onRejected :err => &#123;throw err;&#125;\n        let promise2;//作为下一次then方法的promise\n       if(this.status === 'resolved')&#123;\n           promise2 = new Promise((resolve,reject) => &#123;\n               setTimeout(() => &#123;\n                  try&#123;\n                        //成功的逻辑 失败的逻辑\n                        let x = onFuiFilled(this.value);\n                        //看x是不是promise 如果是promise取他的结果 作为promise2成功的的结果\n                        //如果返回一个普通值，作为promise2成功的结果\n                        //resolvePromise可以解析x和promise2之间的关系\n                        //在resolvePromise中传入四个参数，第一个是返回的promise，第二个是返回的结果，第三个和第四个分别是resolve()和reject()的方法。\n                        resolvePromise(promise2,x,resolve,reject)\n                  &#125;catch(e)&#123;\n                        reject(e);\n                  &#125;\n               &#125;,0)\n           &#125;);\n       &#125;\n       if(this.status === 'rejected')&#123;\n            promise2 = new Promise((resolve,reject) => &#123;\n                setTimeout(() => &#123;\n                    try&#123;\n                        let x = onRejected(this.reason);\n                        //在resolvePromise中传入四个参数，第一个是返回的promise，第二个是返回的结果，第三个和第四个分别是resolve()和reject()的方法。\n                        resolvePromise(promise2,x,resolve,reject)\n                    &#125;catch(e)&#123;\n                        reject(e);\n                    &#125;\n                &#125;,0)\n\n            &#125;);\n       &#125;\n       //当前既没有完成也没有失败\n       if(this.status === 'pending')&#123;\n           promise2 = new Promise((resolve,reject) => &#123;\n               //把成功的函数一个个存放到成功回调函数数组中\n                this.onResolvedCallbacks.push( () =>&#123;\n                    setTimeout(() => &#123;\n                        try&#123;\n                            let x = onFuiFilled(this.value);\n                            resolvePromise(promise2,x,resolve,reject);\n                        &#125;catch(e)&#123;\n                            reject(e);\n                        &#125;\n                    &#125;,0)\n                &#125;);\n                //把失败的函数一个个存放到失败回调函数数组中\n                this.onRejectedCallbacks.push( ()=>&#123;\n                    setTimeout(() => &#123;\n                        try&#123;\n                            let x = onRejected(this.reason);\n                            resolvePromise(promise2,x,resolve,reject)\n                        &#125;catch(e)&#123;\n                            reject(e)\n                        &#125;\n                    &#125;,0)\n                &#125;)\n           &#125;)\n       &#125;\n       return promise2;//调用then后返回一个新的promise\n    &#125;\n    catch (onRejected) &#123;\n        // catch 方法就是then方法没有成功的简写\n        return this.then(null, onRejected);\n    &#125;\n&#125;\nPromise.all = function (promises) &#123;\n    //promises是一个promise的数组\n    return new Promise(function (resolve, reject) &#123;\n        let arr = []; //arr是最终返回值的结果\n        let i = 0; // 表示成功了多少次\n        function processData(index, data) &#123;\n            arr[index] = data;\n            if (++i === promises.length) &#123;\n                resolve(arr);\n            &#125;\n        &#125;\n        for (let i = 0; i &lt; promises.length; i++) &#123;\n            promises[i].then(function (data) &#123;\n                processData(i, data)\n            &#125;, reject)\n        &#125;\n    &#125;)\n&#125;\n// 只要有一个promise成功了 就算成功。如果第一个失败了就失败了\nPromise.race = function (promises) &#123;\n    return new Promise((resolve, reject) => &#123;\n        for (var i = 0; i &lt; promises.length; i++) &#123;\n            promises[i].then(resolve,reject)\n        &#125;\n    &#125;)\n&#125;\n// 生成一个成功的promise\nPromise.resolve = function(value)&#123;\n    return new Promise((resolve,reject) => resolve(value);\n&#125;\n// 生成一个失败的promise\nPromise.reject = function(reason)&#123;\n    return new Promise((resolve,reject) => reject(reason));\n&#125;\nPromise.defer = Promise.deferred = function () &#123;\n    let dfd = &#123;&#125;;\n    dfd.promise = new Promise( (resolve, reject) =>  &#123;\n        dfd.resolve = resolve;\n        dfd.reject = reject;\n    &#125;);\n    return dfd\n&#125;\nmodule.exports = Promise;\n\n","slug":"根据PromiseA-实现一个自己的promise","date":"2022-05-29T06:13:47.000Z","categories_index":"","tags_index":"","author_index":"R桑"},{"id":"4239f11e747e61320e1a75b03648e3f3","title":"解决无法 clone github上的项目问题","content":"搭建 github-ssh 连接时，Could not resolve hostname github 的解决方案(无法 ping 通 github)解决无法 SSH clone github.com 的问题今天在进行搭建本地 git 时，需要通过 ssh 建立与 github 的连接，在进行ssh连接验证时，出现如下提示\nssh: Could not resolve hostname github.com: Name or service not known\n此时我们对github地址进行 ping 操作如下\nping github.com\n\n出现如下错误提示(git bash)\nPing request could not find host github.com. Please check the name and try again.\nwindows的 cmd 我没复制，但大致提示无法访问远程主机，连接不可建立\n解决方案：首先获取 github.com 的 IP 地址\nIP 地址查询： Click\n通过上述网站查询得到 github.com 的IP 地址如下\n140.82.114.3\n\n此时修改本地 DNS 文件 C:\\Windows\\System32\\drivers\\etc 目录下的 hosts 文件\n由于该文件在 C 盘中，无法直接打开进行修改，需要使用管理员权限\n此处操作方式为，搜索 记事本 软件，右键以管理员身份运行\n通过左上角文件 -&gt; 打开，选择上述 hosts 文件打开，在文件内容最下方加入一行\n140.82.114.3 github.com\n\n完成后保存即可。\n此时再次 ping github.com 即可看到能够成功 ping 通\nping 140.82.114.3\n","slug":"github上的项目问题","date":"2022-05-29T06:07:50.000Z","categories_index":"","tags_index":"bug","author_index":"R桑"},{"id":"731ec5f1b7c73c340c402d1ca94be6d0","title":"如何使用 Hexo","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new posthexo new \"My New Post\"\n\nMore info: Writing\nRun serverhexo server\n\nMore info: Server\nGenerate static fileshexo generate\n\nMore info: Generating\nDeploy to remote siteshexo deploy\n\nMore info: Deployment\n重新生成与本地服务器hexo clean &amp; hexo g &amp; hexo server\n","slug":"hello-world","date":"2022-05-15T02:45:36.000Z","categories_index":"","tags_index":"","author_index":"R桑"}]