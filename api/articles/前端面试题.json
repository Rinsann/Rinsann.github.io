{"title":"web前端面试题","uid":"00e814c6dd8c392dd19a02f2418ceb24","slug":"前端面试题","date":"2022-07-07T13:39:33.000Z","updated":"2022-07-11T08:56:51.854Z","comments":true,"path":"api/articles/前端面试题.json","keywords":null,"cover":[],"content":"<h3 id=\"如何理解SPA应用\"><a href=\"#如何理解SPA应用\" class=\"headerlink\" title=\"如何理解SPA应用\"></a>如何理解<code>SPA</code>应用</h3><p><code>SPA</code>（ <code>single-page application</code> ）仅在 <code>Web</code> 页面初始化时加载相应的 <code>HTML</code>、<code>JavaScript</code> 和 <code>CSS</code>。一旦页面加载完成，<code>SPA</code> 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 <code>HTML</code> 内容的变换，<code>UI</code> 与用户的交互，避免页面的重新加载。</p>\n<p><strong>优点：</strong></p>\n<ul>\n<li><p>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</p>\n</li>\n<li><p>基于上面一点，<code>SPA</code> 相对对服务器压力小；</p>\n</li>\n<li><p>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</p>\n</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>初次加载耗时多：为实现单页 <code>Web</code> 应用功能及显示效果，需要在加载页面的时候将 <code>JavaScript</code>、<code>CSS</code> 统一加载，部分页面按需加载；</li>\n<li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li>\n<li><code>SEO</code> 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 <code>SEO</code> 上其有着天然的弱势。</li>\n</ul>\n<h3 id=\"说一下前端登录的流程\"><a href=\"#说一下前端登录的流程\" class=\"headerlink\" title=\"说一下前端登录的流程?\"></a>说一下前端登录的流程?</h3><p>初次登录的时候，前端调后调的登录接口，发送用户名和密码，后端收到请求，验证用户名和密码，验证成功，就给前端返回一个<code>token</code>，和一个用户信息的值，前端拿到<code>token</code>，将<code>token</code>储存到<code>Vuex</code>中，然后从<code>Vuex</code>中把<code>token</code>的值存入浏览器<code>Cookies</code>中。</p>\n<p>把用户信息存到<code>Vuex</code>然后再存储到<code>LocalStroage</code>中,然后跳转到下一个页面，根据后端接口的要求，只要不登录就不能访问的页面需要在前端每次跳转页面师判断<code>Cookies</code>中是否有<code>token</code>，没有就跳转到登录页，有就跳转到相应的页面，我们应该再每次发送 post&#x2F;get 请求的时候应该加入<code>token</code>，常用方法再项目<code>utils/service.js</code>中添加全局拦截器，将<code>token</code>的值放入请求头中 后端判断请求头中有无<code>token</code>，有<code>token</code>，就拿到<code>token</code>并验证<code>token</code>是否过期，在这里过期会返回无效的<code>token</code>然后有个跳回登录页面重新登录并且清除本地用户的信息</p>\n<h3 id=\"说一下购物车的逻辑\"><a href=\"#说一下购物车的逻辑\" class=\"headerlink\" title=\"说一下购物车的逻辑?\"></a>说一下购物车的逻辑?</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token comment\">//vue中购物车逻辑的实现</span>\n<span class=\"token number\">1.</span> 购物车信息用一个数组来存储，数组中保存对象，对象中有id和count属性\n\n<span class=\"token number\">2.</span> 在vuex中state中添加一个数据 cartList 用来保存这个数组\n\n<span class=\"token number\">3.</span> 由于商品详情页需要用到加入购物车功能，所以我们需要提供一个mutation<span class=\"token punctuation\">,</span> 用来将购物车信息加入 cartList中\n\n<span class=\"token number\">4.</span> 加入购物车信息的时候，遵照如下规则： 如果购物车中已经有了该商品信息，则数量累加，如果没有该商品信息，则新增一个对象\n\n<span class=\"token number\">5.</span> 在商品详情页，点击加入购物车按钮的时候，调用vuex提供的addToCart这个mutation将当前的商品信息 （id count）传给addTocart  <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>$store<span class=\"token punctuation\">.</span><span class=\"token function\">commit</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"addToCart\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span><span class=\"token literal-property property\">id</span><span class=\"token operator\">:</span>  <span class=\"token punctuation\">,</span> count：<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">// js中购物车逻辑的实现</span>\n<span class=\"token number\">1.</span>商品页点击“加入购物车”按钮，触发事件\n\n<span class=\"token number\">2.</span>事件调用购物车“增加商品”的Js程序（函数、对象方法）\n\n<span class=\"token number\">3.</span>向Js程序传递传递“商品id”、“商品数量”等数据\n\n<span class=\"token number\">4.</span>存储“商品id”、“商品数量”到浏览器的localStorage中\n\n<span class=\"token operator\">**</span>展示购物车中的商品<span class=\"token operator\">**</span><span class=\"token operator\">**</span><span class=\"token operator\">**</span>\n\n<span class=\"token number\">1.</span>打开购物车页面\n\n<span class=\"token number\">2.</span>从localStorage中取出“商品Id”、“商品数量”等信息。\n\n<span class=\"token number\">3.</span>调用服务器端“获得商品详情”的接口得到购物车中的商品信息（参数为商品Id）\n\n<span class=\"token number\">4.</span>将获得的商品信息显示在购物车页面。\n\n<span class=\"token operator\">**</span>完成购物车中商品的购买<span class=\"token operator\">**</span><span class=\"token operator\">**</span><span class=\"token operator\">**</span>\n\n<span class=\"token number\">1.</span>用户对购物车中的商品完成购买流程，产生购物订单\n\n<span class=\"token number\">2.</span>清除localStorage中存储的已经购买的商品信息\n\n备注<span class=\"token number\">1</span>：购物车中商品存储的数据除了“商品id”、“商品数量”之外，根据产品要求还可以有其他的信息，例如完整的商品详情（这样就不用掉服务器接口获得详情了）、购物车商品的过期时间，超过时间的购物车商品在下次打开网站或者购物车页面时被清除。\n\n备注<span class=\"token number\">2</span>：购物车商品除了存储在localStorage中，根据产品的需求不同，也可以存储在sessionStorage、cookie、session中，或者直接向服务器接口发起请求存储在服务器上。何种情况使用哪种方式存储、有啥区别请自己分析。<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"说一下前端权限管理怎么实现\"><a href=\"#说一下前端权限管理怎么实现\" class=\"headerlink\" title=\"说一下前端权限管理怎么实现\"></a>说一下前端权限管理怎么实现</h3><p><strong><code>Vue</code> 实现</strong></p>\n<p>目前主要的设计思路都是基于<code>Vue-Router</code>配合后端返回角色权限定义进行设计。后端返回角色对应路由权限数据，返回形如 <code>&#123; role: ‘admin’, permissions: [‘Order’, …] &#125;</code>，<br>其中<code>permissions</code>对应前端路由页面<code>name</code>，通过这样的形式后端动态返回该角色所具备的权限列表，前端配合<code>router.addRoutes</code>动态注册路由，达到路由级的权限控制。</p>\n<p>在后台管理系统中对角色进行权限的分配（包括页面权限和接口权限），页面权限可以根据<code>vue-router</code>的<code>api</code>动态的生成路由表，而接口权限就需要后端的同学去进行校验。</p>\n<p>在<code>Vue</code>中权限控制的主体思路，前端会有一份路由表，它表示了每一个路由可访问的权限。当用户登录之后，通过 <code>token</code> 获取用户的 <code>role</code> ，动态根据用户的 <code>role</code> 算出其对应有权限的路由，再通过<code>router.addRoutes</code>动态挂载路由。但这些控制都只是页面级的。</p>\n<p>创建<code>vue</code>实例的时候将<code>vue-router</code>挂载，但这个时候<code>vue-router</code>挂载一些登录或者不用权限的公用的页面。<br>当用户登录后，获取用<code>role</code>，将<code>role</code>和路由表每个页面的需要的权限作比较，生成最终用户可访问的路由表。<br>调用<code>router.addRoutes(store.getters.addRouters)</code>添加用户可访问的路由。<br>使用<code>vuex</code>管理路由表，根据<code>vuex</code>中可访问的路由渲染侧边栏组件。</p>\n<p><strong><code>React</code> 实现</strong></p>\n<p><code>React</code>：利用高阶组件包装路由视图进行权限控制</p>\n<h3 id=\"说一下常见的-git-操作\"><a href=\"#说一下常见的-git-操作\" class=\"headerlink\" title=\"说一下常见的 git 操作\"></a>说一下常见的 git 操作</h3><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token function\">git</span> branch 查看本地所有分支\n<span class=\"token function\">git</span> status 查看当前状态\n<span class=\"token function\">git</span> commit 提交\n<span class=\"token function\">git</span> branch -a 查看所有的分支\n<span class=\"token function\">git</span> branch -r 查看远程所有分支\n<span class=\"token function\">git</span> commit -am <span class=\"token string\">\"init\"</span> 提交并且加注释\n<span class=\"token function\">git</span> remote <span class=\"token function\">add</span> origin git@192.168.1.119:ndshow\n<span class=\"token function\">git</span> push origin master 将文件给推到服务器上\n<span class=\"token function\">git</span> remote show origin 显示远程库origin里的资源\n<span class=\"token function\">git</span> push origin master:develop\n<span class=\"token function\">git</span> push origin master:hb-dev 将本地库与服务器上的库进行关联\n<span class=\"token function\">git</span> checkout --track origin/dev 切换到远程dev分支\n<span class=\"token function\">git</span> branch -D master develop 删除本地库develop\n<span class=\"token function\">git</span> checkout -b dev 建立一个新的本地分支dev\n<span class=\"token function\">git</span> merge origin/dev 将分支dev与当前分支进行合并\n<span class=\"token function\">git</span> checkout dev 切换到本地dev分支\n<span class=\"token function\">git</span> remote show 查看远程库\n<span class=\"token function\">git</span> <span class=\"token function\">add</span> <span class=\"token builtin class-name\">.</span>\n<span class=\"token function\">git</span> <span class=\"token function\">rm</span> 文件名<span class=\"token punctuation\">(</span>包括路径<span class=\"token punctuation\">)</span> 从git中删除指定文件\n<span class=\"token function\">git</span> clone git://github.com/schacon/grit.git 从服务器上将代码给拉下来\n<span class=\"token function\">git</span> config --list 看所有用户\n<span class=\"token function\">git</span> ls-files 看已经被提交的\n<span class=\"token function\">git</span> <span class=\"token function\">rm</span> <span class=\"token punctuation\">[</span>file name<span class=\"token punctuation\">]</span> 删除一个文件\n<span class=\"token function\">git</span> commit -a 提交当前repos的所有的改变\n<span class=\"token function\">git</span> <span class=\"token function\">add</span> <span class=\"token punctuation\">[</span>file name<span class=\"token punctuation\">]</span> 添加一个文件到git index\n<span class=\"token function\">git</span> commit -v 当你用－v参数的时候可以看commit的差异\n<span class=\"token function\">git</span> commit -m <span class=\"token string\">\"This is the message describing the commit\"</span> 添加commit信息\n<span class=\"token function\">git</span> commit -a -a是代表add，把所有的change加到git index里然后再commit\n<span class=\"token function\">git</span> commit -a -v 一般提交命令\n<span class=\"token function\">git</span> log 看你commit的日志\n<span class=\"token function\">git</span> <span class=\"token function\">diff</span> 查看尚未暂存的更新\n<span class=\"token function\">git</span> <span class=\"token function\">rm</span> a.a 移除文件<span class=\"token punctuation\">(</span>从暂存区和工作区中删除<span class=\"token punctuation\">)</span>\n<span class=\"token function\">git</span> <span class=\"token function\">rm</span> --cached a.a 移除文件<span class=\"token punctuation\">(</span>只从暂存区中删除<span class=\"token punctuation\">)</span>\n<span class=\"token function\">git</span> commit -m <span class=\"token string\">\"remove\"</span> 移除文件<span class=\"token punctuation\">(</span>从Git中删除<span class=\"token punctuation\">)</span>\n<span class=\"token function\">git</span> <span class=\"token function\">rm</span> -f a.a 强行移除修改后文件<span class=\"token punctuation\">(</span>从暂存区和工作区中删除<span class=\"token punctuation\">)</span>\n<span class=\"token function\">git</span> <span class=\"token function\">diff</span> --cached 或 $ <span class=\"token function\">git</span> <span class=\"token function\">diff</span> --staged 查看尚未提交的更新\n<span class=\"token function\">git</span> stash push 将文件给push到一个临时空间中\n<span class=\"token function\">git</span> stash pop 将文件从临时空间pop下来\n\n//  我是cv的自取吧<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"git-解决合并冲突\"><a href=\"#git-解决合并冲突\" class=\"headerlink\" title=\"git 解决合并冲突\"></a><code>git</code> 解决合并冲突</h3><p>现在通过<code>git merge featurel</code>进行分支合并，如下所示：</p>\n<p><img src=\"/../images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/b0991d90-fdb3-11eb-bc6f-3f06e1491664.png\" alt=\"img\"></p>\n<p>从冲突信息可以看到，<code>a.txt</code>发生冲突，必须手动解决冲突之后再提交</p>\n<p>而<code>git status</code>同样可以告知我们冲突的文件：</p>\n<p><img src=\"/../images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/c5823430-fdb3-11eb-991d-334fd31f0201.png\" alt=\"img\"></p>\n<p>打开<code>a.txt</code>文件，可以看到如下内容：</p>\n<p><img src=\"/../images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/ce7a0a90-fdb3-11eb-bc6f-3f06e1491664.png\" alt=\"img\"></p>\n<p><code>git</code>用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容：</p>\n<ul>\n<li>&#96;&#96;&#96;text<br>Invalid code snippet option<pre class=\"line-numbers language-none\"><code class=\"language-none\">\n- &#96;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#96; 和 &#96;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#96; 之间的区域就是传入进来更改的内容\n\n现在要做的事情就是将冲突的内容进行更改，对每个文件使用 &#96;git add&#96; 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，&#96;Git&#96;就会将它们标记为冲突已解决然后再提交：\n\n- &#96;git add a.txt&#96;\n- &#96;git commit -m &quot;conflict fixed&quot;&#96;\n\n此时&#96;master&#96;分支和&#96;feature1&#96;分支变成了下图所示：\n\n![img](..&#x2F;images&#x2F;%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98&#x2F;d7421e60-fdb3-11eb-bc6f-3f06e1491664.png)\n\n使用&#96;git log&#96;命令可以看到合并的信息：\n\n![img](..&#x2F;images&#x2F;%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98&#x2F;e0dfd1b0-fdb3-11eb-991d-334fd31f0201.png)\n\n当&#96;Git&#96;无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成\n\n解决冲突就是把&#96;Git&#96;合并失败的文件手动编辑为我们希望的内容，再提交\n\n### SPA 应用首屏加载速度慢\n\n**加载慢的原因**\n\n在页面渲染的过程，导致加载速度慢的因素可能如下：\n\n- 网络延时问题\n- 资源文件体积是否过大\n- 资源是否重复发送请求去加载了\n- 加载脚本的时候，渲染内容堵塞了\n\n**解决方案**\n\n常见的几种&#96;SPA&#96;首屏优化方式\n\n1.减小入口文件体积\n\n常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加\n\n&#96;&#96;&#96;js\n&#x2F;&#x2F; vue-router 配置路由的时候，采用动态加载路由的形式\nroutes:[\n    path: &#39;Blogs&#39;,\n    name: &#39;ShowBlogs&#39;,\n    component: () &#x3D;&gt; import(&#39;.&#x2F;components&#x2F;ShowBlogs.vue&#39;) &#x2F;&#x2F; 以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件\n]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>\n</ul>\n<p>2.静态资源本地缓存</p>\n<p>后端返回资源问题：</p>\n<ul>\n<li>采用<code>HTTP</code>缓存，设置<code>Cache-Control</code>，<code>Last-Modified</code>，<code>Etag</code>等响应头</li>\n<li>采用<code>Service Worker</code>离线缓存</li>\n</ul>\n<p>前端合理利用 <code>localStorage</code></p>\n<p>3.<code>UI</code>框架按需加载</p>\n<p>在日常使用<code>UI</code>框架，例如<code>element-UI</code>、或者<code>antd</code>，我们经常性直接饮用整个<code>UI</code>库</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> ElementUI <span class=\"token keyword\">from</span> <span class=\"token string\">'element-ui'</span>\nVue<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>ElementUI<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>但实际上我用到的组件只有按钮，分页，表格，输入与警告 所以我们要按需引用</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">&#123;</span>\n\tButton<span class=\"token punctuation\">,</span>\n\tInput<span class=\"token punctuation\">,</span>\n\tPagination<span class=\"token punctuation\">,</span>\n\tTable<span class=\"token punctuation\">,</span>\n\tTableColumn<span class=\"token punctuation\">,</span>\n\tMessageBox<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">&#125;</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'element-ui'</span>\nVue<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>Button<span class=\"token punctuation\">)</span>\nVue<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>Input<span class=\"token punctuation\">)</span>\nVue<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>Pagination<span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>4.图片资源的压缩</p>\n<p>图片资源虽然不在编码过程中，但它却是对页面性能影响最大的因素，对于所有的图片资源，我们可以进行适当的压缩</p>\n<p>对页面上使用到的<code>icon</code>，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻<code>http</code>请求压力。</p>\n<p>5.组件重复打包</p>\n<p>假设<code>A.js</code>文件是一个常用的库，现在有多个路由使用了<code>A.js</code>文件，这就造成了重复下载</p>\n<p>解决方案：在<code>webpack</code>的<code>config</code>文件中，修改<code>CommonsChunkPlugin</code>的配置</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token literal-property property\">minChunks</span><span class=\"token operator\">:</span> <span class=\"token number\">3</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><code>minChunks</code>为 3 表示会把使用 3 次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件</p>\n<p>6.开启<code>GZip</code>压缩</p>\n<p>拆完包之后，我们再用<code>gzip</code>做一下压缩 安装<code>compression-webpack-plugin</code></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">nmp i compression-webpack-plugin -D<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>在<code>vue.congig.js</code>中引入并修改<code>webpack</code>配置</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> CompressionPlugin <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'compression-webpack-plugin'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token function-variable function\">configureWebpack</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">config</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">NODE_ENV</span> <span class=\"token operator\">===</span> <span class=\"token string\">'production'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 为生产环境修改配置...</span>\n        config<span class=\"token punctuation\">.</span>mode <span class=\"token operator\">=</span> <span class=\"token string\">'production'</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token literal-property property\">plugins</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">CompressionPlugin</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">&#123;</span>\n        <span class=\"token literal-property property\">test</span><span class=\"token operator\">:</span> <span class=\"token regex\"><span class=\"token regex-delimiter\">/</span><span class=\"token regex-source language-regex\">\\.js$|\\.html$|\\.css</span><span class=\"token regex-delimiter\">/</span></span><span class=\"token punctuation\">,</span> <span class=\"token comment\">//匹配文件名</span>\n        <span class=\"token literal-property property\">threshold</span><span class=\"token operator\">:</span> <span class=\"token number\">10240</span><span class=\"token punctuation\">,</span> <span class=\"token comment\">//对超过10k的数据进行压缩</span>\n        <span class=\"token literal-property property\">deleteOriginalAssets</span><span class=\"token operator\">:</span> <span class=\"token boolean\">false</span> <span class=\"token comment\">//是否删除原文件</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>7.使用<code>SSR</code></p>\n<p><code>SSR</code>（<code>Server side</code> ），也就是服务端渲染，组件或页面通过服务器生成<code>html</code>字符串，再发送到浏览器</p>\n<p>从头搭建一个服务端渲染是很复杂的，<code>vue</code>应用建议使用<code>Nuxt.js</code>实现服务端渲染</p>\n<h3 id=\"重排-reflow-和重绘-repaint\"><a href=\"#重排-reflow-和重绘-repaint\" class=\"headerlink\" title=\"重排(reflow)和重绘(repaint)\"></a>重排(reflow)和重绘(repaint)</h3><ul>\n<li>重绘：某些元素的外观被改变，例如：元素的填充颜色</li>\n<li>重排：重新生成布局，重新排列元素。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>重绘不一定导致重排，但重排一定会导致重绘</strong>。</p></blockquote>\n<h3 id=\"HTML5-有哪些新特性\"><a href=\"#HTML5-有哪些新特性\" class=\"headerlink\" title=\"HTML5 有哪些新特性\"></a>HTML5 有哪些新特性</h3><ol>\n<li>新增了语义化标签：<code>header/ footer/main/aside/nav/article/section</code></li>\n<li>新增了视频 <code>video</code> 和 音频 <code>audio</code> 标签</li>\n<li>新增了 <code>canvas</code> 和 <code>SVG</code></li>\n<li>新增了 <code>localStorage</code> 和 <code>sessionStorage</code><ol>\n<li><code>localStorage</code> - 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。</li>\n<li><code>sessionStorage</code> - 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。</li>\n</ol>\n</li>\n<li>新增了 <code>Web Socket</code></li>\n</ol>\n<h3 id=\"理解-cookie、session、localStorage、sessionStorage-关系与区别\"><a href=\"#理解-cookie、session、localStorage、sessionStorage-关系与区别\" class=\"headerlink\" title=\"理解 cookie、session、localStorage、sessionStorage 关系与区别\"></a>理解 cookie、session、localStorage、sessionStorage 关系与区别</h3><h4 id=\"cookie与session的区别\"><a href=\"#cookie与session的区别\" class=\"headerlink\" title=\"cookie与session的区别\"></a><code>cookie</code>与<code>session</code>的区别</h4><ul>\n<li><code>Cookie</code>数据存放在客户端，<code>Session</code>数据放在服务器端</li>\n<li><code>Cookie</code>的安全性一般，他人可通过分析存放在本地的<code>Cookie</code>并进行<code>Cookie</code>欺骗。在安全性第一的前提下，选择<code>Session</code>更优。重要交互信息比如权限等就要放在<code>Session</code>中，一般的信息记录放<code>Cookie</code>中</li>\n<li>单个<code>Cookie</code>保存的数据不能超过<code>4K</code>，很多浏览器都限制一个站点最多保存<code>20</code>个<code>Cookie</code>，而<code>Session</code>原则上没有限制</li>\n<li><code>Session</code>会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用<code>Cookie</code>。</li>\n<li><code>Session</code> 的运行依赖<code>Session ID</code>，而 <code>Session ID</code> 是存在 <code>Cookie</code> 中的，也就是说，如果浏览器禁用了 <code>Cookie</code>，<code>Session</code> 也会失效（但是可以通过其它方式实现，比如在 <code>url</code> 中传递 <code>Session ID</code>，也就是地址重写）</li>\n</ul>\n<h4 id=\"localStorage-的特点\"><a href=\"#localStorage-的特点\" class=\"headerlink\" title=\"localStorage 的特点\"></a>localStorage 的特点</h4><ul>\n<li><code>localStorage</code> 与 <code>HTTP</code> 没有任何关系，所以在 HTTP 请求时不会带上 <code>localStorage</code> 的值</li>\n<li>只有相同域名的页面才能互相读取 <code>localStorage</code>，同源策略与 <code>cookie</code> 一致</li>\n<li>不同的浏览器，对每个域名 <code>localStorage</code> 的最大存储量的规定不一样，超出存储量会被拒绝。最大存<code>5M</code> 超过<code>5M</code>的数据就会丢失。而 <code>Chrome 10MB</code> 左右</li>\n<li>常用来记录一些不敏感的信息</li>\n<li><code>localStorage</code> 理论上永久有效，除非用户清理缓存</li>\n</ul>\n<h4 id=\"sessionStorage的特点\"><a href=\"#sessionStorage的特点\" class=\"headerlink\" title=\"sessionStorage的特点\"></a><code>sessionStorage</code>的特点</h4><p><code>sessionStorage</code> 的所有性质基本上与 <code>localStorage</code> 一致，唯一的不同区别在于：</p>\n<p><code>sessionStorage</code> 的有效期是页面会话持续，如果页面会话（<code>session</code>）结束（关闭窗口或标签页），<code>sessionStorage</code> 就会消失。而 <code>localStorage</code> 则会一直存在。</p>\n<h4 id=\"localStorage与sessionStorage的区别\"><a href=\"#localStorage与sessionStorage的区别\" class=\"headerlink\" title=\"localStorage与sessionStorage的区别\"></a><code>localStorage</code>与<code>sessionStorage</code>的区别</h4><ul>\n<li><code>localStorage</code>生命周期是永久的，除非被清除，否则永久保存，而<code>sessionStorage</code>仅在当前会话下有效，关闭页面或浏览器后被清除</li>\n</ul>\n<h3 id=\"px、em、rem、vw-百分比的区别\"><a href=\"#px、em、rem、vw-百分比的区别\" class=\"headerlink\" title=\"px、em、rem、vw 百分比的区别\"></a>px、em、rem、vw 百分比的区别</h3><ul>\n<li><code>px</code>: 是固定单位，其他几种都是相对单位。</li>\n<li><code>em</code>: 默认字体大小的倍数。比如给元素设置<code>font-size：2em</code></li>\n<li><code>rem</code>: 根元素（<code>html</code>节点）字体大小的倍数。</li>\n<li><code>1vw</code>: 代表浏览器视口宽度的<code>1% </code>，<code>vw</code>和<code>vh</code>比<code>rem</code>精度更高</li>\n<li><code>1%</code>: 对不同的属性有不同的含义。</li>\n</ul>\n<h3 id=\"forEach能return吗\"><a href=\"#forEach能return吗\" class=\"headerlink\" title=\"forEach能return吗\"></a><code>forEach</code>能<code>return</code>吗</h3><p><code>forEach </code>没有返回值只是作为一个对象去遍历的。</p>\n<h3 id=\"为什么-JavaScript-中-0-1-0-2-≠-0-3\"><a href=\"#为什么-JavaScript-中-0-1-0-2-≠-0-3\" class=\"headerlink\" title=\"为什么 JavaScript 中 0.1 + 0.2 ≠ 0.3\"></a>为什么 JavaScript 中 0.1 + 0.2 ≠ 0.3</h3><p>JavaScript 使用 Number 类型表示数字（整数和浮点数），遵循 <a href=\"https://link.juejin.cn/?target=https://zh.wikipedia.org/wiki/IEEE_754\">IEEE 754</a> 标准 通过 64 位来表示一个数字</p>\n<p>0.1 在二进制中表示为 0.1 &#x3D; 2^-4 * 1.10011(0011)，即 0.000110011001100110011……</p>\n<p>0.1 和 0.2 转换成二进制后会无限循环</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0.1 -&gt; 0.0001100110011001...(无限循环)\n0.2 -&gt; 0.0011001100110011...(无限循环)<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>即 0.1 在二进制中是无限循环的，很多十进制小数用二进制表示都是无限循环的，但 JS 采用的浮点数标准 IEEE 754 尾数位数限制，会舍入掉超出 64 位的数字，这样在进制之间的转换中精度已经损失。</p>\n<h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h3><h3 id=\"JavaScript-原型，原型链-有什么特点？\"><a href=\"#JavaScript-原型，原型链-有什么特点？\" class=\"headerlink\" title=\"JavaScript 原型，原型链 ? 有什么特点？\"></a>JavaScript 原型，原型链 ? 有什么特点？</h3><p><code>JavaScript</code> 常被描述为一种基于原型的语言——每个对象拥有一个原型对象</p>\n<p>当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾</p>\n<p>准确地说，这些属性和方法定义在 Object 的构造器函数（constructor functions）之上的<code>prototype</code>属性上，而非实例对象本身</p>\n<p>原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。这种关系常被称为原型链 (prototype chain)，它解释了为何一个对象会拥有定义在其他对象中的属性和方法</p>\n<p>在对象实例和它的构造器之间建立一个链接（它是<code>__proto__</code>属性，是从构造函数的<code>prototype</code>属性派生的），之后通过上溯原型链，在构造器中找到这些属性和方法</p>\n<p><img src=\"/../images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/6a742160-725e-11eb-ab90-d9ae814b240d.png\" alt=\"img\"></p>\n<p>每个对象的<code>__proto__</code>都是指向它的构造函数的原型对象<code>prototype</code>的</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">person1<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">===</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>构造函数是一个函数对象，是通过 <code>Function</code>构造器产生的</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Person<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">===</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">.</span>prototype<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>原型对象本身是一个普通对象，而普通对象的构造函数都是<code>Object</code></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token class-name\">Person</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">===</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>刚刚上面说了，所有的构造器都是函数对象，函数对象都是 <code>Function</code>构造产生的</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">Object<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">===</span> <span class=\"token class-name\">Function</span><span class=\"token punctuation\">.</span>prototype<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><code>Object</code> 的原型对象也有<code>__proto__</code>属性指向<code>null</code>，<code>null</code>是原型链的顶端</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span>__proto__ <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>下面作出总结：</p>\n<ul>\n<li>一切对象都是继承自<code>Object</code>对象，<code>Object</code> 对象直接继承根源对象<code>null</code></li>\n<li>一切的函数对象（包括 <code>Object</code> 对象），都是继承自 <code>Function</code> 对象</li>\n<li><code>Object</code> 对象直接继承自 <code>Function</code> 对象</li>\n<li><code>Function</code>对象的<code>__proto__</code>会指向自己的原型对象，最终还是继承自<code>Object</code>对象</li>\n</ul>\n<h3 id=\"ES6-的新特性\"><a href=\"#ES6-的新特性\" class=\"headerlink\" title=\"ES6 的新特性\"></a>ES6 的新特性</h3><ul>\n<li>新增了<code>let</code>和<code>const</code></li>\n<li>变量的解构赋值 <code>const student = [&#39;小花&#39;,&#39;小王&#39;,&#39;小李&#39;,&#39;小吴&#39;,]; let [xiaohua,xiaowang,xiaoli,xiangwu] = student;</code></li>\n<li>模板字符串</li>\n<li>箭头函数 () &#x3D;&gt; {}</li>\n<li>扩展运算符，也就是三个点 <code>...</code></li>\n<li><code>Symbol</code>：<code>ES6</code> 引入的一种新的原始数据类型 <code>Symbol</code>，表示独一无二的值。</li>\n<li><code>Promise</code>：<code>Promise</code>是 <code>ES6</code>引入的异步编程的新解决方案 。语法上 <code>Promise</code>是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。</li>\n<li><code>class</code> 类</li>\n<li>模块化</li>\n</ul>\n<h3 id=\"New-操作符做了什么事情\"><a href=\"#New-操作符做了什么事情\" class=\"headerlink\" title=\"New 操作符做了什么事情?\"></a>New 操作符做了什么事情?</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token number\">1</span>、首先创建了一个新对象\n<span class=\"token number\">2</span>、设置原型，将对象的原型设置为函数的prototype对象\n<span class=\"token number\">3</span>、让函数的<span class=\"token keyword\">this</span>指向这个对象，执行构造函数的代码（为这个新对象添加属性）\n<span class=\"token number\">4</span>、判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"箭头函数的this指向\"><a href=\"#箭头函数的this指向\" class=\"headerlink\" title=\"箭头函数的this指向\"></a>箭头函数的<code>this</code>指向</h3><p>箭头函数没有自己的<code>this</code>，一般是外部的作用域的<code>this</code>，如果已经是在全局环境下了那么<code>this</code>指向就是<code>window</code></p>\n<h3 id=\"async-和-await\"><a href=\"#async-和-await\" class=\"headerlink\" title=\"async 和 await\"></a>async 和 await</h3><p><code>async</code> 函数是 <code>Generator</code> 函数的语法糖。使用 关键字 <code>async</code> 来表示，在函数内部使用<code>await</code> 表明当前函数是异步函数 不会阻塞线程导致后续代码停止运行。</p>\n<p><code>await</code>意思是<code>async wait</code>(异步等待)。这个关键字只能在使用<code>async</code>定义的函数里面使用。任何<code>async</code>函数都会默认返回<code>promise</code>，并且这个<code>promise</code>解析的值都将会是这个函数的返回值，而<code>async</code>函数必须等到内部所有的 <code>await</code> 命令的 <code>Promise</code> 对象执行完，才会发生状态改变</p>\n<h3 id=\"Vue-的-data-为什么是一个方法而不写成对象\"><a href=\"#Vue-的-data-为什么是一个方法而不写成对象\" class=\"headerlink\" title=\"Vue 的 data 为什么是一个方法而不写成对象\"></a>Vue 的 data 为什么是一个方法而不写成对象</h3><p><code>vue</code>为了保证每个实例上的<code>data</code>数据的独立性，规定了必须使用函数，而不是对象。</p>\n<p>因为使用对象的话，每个实例（组件）上使用的<code>data</code>数据是相互影响的，这当然就不是我们想要的了。对象是对于内存地址的引用，直接定义个对象的话组件之间都会使用这个对象，这样会造成组件之间数据相互影响。</p>\n<h3 id=\"Vue-set-方法\"><a href=\"#Vue-set-方法\" class=\"headerlink\" title=\"Vue.set 方法\"></a>Vue.set 方法</h3><p>当生成<code>vue</code>实例后，当再次对 data 中的数组或对象进行修改时，有些操作方式是非响应式的，<code>Vue</code>检测不到数据更新，因此也不会触发视图更新。此时需要使用<code>Vue.set()</code>进行响应式的数据更新。</p>\n<h3 id=\"v-model-数据双向绑定\"><a href=\"#v-model-数据双向绑定\" class=\"headerlink\" title=\"v-model 数据双向绑定\"></a>v-model 数据双向绑定</h3><ol>\n<li><p>说明一般使用 <code>v-model / .sync</code> 实现，<code>v-model</code> 是 <code>v-bind:value</code>和 <code>v-on:input</code>的语法糖</p>\n<ul>\n<li><code>v-bind:value</code> 实现了 <code>data ⇒ UI</code> 的单向绑定</li>\n<li><code>v-on:input</code> 实现了 <code>UI ⇒ data</code> 的单向绑定</li>\n<li>加起来就是双向绑定了</li>\n</ul>\n</li>\n<li><p>这两个单向绑定是如何实现的呢？</p>\n<ul>\n<li><p>前者通过 <code>Object.defineProperty API</code> 给 <code>data</code> 创建 <code>getter</code> 和 <code>setter</code>，用于监听 <code>data</code> 的改变，<code>data</code> 一变就会安排改变 <code>UI</code></p>\n</li>\n<li><p>后者通过 <code>template compiler</code> 给 <code>DOM</code> 添加事件监听，<code>DOM input</code> 的值变了就会去修改 <code>data</code>。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"组件间数据传递的方式\"><a href=\"#组件间数据传递的方式\" class=\"headerlink\" title=\"组件间数据传递的方式\"></a>组件间数据传递的方式</h3><ol>\n<li><p>父子组件：使用「props 和事件」进行通信</p>\n</li>\n<li><p>爷孙组件：</p>\n<ul>\n<li><p>使用两次父子组件间通信来实现</p>\n</li>\n<li><p>使用「<code>provide + inject</code>」来通信</p>\n</li>\n</ul>\n</li>\n<li><p>任意组件：使用 <code>eventBus = new Vue()</code> 来通信</p>\n</li>\n</ol>\n<ul>\n<li>主要 API 是 <code>eventBus.$on</code> 和 <code>eventBus.$emit</code></li>\n<li>缺点是事件多了就很乱，难以维护</li>\n</ul>\n<ol start=\"4\">\n<li>任意组件：使用 <code>Vuex</code> 通信（<code>Vue 3</code> 可用 <code>Pinia</code> 代替 <code>Vuex</code>）</li>\n</ol>\n<h3 id=\"MVVM-模型\"><a href=\"#MVVM-模型\" class=\"headerlink\" title=\"MVVM 模型\"></a>MVVM 模型</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>MVVM</code>表示的是 &#96;&#96;Model-View-ViewModel&#96;</p></blockquote>\n<ul>\n<li><code>Model</code>：模型层，负责处理业务逻辑以及和服务器端进行交互</li>\n<li><code>View</code>：视图层：负责将数据模型转化为<code>UI</code>展示出来，可以简单的理解为<code>HTML</code>页面</li>\n<li><code>ViewModel</code>：视图模型层，用来连接<code>Model</code>和<code>View</code>，是<code>Model</code>和<code>View</code>之间的通信桥梁</li>\n</ul>\n<p><img src=\"/../images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/4402c560-3ac6-11eb-85f6-6fac77c0c9b3.png\" alt=\"image.png\"></p>\n<h3 id=\"computed-和-watch\"><a href=\"#computed-和-watch\" class=\"headerlink\" title=\"computed 和 watch\"></a>computed 和 watch</h3><ul>\n<li><code>computed</code> 支持缓存，只有依赖数据发生改变，才会重新进行计算</li>\n<li><code>computed</code> 不支持异步，当<code>computed</code>内有异步操作时无效，无法监听数据的变化</li>\n<li><code>computed</code>属性属性值是函数，那么默认会走<code>get</code>方法；函数的返回值就是属性的属性值；在<code>computed</code>中的，属性都有一个<code>get</code>和一个<code>set</code>方法，当数据变化时，调用<code>set</code>方法。</li>\n<li><code>watch</code>它是一个对<code>data</code>的数据监听回调, 当依赖的<code>data</code>的数据变化时, 会执行回调</li>\n<li><code>watch</code>支持异步, 同时有两个属性<code>immediate</code>：组件加载立即触发回调函数执行， <code>deep</code>: 深度监听，为了发现对象内部值的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：<code>deep</code>无法监听到数组的变动和对象的新增，参考<code>vue</code>数组变异,只有以响应式的方式触发才会被监听到。</li>\n</ul>\n<p><strong>watch 和 computed 的区别是：</strong></p>\n<p>相同点：他们两者都是观察页面数据变化的。</p>\n<p>不同点：<code>computed</code>只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。 <code>watch</code>每次都需要执行函数。<code>watch</code>更适用于数据变化时的异步操作。</p>\n<p>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。这是和<code>computed</code>最大的区别，请勿滥用。</p>\n<h3 id=\"webpack-构建流程\"><a href=\"#webpack-构建流程\" class=\"headerlink\" title=\"webpack 构建流程\"></a>webpack 构建流程</h3><ul>\n<li>开始运行 <code>Webpack</code>。<ul>\n<li>读取与合并参数，加载 <code>plugin</code>。</li>\n<li>实例化 <code>Compiler</code>。<ul>\n<li>调用 <code>compiler.run</code> 创建 <code>Compilation</code>，代表一次资源的构建。</li>\n<li><code>Compilation</code> 对象也提供了很多关键步骤的钩子函数，并生成一次 <code>Chunk</code>。</li>\n<li><code>Compilation.buildModule</code> 主要执行 <code>loader</code>，编译掉不认识的代码。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>使用 <code>Parser</code> 分析项目依赖。<ul>\n<li>从 <code>Chunk</code> 开始解析依赖，使用 <code>Module</code> 和 <code>Dependency</code> 管理代码模块相互关系。</li>\n</ul>\n</li>\n<li>使用 <code>Template</code> 生成结果代码。<ul>\n<li>基于 <code>Chunk</code> 的数据拼接字符串，生成最终代码。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"token-的过期时间\"><a href=\"#token-的过期时间\" class=\"headerlink\" title=\"token 的过期时间\"></a>token 的过期时间</h3><p>登录完后后端返回一个<code>token</code>，将<code>token</code>存储到 <code>localStorage</code>，用户触发页面行为的时候回去调用接口，我们把这个<code>token</code>放在请求头上带给后端，后端去数据库里面查，看看用户的 token 有没有过期，过期了会返回一个状态码 <code>401</code>，然后跳转到 <code>login</code> 让用户重新登录请求<code>token</code></p>\n<h3 id=\"说一下常见的-HTTP-状态码-说一下状态码是-302-和-304-是什么意思？你在项目中出现过么？你是怎么解决的？\"><a href=\"#说一下常见的-HTTP-状态码-说一下状态码是-302-和-304-是什么意思？你在项目中出现过么？你是怎么解决的？\" class=\"headerlink\" title=\"说一下常见的 HTTP 状态码?说一下状态码是 302 和 304 是什么意思？你在项目中出现过么？你是怎么解决的？\"></a>说一下常见的 HTTP 状态码?说一下状态码是 302 和 304 是什么意思？你在项目中出现过么？你是怎么解决的？</h3><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">   <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 状态码：由<span class=\"token number\">3</span>位数字组成，第一个数字定义了响应的类别 <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n   <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 1xx：指示消息<span class=\"token punctuation\">,</span>表示请求已接收，继续处理 <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n   <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 2xx：成功<span class=\"token punctuation\">,</span>表示请求已被成功接收，处理 <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n   <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> <span class=\"token number\">200</span> <span class=\"token constant\">OK</span>：客户端请求成功\n        <span class=\"token number\">204</span> No Content：无内容。服务器成功处理，但未返回内容。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。不会刷新页面。\n        <span class=\"token number\">206</span> Partial Content：服务器已经完成了部分<span class=\"token constant\">GET</span>请求（客户端进行了范围请求）。响应报文中包含Content<span class=\"token operator\">-</span>Range指定范围的实体内容\n<span class=\"token operator\">--</span><span class=\"token operator\">></span>\n   <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 3xx 重定向 <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n   <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> <span class=\"token number\">301</span> Moved Permanently：永久重定向，表示请求的资源已经永久的搬到了其他位置。\n        <span class=\"token number\">302</span> Found：临时重定向，表示请求的资源临时搬到了其他位置\n        <span class=\"token number\">303</span> See Other：临时重定向，应使用<span class=\"token constant\">GET</span>定向获取请求资源。<span class=\"token number\">303</span>功能与<span class=\"token number\">302</span>一样，区别只是<span class=\"token number\">303</span>明确客户端应该使用<span class=\"token constant\">GET</span>访问\n        <span class=\"token number\">307</span> Temporary Redirect：临时重定向，和<span class=\"token number\">302</span>有着相同含义。<span class=\"token constant\">POST</span>不会变成<span class=\"token constant\">GET</span>\n        <span class=\"token number\">304</span> Not Modified：表示客户端发送附带条件的请求（<span class=\"token constant\">GET</span>方法请求报文中的<span class=\"token constant\">IF</span>…）时，条件不满足。返回<span class=\"token number\">304</span>时，不包含任何响应主体。虽然<span class=\"token number\">304</span>被划分在3XX，但和重定向一毛钱关系都没有\n<span class=\"token operator\">--</span><span class=\"token operator\">></span>\n   <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 4xx：客户端错误 <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n   <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> <span class=\"token number\">400</span> Bad Request：客户端请求有语法错误，服务器无法理解。\n        <span class=\"token number\">401</span> Unauthorized：请求未经授权，这个状态代码必须和<span class=\"token constant\">WWW</span><span class=\"token operator\">-</span>Authenticate报头域一起使用。\n        <span class=\"token number\">403</span> Forbidden：服务器收到请求，但是拒绝提供服务\n        <span class=\"token number\">404</span> Not Found：请求资源不存在。比如，输入了错误的url\n        <span class=\"token number\">415</span> Unsupported media type：不支持的媒体类型\n<span class=\"token operator\">--</span><span class=\"token operator\">></span>\n   <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> 5xx：服务器端错误，服务器未能实现合法的请求。 <span class=\"token operator\">--</span><span class=\"token operator\">></span>\n   <span class=\"token operator\">&lt;</span><span class=\"token operator\">!</span><span class=\"token operator\">--</span> <span class=\"token number\">500</span> Internal Server Error：服务器发生不可预期的错误。\n        <span class=\"token number\">503</span> Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常，\n<span class=\"token operator\">--</span><span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h3 id=\"我们在浏览器中输入-URL-并回车后都发生了什么？\"><a href=\"#我们在浏览器中输入-URL-并回车后都发生了什么？\" class=\"headerlink\" title=\"我们在浏览器中输入 URL 并回车后都发生了什么？\"></a>我们在浏览器中输入 URL 并回车后都发生了什么？</h3><ol>\n<li><p>合成 <code>URL</code></p>\n</li>\n<li><p><code>DNS</code> 域名解析</p>\n</li>\n<li><p>三次握手，建立<code>TCP</code>连接</p>\n</li>\n<li><p>发送<code>HTTP</code>请求，服务器处理请求，返回响应结果</p>\n</li>\n<li><p>关闭<code>TCP</code>连接，四次挥手</p>\n</li>\n<li><p>浏览器渲染</p>\n<ul>\n<li>渲染进程将<code>HTML</code>内容转换为能够读懂的<code>DOM</code>树结构</li>\n<li>渲染引擎将<code>CSS</code>样式表转化为浏览器可以理解的<code>styleSheets</code>，计算出<code>DOM</code>节点的样式</li>\n<li>创建布局树，并计算元素的布局信息</li>\n<li>对布局树进行分层，并生成分层树</li>\n<li>为每个图层生成绘制列表，并将其提交到合成线程。合成线程将图层分图块，并栅格化将图块转成位图</li>\n<li>合成线程发送绘制图块命令给浏览器进程，浏览器进程根据指令生成页面，并显示到显示器上。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"微任务和宏任务\"><a href=\"#微任务和宏任务\" class=\"headerlink\" title=\"微任务和宏任务\"></a>微任务和宏任务</h3><h4 id=\"正式开始\"><a href=\"#正式开始\" class=\"headerlink\" title=\"正式开始\"></a>正式开始</h4><ul>\n<li>先上代码</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">app</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n\t\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'1-1'</span><span class=\"token punctuation\">)</span>\n\t\tPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n\t\t\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'2-1'</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'1-2'</span><span class=\"token punctuation\">)</span>\n\tPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n\t\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'1-3'</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n\t\t\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'3-1'</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token function\">app</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>输出结果：</li>\n</ul>\n<pre class=\"line-numbers language-apache\" data-language=\"apache\"><code class=\"language-apache\">1-2\n1-3\n1-1\n2-1\n3-1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"开始分析\"><a href=\"#开始分析\" class=\"headerlink\" title=\"开始分析\"></a>开始分析</h4><ul>\n<li>面试官特别喜欢问：你讲讲什么是微任务和宏任务</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>大部分面试官其实自己也不懂什么是微任务和宏任务,不信下次你们反问一下</p></blockquote>\n<h5 id=\"所谓微任务和宏任务\"><a href=\"#所谓微任务和宏任务\" class=\"headerlink\" title=\"所谓微任务和宏任务\"></a>所谓微任务和宏任务</h5><ul>\n<li>宏任务:常见的定时器,用户交互事件等等.（宏任务就是特定的这些个任务,没什么特殊含义）</li>\n<li>微任务:<code>Promise</code>相关任务,<code>MutationObserver</code>等（一样，<code>只是一种称呼而已！！！</code>）</li>\n</ul>\n<h5 id=\"到底先执行微任务还是宏任务\"><a href=\"#到底先执行微任务还是宏任务\" class=\"headerlink\" title=\"到底先执行微任务还是宏任务\"></a>到底先执行微任务还是宏任务</h5><ul>\n<li>先有鸡还是先有蛋? 到底是先有宏任务还是微任务啊?</li>\n</ul>\n<h5 id=\"第一个原则\"><a href=\"#第一个原则\" class=\"headerlink\" title=\"第一个原则\"></a>第一个原则</h5><ul>\n<li>万物皆从全局上下文准备退出，全局的同步代码运行结束的这个时机开始</li>\n<li>例如我们刚才这段代码：</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">app</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\t<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n\t\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'1-1'</span><span class=\"token punctuation\">)</span>\n\t\tPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n\t\t\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'2-1'</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'1-2'</span><span class=\"token punctuation\">)</span>\n\tPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n\t\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'1-3'</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n\t\t\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'3-1'</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token function\">app</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<ul>\n<li>当执行完了<code>console.log(&quot;1-2&quot;);</code>的时候，意味着全局的上下文马上要退出了,因为此时全局的同步代码都执行完了,剩下的都是异步代码</li>\n</ul>\n<h5 id=\"第二个原则\"><a href=\"#第二个原则\" class=\"headerlink\" title=\"第二个原则\"></a>第二个原则</h5><ul>\n<li>同一层级下(<code>不理解层级，可以先不管，后面会讲</code>),微任务永远比宏任务先执行</li>\n<li>即<code>Promise.then</code>比<code>setTimeout</code>先执行</li>\n<li>所以先打印<code>1-3</code>,再打印<code>1-1</code></li>\n</ul>\n<h5 id=\"第三个原则\"><a href=\"#第三个原则\" class=\"headerlink\" title=\"第三个原则\"></a>第三个原则</h5><ul>\n<li>每个宏任务,都单独关联了一个微任务队列</li>\n<li>我用刚买的黑板画了一张图,大家就知道什么是层级了</li>\n</ul>\n<p><img src=\"/../images/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/1460000039055445.png\" alt=\"img\"></p>\n<ul>\n<li>每个层级的宏任务,都对应了他们的微任务队列,微任务队列遵循先进先出的原则,当全局同步代码执行完毕后,就开始执行第一层的任务。同层级的微任务永远先于宏任务执行,并且会在当前层级宏任务结束前全部执行完毕</li>\n</ul>\n<h4 id=\"怎么分辨层级？\"><a href=\"#怎么分辨层级？\" class=\"headerlink\" title=\"怎么分辨层级？\"></a>怎么分辨层级？</h4><ul>\n<li>属于同一个维度的代码,例如下面的<code>func1和func2</code>就属于同层级任务</li>\n</ul>\n<pre class=\"line-numbers language-stylus\" data-language=\"stylus\"><code class=\"language-stylus\"><span class=\"token func\"><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>func1<span class=\"token punctuation\">)</span><span class=\"token operator\">...</span></span>\nPromise<span class=\"token punctuation\">.</span><span class=\"token func\"><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>.<span class=\"token func\"><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>func2<span class=\"token punctuation\">)</span><span class=\"token operator\">...</span></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<ul>\n<li>下面这种<code>fn1和fn2</code>就不属于同一个层级的,因为 fn2 属于内部这个<code>setTimeout</code>的微任务队列,而<code>fn1</code>属于外部<code>setTimeout</code>的微任务队列</li>\n</ul>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n\tPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>fn1<span class=\"token punctuation\">)</span>\n\t<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">&#123;</span>\n\t\tPromise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span>fn2<span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>划重点:每个宏任务对应一个单独的微任务队列</p></blockquote>\n<h5 id=\"遇到面试题\"><a href=\"#遇到面试题\" class=\"headerlink\" title=\"遇到面试题\"></a>遇到面试题</h5><ul>\n<li>就按照我的套路,从全局上下文退出前（全局的同步代码执行完毕后）,开始收集当前层级的微任务和宏任务,然后先清空微任务队列,再执行宏任务.如果这期间遇到宏任务&#x2F;微任务,就像我这样画个图,把他们塞进对应的层级里即可</li>\n</ul>\n<h3 id=\"Vue中的-nextTick使用场景\"><a href=\"#Vue中的-nextTick使用场景\" class=\"headerlink\" title=\"Vue中的$nextTick使用场景\"></a><code>Vue</code>中的<code>$nextTick</code>使用场景</h3><p>轮播图场景：仓库中的<code>bannerList</code>最开始是一个空数组，然后服务器发请求数据回来，获取到图片数据，这里是有数据变化的。</p>\n<p>通过 <code>watch</code> 监听 <code>bannerList</code> 属性值的变化，当我们监听的这个回调执行力，代表组件实例身上这个属性的数据已经有了。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\"><span class=\"token literal-property property\">watch</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token comment\">//  监听bannerList数据的变化</span>\n  <span class=\"token literal-property property\">bannerList</span><span class=\"token operator\">:</span><span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">handler</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">newValue<span class=\"token punctuation\">,</span>oldValue</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n      <span class=\"token keyword\">new</span> <span class=\"token class-name\">Swiper</span><span class=\"token punctuation\">(</span>document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'.swiper-container'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token literal-property property\">loop</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n        <span class=\"token comment\">//  如果需要分页器</span>\n        <span class=\"token literal-property property\">pagination</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n          <span class=\"token literal-property property\">el</span><span class=\"token operator\">:</span> <span class=\"token string\">'.swiper-pagination'</span><span class=\"token punctuation\">,</span>\n          <span class=\"token literal-property property\">clickable</span><span class=\"token operator\">:</span><span class=\"token boolean\">true</span>\n        <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">,</span>\n        <span class=\"token comment\">//  如果需要前进后退</span>\n        <span class=\"token literal-property property\">navigation</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">&#123;</span>\n          <span class=\"token literal-property property\">nextEl</span><span class=\"token operator\">:</span> <span class=\"token string\">'.swiper-button-next'</span><span class=\"token punctuation\">,</span>\n          <span class=\"token literal-property property\">prevEl</span><span class=\"token operator\">:</span> <span class=\"token string\">'.swiper-button-prev'</span>\n        <span class=\"token punctuation\">&#125;</span>\n      <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">&#125;</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>那<code>watch</code>这种写法可以吗？还是不行~</p>\n<p>在这里<code>new Swiper</code> 还是没有结构，这里只能保证数据已经有了，但是 <code>v-for</code> 有没有执行完毕把结构渲染出来还是不确定的。</p>\n<p><strong><code>$nextTick</code>：</strong>在下次<code>DOM</code>更新<strong>循环结束之后</strong>执行延迟回调。在<strong>修改数据之后</strong>立即执行这个方法，获取更新后的<code>DOM</code>。</p>\n<p><code>bannerList</code> 初始状态是一个空数组，数据拿到它发生数组中有了数据，DOM 已经更新完毕了，这里指的就是下次<code>DOM</code>更新，<code>v-for</code> 循环结束了结构已经有了，就是循环结束之后然后再延迟执行回调。</p>\n<p>在修改数据之后，<code>bannerList</code>就是一个空数组，服务器数据已经拿到了，<code>v-for</code> 循环结束之后，在执行 <code>nextTick</code>回调。</p>\n<p><code>$nextTick</code>：可以保证页面中结构一定是有的，经常和很多插件一起使用，这些插件都需要<code>DOM</code>已经存在了。</p>\n<h3 id=\"v-for-为什么不能和-v-if-一起使用\"><a href=\"#v-for-为什么不能和-v-if-一起使用\" class=\"headerlink\" title=\"v-for 为什么不能和 v-if 一起使用\"></a>v-for 为什么不能和 v-if 一起使用</h3><p>在官方文档中明确指出 v-for 和 v-if 不建议一起使用。</p>\n<p>原因：<code>v-for</code>比<code>v-if</code>优先级高，所以一起使用的话，每次<code>v-for</code>都会执行<code>v-if</code>,造成不必要的计算，影响性能，尤其是当之需要渲染很小一部分的时候。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>ul</span><span class=\"token punctuation\">></span></span>\n\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>li</span> <span class=\"token attr-name\">v-for</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>user in users<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">v-if</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>user.isActive<span class=\"token punctuation\">\"</span></span> <span class=\"token attr-name\">:key</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>user.id<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n\t\t&#123;&#123; user.name &#125;&#125;\n\t<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>li</span><span class=\"token punctuation\">></span></span>\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>ul</span><span class=\"token punctuation\">></span></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>如上述情况，即使有<code>100</code>个<code>user</code>中只有一个需要使用<code>v-if</code>，也需要整个循环数组，这在性能上是极大的浪费。</p>\n<p>那难道就没有更好的解决办法，回答：当然是有解决方法的；我们可以使用<code>computed</code></p>\n<p>示例：</p>\n<pre class=\"line-numbers language-vue\" data-language=\"vue\"><code class=\"language-vue\">&lt;div&gt;\n\t&lt;div v-for&#x3D;&quot;(user,index) in activeUsers&quot; :key&#x3D;&quot;user.index&quot; &gt;\n\t\t&#123;&#123; user.name &#125;&#125;\n\t&lt;&#x2F;div&gt;\n&lt;&#x2F;div&gt;\ndata () &#123;  &#x2F;&#x2F; 业务逻辑里面定义的数据\n    return &#123;\n      users,: [&#123;\n        name: &#39;111111&#39;,\n        isShow: true\n      &#125;, &#123;\n        name: &#39;22222&#39;,\n        isShow: false\n      &#125;]\n    &#125;\n  &#125;\ncomputed: &#123;\n\tactiveUsers: function () &#123;\n\t\treturn this.users.filter(function (user) &#123;\n\t\t\treturn user.isShow;&#x2F;&#x2F;返回isShow&#x3D;true的项，添加到activeUsers数组\n\t\t&#125;)\n\t&#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>总结：<code>v-if</code>比<code>v-for</code>优先级高，一起使用在性能上会造成极大的浪费，并且官网也并不推荐我们这样做，所以我们可以选择使用<code>computed</code>过滤掉列表中不需要显示的项目。</p>\n<h3 id=\"VueRouter-路由器的两种工作模式\"><a href=\"#VueRouter-路由器的两种工作模式\" class=\"headerlink\" title=\"VueRouter 路由器的两种工作模式\"></a><code>VueRouter</code> 路由器的两种工作模式</h3><ol>\n<li>对于一个<code>url</code>来说，什么是<code>hash</code>值？—— <code>#</code>及其后面的内容就是<code>hash</code>值。</li>\n<li><code>hash</code> 值不会包含在 <code>HTTP</code> 请求中，即：<code>hash</code> 值不会带给服务器。</li>\n<li><code>hash</code>模式：<ol>\n<li>地址中永远带着<code>#</code>号，不美观 。</li>\n<li>若以后将地址通过第三方手机<code>app</code>分享，若 <code>app</code> 校验严格，则地址会被标记为不合法。</li>\n<li>兼容性较好。</li>\n</ol>\n</li>\n<li><code>history</code>模式：<ol>\n<li>地址干净，美观 。</li>\n<li>兼容性和 <code>hash</code> 模式相比略差。</li>\n<li>应用部署上线时需要后端人员支持，解决刷新页面服务端 <code>404</code> 的问题。</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"虚拟DOM中key的作用：\"><a href=\"#虚拟DOM中key的作用：\" class=\"headerlink\" title=\"虚拟DOM中key的作用：\"></a><strong>虚拟<code>DOM</code>中<code>key</code>的作用：</strong></h3><ul>\n<li>简单的说: <code>key</code>是虚拟<code>DOM</code>对象的标识, 在更新显示时<code>key</code>起着极其重要的作用。</li>\n<li>详细的说: 当状态中的数据发生变化时，<code>react</code>会根据【新数据】生成【新的虚拟<code>DOM</code>】, 随后 React 进行【新虚拟<code>DOM</code>】与【旧虚拟<code>DOM</code>】的<code>diff</code>比较，比较规则如下：<ul>\n<li>a.旧虚拟<code>DOM</code>中找到了与新虚拟<code>DOM</code>相同的<code>key</code>：</li>\n<li>(1).若虚拟<code>DOM</code>中内容没变, 直接使用之前的真实<code>DOM</code></li>\n<li>(2).若虚拟<code>DOM</code>中内容变了, 则生成新的真实 DOM，随后替换掉页面中之前的真实<code>DOM</code></li>\n<li>b. 旧虚拟<code>DOM</code>中未找到与新虚拟<code>DOM</code>相同的<code>key</code></li>\n<li>根据数据创建新的真实<code>DOM</code>，随后渲染到到页面</li>\n</ul>\n</li>\n</ul>\n<p><strong>用 index 作为 key 可能会引发的问题：</strong></p>\n<ul>\n<li>若对数据进行：逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实<code>DOM</code>更新 &#x3D;&#x3D;&gt; 界面效果没问题, 但效率低。</li>\n<li>如果结构中还包含输入类的<code>DOM</code>：会产生错误<code>DOM</code>更新 &#x3D;&#x3D;&gt; 界面有问题。</li>\n<li>注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用<code>index</code>作为<code>key</code>是没有问题的。</li>\n</ul>\n","feature":true,"text":"如何理解SPA应用SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变...","link":"","photos":[],"count_time":{"symbolsCount":"18k","symbolsTime":"17 mins."},"categories":[],"tags":[{"name":"面试题","slug":"面试题","count":1,"path":"api/tags/面试题.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3SPA%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">如何理解SPA应用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%89%8D%E7%AB%AF%E7%99%BB%E5%BD%95%E7%9A%84%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">说一下前端登录的流程?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E4%B8%80%E4%B8%8B%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%9A%84%E9%80%BB%E8%BE%91\"><span class=\"toc-text\">说一下购物车的逻辑?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%89%8D%E7%AB%AF%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">说一下前端权限管理怎么实现</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%B8%B8%E8%A7%81%E7%9A%84-git-%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">说一下常见的 git 操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#git-%E8%A7%A3%E5%86%B3%E5%90%88%E5%B9%B6%E5%86%B2%E7%AA%81\"><span class=\"toc-text\">git 解决合并冲突</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E6%8E%92-reflow-%E5%92%8C%E9%87%8D%E7%BB%98-repaint\"><span class=\"toc-text\">重排(reflow)和重绘(repaint)</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#HTML5-%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">HTML5 有哪些新特性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3-cookie%E3%80%81session%E3%80%81localStorage%E3%80%81sessionStorage-%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">理解 cookie、session、localStorage、sessionStorage 关系与区别</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#cookie%E4%B8%8Esession%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">cookie与session的区别</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#localStorage-%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">localStorage 的特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#sessionStorage%E7%9A%84%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">sessionStorage的特点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#localStorage%E4%B8%8EsessionStorage%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">localStorage与sessionStorage的区别</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#px%E3%80%81em%E3%80%81rem%E3%80%81vw-%E7%99%BE%E5%88%86%E6%AF%94%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">px、em、rem、vw 百分比的区别</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#forEach%E8%83%BDreturn%E5%90%97\"><span class=\"toc-text\">forEach能return吗</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88-JavaScript-%E4%B8%AD-0-1-0-2-%E2%89%A0-0-3\"><span class=\"toc-text\">为什么 JavaScript 中 0.1 + 0.2 ≠ 0.3</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JavaScript-%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F\"><span class=\"toc-text\">JavaScript 原型，原型链 ? 有什么特点？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#ES6-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">ES6 的新特性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#New-%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%E4%BA%8B%E6%83%85\"><span class=\"toc-text\">New 操作符做了什么事情?</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E7%9A%84this%E6%8C%87%E5%90%91\"><span class=\"toc-text\">箭头函数的this指向</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#async-%E5%92%8C-await\"><span class=\"toc-text\">async 和 await</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Vue-%E7%9A%84-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%E8%80%8C%E4%B8%8D%E5%86%99%E6%88%90%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">Vue 的 data 为什么是一个方法而不写成对象</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Vue-set-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Vue.set 方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#v-model-%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A\"><span class=\"toc-text\">v-model 数据双向绑定</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%84%E4%BB%B6%E9%97%B4%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E7%9A%84%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">组件间数据传递的方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MVVM-%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">MVVM 模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#computed-%E5%92%8C-watch\"><span class=\"toc-text\">computed 和 watch</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#webpack-%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">webpack 构建流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#token-%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4\"><span class=\"toc-text\">token 的过期时间</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%B8%B8%E8%A7%81%E7%9A%84-HTTP-%E7%8A%B6%E6%80%81%E7%A0%81-%E8%AF%B4%E4%B8%80%E4%B8%8B%E7%8A%B6%E6%80%81%E7%A0%81%E6%98%AF-302-%E5%92%8C-304-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F%E4%BD%A0%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%87%BA%E7%8E%B0%E8%BF%87%E4%B9%88%EF%BC%9F%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">说一下常见的 HTTP 状态码?说一下状态码是 302 和 304 是什么意思？你在项目中出现过么？你是怎么解决的？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%88%91%E4%BB%AC%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5-URL-%E5%B9%B6%E5%9B%9E%E8%BD%A6%E5%90%8E%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">我们在浏览器中输入 URL 并回车后都发生了什么？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%8F%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">微任务和宏任务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E5%BC%8F%E5%BC%80%E5%A7%8B\"><span class=\"toc-text\">正式开始</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BC%80%E5%A7%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">开始分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%89%80%E8%B0%93%E5%BE%AE%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%8F%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">所谓微任务和宏任务</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%B0%E5%BA%95%E5%85%88%E6%89%A7%E8%A1%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E8%BF%98%E6%98%AF%E5%AE%8F%E4%BB%BB%E5%8A%A1\"><span class=\"toc-text\">到底先执行微任务还是宏任务</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">第一个原则</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">第二个原则</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E4%B8%AA%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">第三个原则</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%8E%E4%B9%88%E5%88%86%E8%BE%A8%E5%B1%82%E7%BA%A7%EF%BC%9F\"><span class=\"toc-text\">怎么分辨层级？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%81%87%E5%88%B0%E9%9D%A2%E8%AF%95%E9%A2%98\"><span class=\"toc-text\">遇到面试题</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Vue%E4%B8%AD%E7%9A%84-nextTick%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">Vue中的$nextTick使用场景</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#v-for-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E5%92%8C-v-if-%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">v-for 为什么不能和 v-if 一起使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#VueRouter-%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F\"><span class=\"toc-text\">VueRouter 路由器的两种工作模式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9FDOM%E4%B8%ADkey%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A\"><span class=\"toc-text\">虚拟DOM中key的作用：</span></a></li></ol>","author":{"name":"R桑","slug":"blog-author","avatar":"https://img1.baidu.com/it/u=3256850095,2680786815&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500","link":"/","description":"一位正在重塑知识的技术人 <br /> @ <b>公众号：小k编码</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"back-stage","uid":"fc5e39806758c28d6affaf6d452a0421","slug":"back-stage","date":"2022-07-10T03:28:23.000Z","updated":"2022-07-11T12:50:25.289Z","comments":true,"path":"api/articles/back-stage.json","keywords":null,"cover":null,"text":"6 种组件间通信方式一、 props 适用场景：父子组件通信 注意事项： 如果父组件给子组件传递函数：本质其实是希望子组件给父组件传递数据 如果父组件给子组件传递的数据（非函数）：本质就是父组件直接给子组件传递数据 props 书写方式：3 种 [&#39;todos&#39;]...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Vue","slug":"Vue","count":2,"path":"api/tags/Vue.json"}],"author":{"name":"R桑","slug":"blog-author","avatar":"https://img1.baidu.com/it/u=3256850095,2680786815&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500","link":"/","description":"一位正在重塑知识的技术人 <br /> @ <b>公众号：小k编码</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"promise.all与promise.race的应用","uid":"6cf6ea53457bfcb2a915aa71f05e8d96","slug":"promise-all与promise-race的应用","date":"2022-06-14T05:28:44.000Z","updated":"2022-06-14T05:30:10.635Z","comments":true,"path":"api/articles/promise-all与promise-race的应用.json","keywords":null,"cover":null,"text":"将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化 const preloadImage = function (path) &#123; return new Promise(function (resolve, reject) &#123; co...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Promise","slug":"Promise","count":1,"path":"api/tags/Promise.json"}],"author":{"name":"R桑","slug":"blog-author","avatar":"https://img1.baidu.com/it/u=3256850095,2680786815&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500","link":"/","description":"一位正在重塑知识的技术人 <br /> @ <b>公众号：小k编码</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}