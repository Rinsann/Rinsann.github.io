{"title":"我们在浏览器中输入URL并回车后都发生了什么？","uid":"c9bf0a586238a4fe73dc5b5acc64d356","slug":"我们在浏览器中输入URL并回车后都发生了什么？","date":"2022-06-01T09:27:47.000Z","updated":"2022-06-02T06:00:35.270Z","comments":true,"path":"api/articles/我们在浏览器中输入URL并回车后都发生了什么？.json","keywords":null,"cover":[],"content":"<p><img src=\"/../images/%E6%88%91%E4%BB%AC%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5URL%E5%B9%B6%E5%9B%9E%E8%BD%A6%E5%90%8E%E9%83%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/url.png\" alt=\"url\"></p>\n<h2 id=\"一、解析-URL\"><a href=\"#一、解析-URL\" class=\"headerlink\" title=\"一、解析 URL\"></a>一、解析 URL</h2><p><code>URL</code>（<code>Universal Resource Locator</code>）：统一资源定位符。俗称网页地址或者网址。<br><code>URL</code>用来表示某个资源的地址。（通过俗称就能看出来）</p>\n<p>URL 主要由以下几个部分组成：</p>\n<ol>\n<li>传输协议</li>\n<li>服务器</li>\n<li>域名</li>\n<li>端口</li>\n<li>虚拟目录</li>\n<li>文件名</li>\n<li>锚</li>\n<li>参数</li>\n</ol>\n<p>现在来讨论<code>URL</code>解析，当在浏览器中输入<code>URL</code>后，浏览器首先对拿到的<code>URL</code>进行识别，抽取出域名字段。</p>\n<h2 id=\"二、DNS-解析\"><a href=\"#二、DNS-解析\" class=\"headerlink\" title=\"二、DNS 解析\"></a>二、DNS 解析</h2><p><code>DNS</code>解析（域名解析），<code>DNS</code>实际上是一个域名和<code>IP</code>对应的数据库。</p>\n<p><code>IP</code>地址往都难以记住，但机器间互相只认<code>IP</code>地址，于是人们发明了域名，让域名与<code>IP</code>地址之间一一对应，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，整个过程是自动进行的。</p>\n<p>可以在浏览器中输入<code>IP</code>地址浏览网站，也可以输入域名查询网站，虽然得出的内容是一样的，但是调用的过程不一样，输入<code>IP</code>地址是直接从主机上调用内容，输入域名是通过域名解析服务器指向对应的主机的<code>IP</code>地址，再从主机调用网站的内容。</p>\n<p>在进行<code>DNS</code>解析时，会经历以下步骤：</p>\n<ol>\n<li><p>查询浏览器缓存（浏览器会缓存之前拿到的<code>DNS</code> 2-30 分钟时间），如果没有找到，那么-&gt;</p>\n</li>\n<li><p>检查系统缓存，检查<code>hosts</code>文件，这个文件保存了一些以前访问过的网站的域名和<code>IP</code>的数据。它就像是一个本地的数据库。如果找到就可以直接获取目标主机的<code>IP</code>地址了。没有找到的话，那么-&gt;</p>\n</li>\n<li><p>检查路由器缓存，路由器有自己的<code>DNS</code>缓存，可能就包括了这在查询的内容；如果没有，那么-&gt;</p>\n</li>\n<li><p>查询<code>ISP DNS</code> 缓存：<code>ISP</code>服务商<code>DNS</code>缓存（本地服务器缓存）那里可能有相关的内容，如果还不行的话，那么-&gt;</p>\n</li>\n<li><p>递归查询：从根域名服务器到顶级域名服务器再到极限域名服务器依次搜索对应目标域名的<code>IP</code>。</p>\n</li>\n</ol>\n<p>通过以上的查找，就可以获取到域名对应的<code>IP</code>了。接下来就是向该<code>IP</code>地址定位的<code>HTTP</code>服务器发起<code>TCP</code>连接。</p>\n<h2 id=\"三、浏览器与网站建立-TCP-连接（三次握手）\"><a href=\"#三、浏览器与网站建立-TCP-连接（三次握手）\" class=\"headerlink\" title=\"三、浏览器与网站建立 TCP 连接（三次握手）\"></a>三、浏览器与网站建立 TCP 连接（三次握手）</h2><p>第一次握手：客户端向服务器端发送请求（SYN&#x3D;1） 等待服务器确认；</p>\n<p>第二次握手：服务器收到请求并确认，回复一个指令（SYN&#x3D;1，ACK&#x3D;1）；</p>\n<p>第三次握手：客户端收到服务器的回复指令并返回确认（ACK&#x3D;1）。</p>\n<p>通过三次握手，建立了客户端和服务器之间的连接，现在可以请求和传输数据了。</p>\n<h2 id=\"四、请求和传输数据\"><a href=\"#四、请求和传输数据\" class=\"headerlink\" title=\"四、请求和传输数据\"></a>四、请求和传输数据</h2><p>比如要通过<code>get</code>请求访 <a href=\"https://links.jianshu.com/go?to=http://www.dydh.org/\">http://www.dydh.org/</a>，通过抓包可以看到：</p>\n<ul>\n<li>请求网址（<code>url</code>）：<a href=\"https://links.jianshu.com/go?to=http://www.dydh.org/\">http://www.dydh.org/</a></li>\n<li>请求方法：<code>GET</code></li>\n<li>远程地址：<code>IP</code></li>\n<li>状态码：200 OK</li>\n<li>HTTP 版本： <code>HTTP/1.1</code></li>\n<li>请求头： …</li>\n<li>响应头： …</li>\n</ul>\n<p>响应头中有一个：<code>Set-Cookie:&quot;PHPSESSID=c882giens9f7d3oglcakhrl994;</code> <code>path=/&quot;\\****</code>，说明浏览器中没有关于这个网站的<code>cookie</code>信息。</p>\n<p>当我们下一次访问相同的网站时：</p>\n<p>可以看到，请求头中包含了这个<code>cookie</code>信息，</p>\n<p><code>Cookie:&quot;PHPSESSID=c882giens9f7d3oglcakhrl994; CNZZDATA1253283365=1870471808-1473694656-%7C1473694656&quot;</code></p>\n<p><code>cookie</code>可以用来保存一些有用的信息：<code>Cookies</code>如果是首次访问，会提示服务器建立用户缓存信息，如果不是，可以利用<code>Cookies</code>对应键值，找到相应缓存，缓存里面存放着用户名，密码和一些用户设置项。</p>\n<p>通过这种<code>GET</code>请求，和服务器的响应。可以将服务器上的目标文件传输到浏览器进行渲染。</p>\n<h2 id=\"关闭TCP连接\"><a href=\"#关闭TCP连接\" class=\"headerlink\" title=\"关闭TCP连接\"></a>关闭TCP连接</h2><ol>\n<li>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置<code>Sequence Number和Acknowledgment Number</code>，向主机2发送一个<code>FIN</code>报文段；此时，主机1进入<code>FIN_WAIT_1</code>状态；这表示主机1没有数据要发送给主机2了；</li>\n<li>第二次挥手：主机2收到了主机1发送的<code>FIN</code>报文段，向主机1回一个<code>ACK</code>报文段，<code>Acknowledgment Number为Sequence Number</code>加1；主机1进入<code>FIN_WAIT_2</code>状态；主机2告诉主机1，我”同意”你的关闭请求；</li>\n<li>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入<code>LAST_ACK</code>状态；</li>\n<li>第四次挥手：主机1收到主机2发送的<code>FIN</code>报文段，向主机2发送<code>ACK</code>报文段，然后主机1进入<code>TIME_WAIT</code>状态；主机2收到主机1的<code>ACK</code>报文段以后，就关闭连接；此时，主机1等待<code>2MSL</code>后依然没有收到回复，则证明<code>Server</code>端已正常关闭，那好，主机1也可以关闭连接了</li>\n</ol>\n<h2 id=\"五、浏览器渲染页面\"><a href=\"#五、浏览器渲染页面\" class=\"headerlink\" title=\"五、浏览器渲染页面\"></a>五、浏览器渲染页面</h2><p>客户端拿到服务器端传输来的文件，找到<code>HTML</code>和<code>MIME</code>文件，通过<code>MIME</code>文件，浏览器知道要用页面渲染引擎来处理<code>HTML</code>文件。</p>\n<ol>\n<li><p>浏览器会解析<code>html</code>源码，然后创建一个 <code>DOM</code>树。</p>\n<ul>\n<li>在<code>DOM</code>树中，每一个<code>HTML</code>标签都有一个对应的节点，并且每一个文本也都会有一个对应的文本节点。</li>\n</ul>\n</li>\n<li><p>浏览器解析<code>CSS</code>代码，计算出最终的样式数据，形成<code>css</code>对象模型<code>CSSOM</code>。</p>\n<ul>\n<li>首先会忽略非法的<code>CSS</code>代码，之后按照浏览器默认设置——用户设置——外链样式——内联样式——<code>HTML</code>中的<code>style</code>样式顺序进行渲染。</li>\n</ul>\n</li>\n<li><p>利用<code>DOM</code>和<code>CSSOM</code>构建一个渲染树（<code>rendering tree</code>）。</p>\n<ul>\n<li>渲染树和<code>DOM</code>树有点像，但是是有区别的。</li>\n<li><code>DOM</code>树完全和<code>html</code>标签一一对应，但是渲染树会忽略掉不需要渲染的元素，比如<code>head</code>、<code>display:none</code>的元素等。</li>\n<li>而且一大段文本中的每一个行在渲染树中都是独立的一个节点，渲染树中的每一个节点都存储有对应的<code>css</code>属性。</li>\n</ul>\n</li>\n<li><p>浏览器就根据渲染树直接把页面绘制到屏幕上</p>\n</li>\n</ol>\n","text":" 一、解析 URLURL（Universal Resource Locator）：统一资源定位符。俗称网页地址或者网址。URL用来表示某个资源的地址。（通过俗称就能看出来） URL 主要由以下几个部分组成： 传输协议 服务器 域名 端口 虚拟目录 文件名 锚 参数 现在来讨论UR...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"HTTP","slug":"HTTP","count":2,"path":"api/tags/HTTP.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E8%A7%A3%E6%9E%90-URL\"><span class=\"toc-text\">一、解析 URL</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81DNS-%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">二、DNS 解析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E7%BD%91%E7%AB%99%E5%BB%BA%E7%AB%8B-TCP-%E8%BF%9E%E6%8E%A5%EF%BC%88%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%89\"><span class=\"toc-text\">三、浏览器与网站建立 TCP 连接（三次握手）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81%E8%AF%B7%E6%B1%82%E5%92%8C%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">四、请求和传输数据</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%97%ADTCP%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">关闭TCP连接</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%94%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2\"><span class=\"toc-text\">五、浏览器渲染页面</span></a></li></ol>","author":{"name":"R桑","slug":"blog-author","avatar":"https://img1.baidu.com/it/u=3256850095,2680786815&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500","link":"/","description":"一位正在重塑知识的技术人 <br /> @ <b>公众号：小k编码</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"小程序开发","uid":"13faca11ddbbdde1b46790dd04adcbcb","slug":"小程序开发","date":"2022-06-09T15:38:00.000Z","updated":"2022-07-11T08:58:02.841Z","comments":true,"path":"api/articles/小程序开发.json","keywords":null,"cover":[],"text":"只需要在 app.json -&gt; pages 中新增页面存放路径。小程序开发者工具即可帮我们自动创建对于的页面文件 pages 配置项中的第一行默认为小程序的首页。 WXML 模板一、什么是WXML WXML（WeiXin Markup Language） 是小程序框架设计...","link":"","photos":[],"count_time":{"symbolsCount":"1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"小程序","slug":"小程序","count":1,"path":"api/tags/小程序.json"}],"author":{"name":"R桑","slug":"blog-author","avatar":"https://img1.baidu.com/it/u=3256850095,2680786815&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500","link":"/","description":"一位正在重塑知识的技术人 <br /> @ <b>公众号：小k编码</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Fetch的使用-关注分离思想","uid":"e9014eb277f72a7198d4ff54563938a4","slug":"Fetch的使用-关注分离思想","date":"2022-05-30T13:42:00.000Z","updated":"2022-06-01T09:37:47.591Z","comments":true,"path":"api/articles/Fetch的使用-关注分离思想.json","keywords":null,"cover":null,"text":"一1.拆分组件、实现静态组件，注意：className、style的写法 2.动态初始化列表，如何确定将数据放在那个组件的state中？—— 某个组件使用：放在自身的state中—— 某些组件使用：放在他们共同的父组件 state 中(官方称为：状态提升) 3.关于父子之间的通信...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"HTTP","slug":"HTTP","count":2,"path":"api/tags/HTTP.json"}],"author":{"name":"R桑","slug":"blog-author","avatar":"https://img1.baidu.com/it/u=3256850095,2680786815&fm=253&fmt=auto&app=138&f=JPEG?w=500&h=500","link":"/","description":"一位正在重塑知识的技术人 <br /> @ <b>公众号：小k编码</b>","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}